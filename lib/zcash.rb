# frozen_string_literal: true

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .rb file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Ruby
# helpers directly inline like we're doing here.

require 'ffi'

module Zcash
  def self.uniffi_in_range(i, type_name, min, max)
    raise TypeError, "no implicit conversion of #{i} into Integer" unless i.respond_to?(:to_int)

    i = i.to_int
    raise RangeError, "#{type_name} requires #{min} <= value < #{max}" unless min <= i && i < max

    i
  end

  def self.uniffi_utf8(v)
    raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)

    v = v.to_str.encode(Encoding::UTF_8)
    raise Encoding::InvalidByteSequenceError, 'not a valid UTF-8 encoded string' unless v.valid_encoding?

    v
  end

  def self.uniffi_bytes(v)
    raise TypeError, "no implicit conversion of #{v} into String" unless v.respond_to?(:to_str)

    v.to_str
  end

  class RustBuffer < FFI::Struct
    layout :capacity, :int32,
           :len,      :int32,
           :data,     :pointer

    def self.alloc(size)
      Zcash.rust_call(:ffi_uniffi_zcash_rustbuffer_alloc, size)
    end

    def self.reserve(rbuf, additional)
      Zcash.rust_call(:ffi_uniffi_zcash_rustbuffer_reserve, rbuf, additional)
    end

    def free
      Zcash.rust_call(:ffi_uniffi_zcash_rustbuffer_free, self)
    end

    def capacity
      self[:capacity]
    end

    def len
      self[:len]
    end

    def len=(value)
      self[:len] = value
    end

    def data
      self[:data]
    end

    def to_s
      "RustBuffer(capacity=#{capacity}, len=#{len}, data=#{data.read_bytes len})"
    end

    # The allocated buffer will be automatically freed if an error occurs, ensuring that
    # we don't accidentally leak it.
    def self.allocWithBuilder
      builder = RustBufferBuilder.new

      begin
        yield builder
      rescue StandardError => e
        builder.discard
        raise e
      end
    end

    # The RustBuffer will be freed once the context-manager exits, ensuring that we don't
    # leak it even if an error occurs.
    def consumeWithStream
      stream = RustBufferStream.new self

      yield stream

      raise 'junk data left in buffer after consuming' if stream.remaining != 0
    ensure
      free
    end

    def self.allocFromString(value)
      RustBuffer.allocWithBuilder do |builder|
        builder.write value.encode('utf-8')
        return builder.finalize
      end
    end

    def consumeIntoString
      consumeWithStream do |stream|
        return stream.read(stream.remaining).force_encoding(Encoding::UTF_8)
      end
    end

    # The Record type TripleSaplingNullifierMap.

    def self.alloc_from_TypeTripleSaplingNullifierMap(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeTripleSaplingNullifierMap(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeTripleSaplingNullifierMap
      consumeWithStream do |stream|
        return stream.readTypeTripleSaplingNullifierMap
      end
    end

    # The Record type TupleAccountIdAndSaplingNote.

    def self.alloc_from_TypeTupleAccountIdAndSaplingNote(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeTupleAccountIdAndSaplingNote(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeTupleAccountIdAndSaplingNote
      consumeWithStream do |stream|
        return stream.readTypeTupleAccountIdAndSaplingNote
      end
    end

    # The Record type TupleAccountIdAndSaplingNullifier.

    def self.alloc_from_TypeTupleAccountIdAndSaplingNullifier(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeTupleAccountIdAndSaplingNullifier(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeTupleAccountIdAndSaplingNullifier
      consumeWithStream do |stream|
        return stream.readTypeTupleAccountIdAndSaplingNullifier
      end
    end

    # The Record type TupleAccountIdAndUnifiedSpendingKey.

    def self.alloc_from_TypeTupleAccountIdAndUnifiedSpendingKey(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeTupleAccountIdAndUnifiedSpendingKey(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeTupleAccountIdAndUnifiedSpendingKey
      consumeWithStream do |stream|
        return stream.readTypeTupleAccountIdAndUnifiedSpendingKey
      end
    end

    # The Record type TupleBlockHeightAndHash.

    def self.alloc_from_TypeTupleBlockHeightAndHash(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeTupleBlockHeightAndHash(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeTupleBlockHeightAndHash
      consumeWithStream do |stream|
        return stream.readTypeTupleBlockHeightAndHash
      end
    end

    # The Record type TupleSaplingCommitments.

    def self.alloc_from_TypeTupleSaplingCommitments(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeTupleSaplingCommitments(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeTupleSaplingCommitments
      consumeWithStream do |stream|
        return stream.readTypeTupleSaplingCommitments
      end
    end

    # The Record type TupleTargetAndAnchorHeight.

    def self.alloc_from_TypeTupleTargetAndAnchorHeight(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeTupleTargetAndAnchorHeight(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeTupleTargetAndAnchorHeight
      consumeWithStream do |stream|
        return stream.readTypeTupleTargetAndAnchorHeight
      end
    end

    # The Record type ZcashAccountId.

    def self.alloc_from_TypeZcashAccountId(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashAccountId(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashAccountId
      consumeWithStream do |stream|
        return stream.readTypeZcashAccountId
      end
    end

    # The Record type ZcashAuthPath.

    def self.alloc_from_TypeZcashAuthPath(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashAuthPath(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashAuthPath
      consumeWithStream do |stream|
        return stream.readTypeZcashAuthPath
      end
    end

    # The Record type ZcashDiversifierIndexAndPaymentAddress.

    def self.alloc_from_TypeZcashDiversifierIndexAndPaymentAddress(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashDiversifierIndexAndPaymentAddress(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashDiversifierIndexAndPaymentAddress
      consumeWithStream do |stream|
        return stream.readTypeZcashDiversifierIndexAndPaymentAddress
      end
    end

    # The Record type ZcashDiversifierIndexAndScope.

    def self.alloc_from_TypeZcashDiversifierIndexAndScope(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashDiversifierIndexAndScope(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashDiversifierIndexAndScope
      consumeWithStream do |stream|
        return stream.readTypeZcashDiversifierIndexAndScope
      end
    end

    # The Record type ZcashInternalOvkExternalOvk.

    def self.alloc_from_TypeZcashInternalOvkExternalOvk(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashInternalOvkExternalOvk(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashInternalOvkExternalOvk
      consumeWithStream do |stream|
        return stream.readTypeZcashInternalOvkExternalOvk
      end
    end

    # The Record type ZcashOrchardDecryptOutput.

    def self.alloc_from_TypeZcashOrchardDecryptOutput(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashOrchardDecryptOutput(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashOrchardDecryptOutput
      consumeWithStream do |stream|
        return stream.readTypeZcashOrchardDecryptOutput
      end
    end

    # The Record type ZcashOrchardDecryptOutputForIncomingKeys.

    def self.alloc_from_TypeZcashOrchardDecryptOutputForIncomingKeys(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashOrchardDecryptOutputForIncomingKeys(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashOrchardDecryptOutputForIncomingKeys
      consumeWithStream do |stream|
        return stream.readTypeZcashOrchardDecryptOutputForIncomingKeys
      end
    end

    # The Record type ZcashOrchardDecryptOutputForOutgoingKeys.

    def self.alloc_from_TypeZcashOrchardDecryptOutputForOutgoingKeys(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashOrchardDecryptOutputForOutgoingKeys(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashOrchardDecryptOutputForOutgoingKeys
      consumeWithStream do |stream|
        return stream.readTypeZcashOrchardDecryptOutputForOutgoingKeys
      end
    end

    # The Record type ZcashOrchardTransmittedNoteCiphertext.

    def self.alloc_from_TypeZcashOrchardTransmittedNoteCiphertext(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashOrchardTransmittedNoteCiphertext(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashOrchardTransmittedNoteCiphertext
      consumeWithStream do |stream|
        return stream.readTypeZcashOrchardTransmittedNoteCiphertext
      end
    end

    # The Record type ZcashPayment.

    def self.alloc_from_TypeZcashPayment(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashPayment(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashPayment
      consumeWithStream do |stream|
        return stream.readTypeZcashPayment
      end
    end

    # The Record type ZcashPaymentParam.

    def self.alloc_from_TypeZcashPaymentParam(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashPaymentParam(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashPaymentParam
      consumeWithStream do |stream|
        return stream.readTypeZcashPaymentParam
      end
    end

    # The Record type ZcashSentTransaction.

    def self.alloc_from_TypeZcashSentTransaction(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashSentTransaction(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashSentTransaction
      consumeWithStream do |stream|
        return stream.readTypeZcashSentTransaction
      end
    end

    # The Record type ZcashTransactionAndSaplingMetadata.

    def self.alloc_from_TypeZcashTransactionAndSaplingMetadata(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashTransactionAndSaplingMetadata(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashTransactionAndSaplingMetadata
      consumeWithStream do |stream|
        return stream.readTypeZcashTransactionAndSaplingMetadata
      end
    end

    # The Record type ZcashTransparentAddressAndIndex.

    def self.alloc_from_TypeZcashTransparentAddressAndIndex(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashTransparentAddressAndIndex(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashTransparentAddressAndIndex
      consumeWithStream do |stream|
        return stream.readTypeZcashTransparentAddressAndIndex
      end
    end

    # The Record type ZcashUnifiedAddressAndDiversifierIndex.

    def self.alloc_from_TypeZcashUnifiedAddressAndDiversifierIndex(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashUnifiedAddressAndDiversifierIndex(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashUnifiedAddressAndDiversifierIndex
      consumeWithStream do |stream|
        return stream.readTypeZcashUnifiedAddressAndDiversifierIndex
      end
    end

    # The Enum type ZcashBranchId.

    def self.alloc_from_TypeZcashBranchId(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashBranchId(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashBranchId
      consumeWithStream do |stream|
        return stream.readTypeZcashBranchId
      end
    end

    # The Enum type ZcashChildIndex.

    def self.alloc_from_TypeZcashChildIndex(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashChildIndex(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashChildIndex
      consumeWithStream do |stream|
        return stream.readTypeZcashChildIndex
      end
    end

    # The Enum type ZcashConsensusParameters.

    def self.alloc_from_TypeZcashConsensusParameters(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashConsensusParameters(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashConsensusParameters
      consumeWithStream do |stream|
        return stream.readTypeZcashConsensusParameters
      end
    end

    # The Enum type ZcashDustAction.

    def self.alloc_from_TypeZcashDustAction(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashDustAction(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashDustAction
      consumeWithStream do |stream|
        return stream.readTypeZcashDustAction
      end
    end

    # The Enum type ZcashFeeRules.

    def self.alloc_from_TypeZcashFeeRules(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashFeeRules(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashFeeRules
      consumeWithStream do |stream|
        return stream.readTypeZcashFeeRules
      end
    end

    # The Enum type ZcashKeySeed.

    def self.alloc_from_TypeZcashKeySeed(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashKeySeed(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashKeySeed
      consumeWithStream do |stream|
        return stream.readTypeZcashKeySeed
      end
    end

    # The Enum type ZcashKeysEra.

    def self.alloc_from_TypeZcashKeysEra(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashKeysEra(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashKeysEra
      consumeWithStream do |stream|
        return stream.readTypeZcashKeysEra
      end
    end

    # The Enum type ZcashMemo.

    def self.alloc_from_TypeZcashMemo(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashMemo(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashMemo
      consumeWithStream do |stream|
        return stream.readTypeZcashMemo
      end
    end

    # The Enum type ZcashNullifierQuery.

    def self.alloc_from_TypeZcashNullifierQuery(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashNullifierQuery(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashNullifierQuery
      consumeWithStream do |stream|
        return stream.readTypeZcashNullifierQuery
      end
    end

    # The Enum type ZcashOrchardScope.

    def self.alloc_from_TypeZcashOrchardScope(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashOrchardScope(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashOrchardScope
      consumeWithStream do |stream|
        return stream.readTypeZcashOrchardScope
      end
    end

    # The Enum type ZcashOvkPolicy.

    def self.alloc_from_TypeZcashOvkPolicy(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashOvkPolicy(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashOvkPolicy
      consumeWithStream do |stream|
        return stream.readTypeZcashOvkPolicy
      end
    end

    # The Enum type ZcashPoolType.

    def self.alloc_from_TypeZcashPoolType(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashPoolType(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashPoolType
      consumeWithStream do |stream|
        return stream.readTypeZcashPoolType
      end
    end

    # The Enum type ZcashRecipient.

    def self.alloc_from_TypeZcashRecipient(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashRecipient(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashRecipient
      consumeWithStream do |stream|
        return stream.readTypeZcashRecipient
      end
    end

    # The Enum type ZcashRseed.

    def self.alloc_from_TypeZcashRseed(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashRseed(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashRseed
      consumeWithStream do |stream|
        return stream.readTypeZcashRseed
      end
    end

    # The Enum type ZcashScanPriority.

    def self.alloc_from_TypeZcashScanPriority(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashScanPriority(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashScanPriority
      consumeWithStream do |stream|
        return stream.readTypeZcashScanPriority
      end
    end

    # The Enum type ZcashScope.

    def self.alloc_from_TypeZcashScope(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashScope(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashScope
      consumeWithStream do |stream|
        return stream.readTypeZcashScope
      end
    end

    # The Enum type ZcashShieldedProtocol.

    def self.alloc_from_TypeZcashShieldedProtocol(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashShieldedProtocol(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashShieldedProtocol
      consumeWithStream do |stream|
        return stream.readTypeZcashShieldedProtocol
      end
    end

    # The Enum type ZcashTransferType.

    def self.alloc_from_TypeZcashTransferType(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashTransferType(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashTransferType
      consumeWithStream do |stream|
        return stream.readTypeZcashTransferType
      end
    end

    # The Enum type ZcashTxVersionSelection.

    def self.alloc_from_TypeZcashTxVersionSelection(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_TypeZcashTxVersionSelection(v)
        return builder.finalize
      end
    end

    def consumeIntoTypeZcashTxVersionSelection
      consumeWithStream do |stream|
        return stream.readTypeZcashTxVersionSelection
      end
    end

    # The Optional<T> type for u64.

    def self.alloc_from_Optionalu64(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_Optionalu64(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalu64
      consumeWithStream do |stream|
        return stream.readOptionalu64
      end
    end

    # The Optional<T> type for string.

    def self.alloc_from_Optionalstring(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_Optionalstring(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalstring
      consumeWithStream do |stream|
        return stream.readOptionalstring
      end
    end

    # The Optional<T> type for TypeZcashAccountPubKey.

    def self.alloc_from_OptionalTypeZcashAccountPubKey(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashAccountPubKey(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashAccountPubKey
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashAccountPubKey
      end
    end

    # The Optional<T> type for TypeZcashAmount.

    def self.alloc_from_OptionalTypeZcashAmount(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashAmount(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashAmount
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashAmount
      end
    end

    # The Optional<T> type for TypeZcashBlockHash.

    def self.alloc_from_OptionalTypeZcashBlockHash(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashBlockHash(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashBlockHash
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashBlockHash
      end
    end

    # The Optional<T> type for TypeZcashBlockHeight.

    def self.alloc_from_OptionalTypeZcashBlockHeight(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashBlockHeight(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashBlockHeight
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashBlockHeight
      end
    end

    # The Optional<T> type for TypeZcashBlockMeta.

    def self.alloc_from_OptionalTypeZcashBlockMeta(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashBlockMeta(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashBlockMeta
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashBlockMeta
      end
    end

    # The Optional<T> type for TypeZcashBlockMetadata.

    def self.alloc_from_OptionalTypeZcashBlockMetadata(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashBlockMetadata(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashBlockMetadata
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashBlockMetadata
      end
    end

    # The Optional<T> type for TypeZcashDiversifiableFullViewingKey.

    def self.alloc_from_OptionalTypeZcashDiversifiableFullViewingKey(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashDiversifiableFullViewingKey(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashDiversifiableFullViewingKey
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashDiversifiableFullViewingKey
      end
    end

    # The Optional<T> type for TypeZcashMemoBytes.

    def self.alloc_from_OptionalTypeZcashMemoBytes(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashMemoBytes(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashMemoBytes
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashMemoBytes
      end
    end

    # The Optional<T> type for TypeZcashOrchardAddress.

    def self.alloc_from_OptionalTypeZcashOrchardAddress(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashOrchardAddress(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashOrchardAddress
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashOrchardAddress
      end
    end

    # The Optional<T> type for TypeZcashOrchardBundle.

    def self.alloc_from_OptionalTypeZcashOrchardBundle(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashOrchardBundle(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashOrchardBundle
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashOrchardBundle
      end
    end

    # The Optional<T> type for TypeZcashOrchardDiversifierIndex.

    def self.alloc_from_OptionalTypeZcashOrchardDiversifierIndex(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashOrchardDiversifierIndex(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashOrchardDiversifierIndex
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashOrchardDiversifierIndex
      end
    end

    # The Optional<T> type for TypeZcashOrchardFullViewingKey.

    def self.alloc_from_OptionalTypeZcashOrchardFullViewingKey(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashOrchardFullViewingKey(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashOrchardFullViewingKey
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashOrchardFullViewingKey
      end
    end

    # The Optional<T> type for TypeZcashOrchardOutgoingViewingKey.

    def self.alloc_from_OptionalTypeZcashOrchardOutgoingViewingKey(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashOrchardOutgoingViewingKey(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashOrchardOutgoingViewingKey
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashOrchardOutgoingViewingKey
      end
    end

    # The Optional<T> type for TypeZcashOutgoingViewingKey.

    def self.alloc_from_OptionalTypeZcashOutgoingViewingKey(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashOutgoingViewingKey(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashOutgoingViewingKey
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashOutgoingViewingKey
      end
    end

    # The Optional<T> type for TypeZcashPaymentAddress.

    def self.alloc_from_OptionalTypeZcashPaymentAddress(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashPaymentAddress(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashPaymentAddress
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashPaymentAddress
      end
    end

    # The Optional<T> type for TypeZcashRatio.

    def self.alloc_from_OptionalTypeZcashRatio(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashRatio(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashRatio
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashRatio
      end
    end

    # The Optional<T> type for TypeZcashSaplingBundle.

    def self.alloc_from_OptionalTypeZcashSaplingBundle(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashSaplingBundle(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashSaplingBundle
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashSaplingBundle
      end
    end

    # The Optional<T> type for TypeZcashSaplingMerklePath.

    def self.alloc_from_OptionalTypeZcashSaplingMerklePath(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashSaplingMerklePath(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashSaplingMerklePath
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashSaplingMerklePath
      end
    end

    # The Optional<T> type for TypeZcashTransparentAddress.

    def self.alloc_from_OptionalTypeZcashTransparentAddress(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashTransparentAddress(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashTransparentAddress
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashTransparentAddress
      end
    end

    # The Optional<T> type for TypeZcashTransparentBundle.

    def self.alloc_from_OptionalTypeZcashTransparentBundle(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashTransparentBundle(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashTransparentBundle
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashTransparentBundle
      end
    end

    # The Optional<T> type for TypeZcashUnifiedAddress.

    def self.alloc_from_OptionalTypeZcashUnifiedAddress(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashUnifiedAddress(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashUnifiedAddress
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashUnifiedAddress
      end
    end

    # The Optional<T> type for TypeZcashWalletSummary.

    def self.alloc_from_OptionalTypeZcashWalletSummary(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashWalletSummary(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashWalletSummary
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashWalletSummary
      end
    end

    # The Optional<T> type for TypeTupleAccountIdAndSaplingNote.

    def self.alloc_from_OptionalTypeTupleAccountIdAndSaplingNote(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeTupleAccountIdAndSaplingNote(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeTupleAccountIdAndSaplingNote
      consumeWithStream do |stream|
        return stream.readOptionalTypeTupleAccountIdAndSaplingNote
      end
    end

    # The Optional<T> type for TypeTupleBlockHeightAndHash.

    def self.alloc_from_OptionalTypeTupleBlockHeightAndHash(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeTupleBlockHeightAndHash(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeTupleBlockHeightAndHash
      consumeWithStream do |stream|
        return stream.readOptionalTypeTupleBlockHeightAndHash
      end
    end

    # The Optional<T> type for TypeTupleTargetAndAnchorHeight.

    def self.alloc_from_OptionalTypeTupleTargetAndAnchorHeight(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeTupleTargetAndAnchorHeight(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeTupleTargetAndAnchorHeight
      consumeWithStream do |stream|
        return stream.readOptionalTypeTupleTargetAndAnchorHeight
      end
    end

    # The Optional<T> type for TypeZcashAccountId.

    def self.alloc_from_OptionalTypeZcashAccountId(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashAccountId(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashAccountId
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashAccountId
      end
    end

    # The Optional<T> type for TypeZcashDiversifierIndexAndPaymentAddress.

    def self.alloc_from_OptionalTypeZcashDiversifierIndexAndPaymentAddress(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashDiversifierIndexAndPaymentAddress(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashDiversifierIndexAndPaymentAddress
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashDiversifierIndexAndPaymentAddress
      end
    end

    # The Optional<T> type for TypeZcashDiversifierIndexAndScope.

    def self.alloc_from_OptionalTypeZcashDiversifierIndexAndScope(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashDiversifierIndexAndScope(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashDiversifierIndexAndScope
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashDiversifierIndexAndScope
      end
    end

    # The Optional<T> type for TypeZcashUnifiedAddressAndDiversifierIndex.

    def self.alloc_from_OptionalTypeZcashUnifiedAddressAndDiversifierIndex(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashUnifiedAddressAndDiversifierIndex(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashUnifiedAddressAndDiversifierIndex
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashUnifiedAddressAndDiversifierIndex
      end
    end

    # The Optional<T> type for TypeZcashOrchardScope.

    def self.alloc_from_OptionalTypeZcashOrchardScope(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalTypeZcashOrchardScope(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalTypeZcashOrchardScope
      consumeWithStream do |stream|
        return stream.readOptionalTypeZcashOrchardScope
      end
    end

    # The Optional<T> type for Sequenceu8.

    def self.alloc_from_OptionalSequenceu8(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_OptionalSequenceu8(v)
        return builder.finalize
      end
    end

    def consumeIntoOptionalSequenceu8
      consumeWithStream do |stream|
        return stream.readOptionalSequenceu8
      end
    end

    # The Sequence<T> type for u8.

    def self.alloc_from_Sequenceu8(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_Sequenceu8(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceu8
      consumeWithStream do |stream|
        return stream.readSequenceu8
      end
    end

    # The Sequence<T> type for u32.

    def self.alloc_from_Sequenceu32(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_Sequenceu32(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceu32
      consumeWithStream do |stream|
        return stream.readSequenceu32
      end
    end

    # The Sequence<T> type for u64.

    def self.alloc_from_Sequenceu64(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_Sequenceu64(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceu64
      consumeWithStream do |stream|
        return stream.readSequenceu64
      end
    end

    # The Sequence<T> type for TypeZcashBlockHeight.

    def self.alloc_from_SequenceTypeZcashBlockHeight(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashBlockHeight(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashBlockHeight
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashBlockHeight
      end
    end

    # The Sequence<T> type for TypeZcashBlockMeta.

    def self.alloc_from_SequenceTypeZcashBlockMeta(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashBlockMeta(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashBlockMeta
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashBlockMeta
      end
    end

    # The Sequence<T> type for TypeZcashCommitmentTreeRoot.

    def self.alloc_from_SequenceTypeZcashCommitmentTreeRoot(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashCommitmentTreeRoot(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashCommitmentTreeRoot
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashCommitmentTreeRoot
      end
    end

    # The Sequence<T> type for TypeZcashDecryptedOutput.

    def self.alloc_from_SequenceTypeZcashDecryptedOutput(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashDecryptedOutput(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashDecryptedOutput
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashDecryptedOutput
      end
    end

    # The Sequence<T> type for TypeZcashOrchardAction.

    def self.alloc_from_SequenceTypeZcashOrchardAction(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashOrchardAction(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashOrchardAction
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashOrchardAction
      end
    end

    # The Sequence<T> type for TypeZcashOrchardIncomingViewingKey.

    def self.alloc_from_SequenceTypeZcashOrchardIncomingViewingKey(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashOrchardIncomingViewingKey(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashOrchardIncomingViewingKey
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashOrchardIncomingViewingKey
      end
    end

    # The Sequence<T> type for TypeZcashOrchardMerkleHash.

    def self.alloc_from_SequenceTypeZcashOrchardMerkleHash(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashOrchardMerkleHash(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashOrchardMerkleHash
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashOrchardMerkleHash
      end
    end

    # The Sequence<T> type for TypeZcashOrchardOutgoingViewingKey.

    def self.alloc_from_SequenceTypeZcashOrchardOutgoingViewingKey(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashOrchardOutgoingViewingKey(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashOrchardOutgoingViewingKey
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashOrchardOutgoingViewingKey
      end
    end

    # The Sequence<T> type for TypeZcashOrchardSpendingKey.

    def self.alloc_from_SequenceTypeZcashOrchardSpendingKey(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashOrchardSpendingKey(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashOrchardSpendingKey
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashOrchardSpendingKey
      end
    end

    # The Sequence<T> type for TypeZcashOutPoint.

    def self.alloc_from_SequenceTypeZcashOutPoint(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashOutPoint(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashOutPoint
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashOutPoint
      end
    end

    # The Sequence<T> type for TypeZcashReceivedNoteId.

    def self.alloc_from_SequenceTypeZcashReceivedNoteId(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashReceivedNoteId(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashReceivedNoteId
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashReceivedNoteId
      end
    end

    # The Sequence<T> type for TypeZcashReceivedSaplingNote.

    def self.alloc_from_SequenceTypeZcashReceivedSaplingNote(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashReceivedSaplingNote(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashReceivedSaplingNote
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashReceivedSaplingNote
      end
    end

    # The Sequence<T> type for TypeZcashSaplingNullifier.

    def self.alloc_from_SequenceTypeZcashSaplingNullifier(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashSaplingNullifier(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashSaplingNullifier
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashSaplingNullifier
      end
    end

    # The Sequence<T> type for TypeZcashSaplingOutputDescription.

    def self.alloc_from_SequenceTypeZcashSaplingOutputDescription(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashSaplingOutputDescription(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashSaplingOutputDescription
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashSaplingOutputDescription
      end
    end

    # The Sequence<T> type for TypeZcashSaplingSpendDescription.

    def self.alloc_from_SequenceTypeZcashSaplingSpendDescription(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashSaplingSpendDescription(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashSaplingSpendDescription
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashSaplingSpendDescription
      end
    end

    # The Sequence<T> type for TypeZcashScanRange.

    def self.alloc_from_SequenceTypeZcashScanRange(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashScanRange(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashScanRange
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashScanRange
      end
    end

    # The Sequence<T> type for TypeZcashScannedBlock.

    def self.alloc_from_SequenceTypeZcashScannedBlock(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashScannedBlock(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashScannedBlock
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashScannedBlock
      end
    end

    # The Sequence<T> type for TypeZcashSentTransactionOutput.

    def self.alloc_from_SequenceTypeZcashSentTransactionOutput(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashSentTransactionOutput(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashSentTransactionOutput
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashSentTransactionOutput
      end
    end

    # The Sequence<T> type for TypeZcashTransparentAddress.

    def self.alloc_from_SequenceTypeZcashTransparentAddress(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashTransparentAddress(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashTransparentAddress
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashTransparentAddress
      end
    end

    # The Sequence<T> type for TypeZcashTxIn.

    def self.alloc_from_SequenceTypeZcashTxIn(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashTxIn(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashTxIn
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashTxIn
      end
    end

    # The Sequence<T> type for TypeZcashTxOut.

    def self.alloc_from_SequenceTypeZcashTxOut(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashTxOut(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashTxOut
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashTxOut
      end
    end

    # The Sequence<T> type for TypeZcashWalletSaplingOutput.

    def self.alloc_from_SequenceTypeZcashWalletSaplingOutput(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashWalletSaplingOutput(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashWalletSaplingOutput
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashWalletSaplingOutput
      end
    end

    # The Sequence<T> type for TypeZcashWalletSaplingSpend.

    def self.alloc_from_SequenceTypeZcashWalletSaplingSpend(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashWalletSaplingSpend(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashWalletSaplingSpend
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashWalletSaplingSpend
      end
    end

    # The Sequence<T> type for TypeZcashWalletTransparentOutput.

    def self.alloc_from_SequenceTypeZcashWalletTransparentOutput(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashWalletTransparentOutput(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashWalletTransparentOutput
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashWalletTransparentOutput
      end
    end

    # The Sequence<T> type for TypeZcashWalletTx.

    def self.alloc_from_SequenceTypeZcashWalletTx(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashWalletTx(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashWalletTx
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashWalletTx
      end
    end

    # The Sequence<T> type for TypeTripleSaplingNullifierMap.

    def self.alloc_from_SequenceTypeTripleSaplingNullifierMap(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeTripleSaplingNullifierMap(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeTripleSaplingNullifierMap
      consumeWithStream do |stream|
        return stream.readSequenceTypeTripleSaplingNullifierMap
      end
    end

    # The Sequence<T> type for TypeTupleAccountIdAndSaplingNullifier.

    def self.alloc_from_SequenceTypeTupleAccountIdAndSaplingNullifier(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeTupleAccountIdAndSaplingNullifier(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeTupleAccountIdAndSaplingNullifier
      consumeWithStream do |stream|
        return stream.readSequenceTypeTupleAccountIdAndSaplingNullifier
      end
    end

    # The Sequence<T> type for TypeTupleSaplingCommitments.

    def self.alloc_from_SequenceTypeTupleSaplingCommitments(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeTupleSaplingCommitments(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeTupleSaplingCommitments
      consumeWithStream do |stream|
        return stream.readSequenceTypeTupleSaplingCommitments
      end
    end

    # The Sequence<T> type for TypeZcashAuthPath.

    def self.alloc_from_SequenceTypeZcashAuthPath(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashAuthPath(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashAuthPath
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashAuthPath
      end
    end

    # The Sequence<T> type for TypeZcashOrchardDecryptOutputForIncomingKeys.

    def self.alloc_from_SequenceTypeZcashOrchardDecryptOutputForIncomingKeys(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashOrchardDecryptOutputForIncomingKeys(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashOrchardDecryptOutputForIncomingKeys
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashOrchardDecryptOutputForIncomingKeys
      end
    end

    # The Sequence<T> type for TypeZcashOrchardDecryptOutputForOutgoingKeys.

    def self.alloc_from_SequenceTypeZcashOrchardDecryptOutputForOutgoingKeys(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashOrchardDecryptOutputForOutgoingKeys(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys
      end
    end

    # The Sequence<T> type for TypeZcashPayment.

    def self.alloc_from_SequenceTypeZcashPayment(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashPayment(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashPayment
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashPayment
      end
    end

    # The Sequence<T> type for TypeZcashPaymentParam.

    def self.alloc_from_SequenceTypeZcashPaymentParam(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashPaymentParam(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashPaymentParam
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashPaymentParam
      end
    end

    # The Sequence<T> type for TypeZcashChildIndex.

    def self.alloc_from_SequenceTypeZcashChildIndex(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_SequenceTypeZcashChildIndex(v)
        return builder.finalize
      end
    end

    def consumeIntoSequenceTypeZcashChildIndex
      consumeWithStream do |stream|
        return stream.readSequenceTypeZcashChildIndex
      end
    end

    # The Map<T> type for TypeZcashAccountBalance.

    def self.alloc_from_MapStringTypeZcashAccountBalance(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_MapStringTypeZcashAccountBalance(v)
        return builder.finalize
      end
    end

    def consumeIntoMapStringTypeZcashAccountBalance
      consumeWithStream do |stream|
        return stream.readMapStringTypeZcashAccountBalance
      end
    end

    def self.alloc_from_MapStringTypeZcashAddressMetadata(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_MapStringTypeZcashAddressMetadata(v)
        return builder.finalize
      end
    end

    def consumeIntoMapStringTypeZcashAddressMetadata
      consumeWithStream do |stream|
        return stream.readMapStringTypeZcashAddressMetadata
      end
    end

    def self.alloc_from_MapStringTypeZcashAmount(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_MapStringTypeZcashAmount(v)
        return builder.finalize
      end
    end

    def consumeIntoMapStringTypeZcashAmount
      consumeWithStream do |stream|
        return stream.readMapStringTypeZcashAmount
      end
    end

    def self.alloc_from_MapTypeZcashAccountIdTypeZcashUnifiedFullViewingKey(v)
      RustBuffer.allocWithBuilder do |builder|
        builder.write_MapTypeZcashAccountIdTypeZcashUnifiedFullViewingKey(v)
        return builder.finalize
      end
    end

    def consumeIntoMapTypeZcashAccountIdTypeZcashUnifiedFullViewingKey
      consumeWithStream do |stream|
        return stream.readMapTypeZcashAccountIdTypeZcashUnifiedFullViewingKey
      end
    end
  end

  module UniFFILib
    class ForeignBytes < FFI::Struct
      layout :len,      :int32,
             :data,     :pointer

      def len
        self[:len]
      end

      def data
        self[:data]
      end

      def to_s
        "ForeignBytes(len=#{len}, data=#{data.read_bytes(len)})"
      end
    end
  end

  private_constant :UniFFILib

  # Helper for structured reading of values from a RustBuffer.
  class RustBufferStream
    def initialize(rbuf)
      @rbuf = rbuf
      @offset = 0
    end

    def remaining
      @rbuf.len - @offset
    end

    def read(size)
      raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

      data = @rbuf.data.get_bytes @offset, size

      @offset += size

      data
    end

    def readU8
      unpack_from 1, 'c'
    end

    def readU16
      unpack_from 2, 'S>'
    end

    def readU32
      unpack_from 4, 'L>'
    end

    def readU64
      unpack_from 8, 'Q>'
    end

    def readI64
      unpack_from 8, 'q>'
    end

    def readBool
      v = unpack_from 1, 'c'

      return false if v.zero?
      return true if v == 1

      raise InternalError, 'Unexpected byte for Boolean type'
    end

    def readString
      size = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative string length' if size.negative?

      read(size).force_encoding(Encoding::UTF_8)
    end

    # The Object type MerkleTreeFrontier.

    def readTypeMerkleTreeFrontier
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      MerkleTreeFrontier._uniffi_allocate(pointer)
    end

    # The Object type MerkleTreePosition.

    def readTypeMerkleTreePosition
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      MerkleTreePosition._uniffi_allocate(pointer)
    end

    # The Object type MerkleTreeRetention.

    def readTypeMerkleTreeRetention
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      MerkleTreeRetention._uniffi_allocate(pointer)
    end

    # The Object type SecpSecretKey.

    def readTypeSecpSecretKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      SecpSecretKey._uniffi_allocate(pointer)
    end

    # The Object type TestSupport.

    def readTypeTestSupport
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      TestSupport._uniffi_allocate(pointer)
    end

    # The Object type TimeOffsetDateTime.

    def readTypeTimeOffsetDateTime
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      TimeOffsetDateTime._uniffi_allocate(pointer)
    end

    # The Object type ZcashAccountBalance.

    def readTypeZcashAccountBalance
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashAccountBalance._uniffi_allocate(pointer)
    end

    # The Object type ZcashAccountBirthday.

    def readTypeZcashAccountBirthday
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashAccountBirthday._uniffi_allocate(pointer)
    end

    # The Object type ZcashAccountPrivKey.

    def readTypeZcashAccountPrivKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashAccountPrivKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashAccountPubKey.

    def readTypeZcashAccountPubKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashAccountPubKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashAddressMetadata.

    def readTypeZcashAddressMetadata
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashAddressMetadata._uniffi_allocate(pointer)
    end

    # The Object type ZcashAmount.

    def readTypeZcashAmount
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashAmount._uniffi_allocate(pointer)
    end

    # The Object type ZcashAnchor.

    def readTypeZcashAnchor
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashAnchor._uniffi_allocate(pointer)
    end

    # The Object type ZcashBalance.

    def readTypeZcashBalance
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashBalance._uniffi_allocate(pointer)
    end

    # The Object type ZcashBlockHash.

    def readTypeZcashBlockHash
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashBlockHash._uniffi_allocate(pointer)
    end

    # The Object type ZcashBlockHeight.

    def readTypeZcashBlockHeight
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashBlockHeight._uniffi_allocate(pointer)
    end

    # The Object type ZcashBlockMeta.

    def readTypeZcashBlockMeta
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashBlockMeta._uniffi_allocate(pointer)
    end

    # The Object type ZcashBlockMetadata.

    def readTypeZcashBlockMetadata
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashBlockMetadata._uniffi_allocate(pointer)
    end

    # The Object type ZcashCommitmentTree.

    def readTypeZcashCommitmentTree
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashCommitmentTree._uniffi_allocate(pointer)
    end

    # The Object type ZcashCommitmentTreeRoot.

    def readTypeZcashCommitmentTreeRoot
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashCommitmentTreeRoot._uniffi_allocate(pointer)
    end

    # The Object type ZcashDecryptedOutput.

    def readTypeZcashDecryptedOutput
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashDecryptedOutput._uniffi_allocate(pointer)
    end

    # The Object type ZcashDecryptedTransaction.

    def readTypeZcashDecryptedTransaction
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashDecryptedTransaction._uniffi_allocate(pointer)
    end

    # The Object type ZcashDiversifiableFullViewingKey.

    def readTypeZcashDiversifiableFullViewingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashDiversifiableFullViewingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashDiversifier.

    def readTypeZcashDiversifier
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashDiversifier._uniffi_allocate(pointer)
    end

    # The Object type ZcashDiversifierIndex.

    def readTypeZcashDiversifierIndex
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashDiversifierIndex._uniffi_allocate(pointer)
    end

    # The Object type ZcashDustOutputPolicy.

    def readTypeZcashDustOutputPolicy
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashDustOutputPolicy._uniffi_allocate(pointer)
    end

    # The Object type ZcashExpandedSpendingKey.

    def readTypeZcashExpandedSpendingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashExpandedSpendingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashExtendedFullViewingKey.

    def readTypeZcashExtendedFullViewingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashExtendedFullViewingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashExtendedPrivKey.

    def readTypeZcashExtendedPrivKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashExtendedPrivKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashExtendedSpendingKey.

    def readTypeZcashExtendedSpendingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashExtendedSpendingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashExternalIvk.

    def readTypeZcashExternalIvk
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashExternalIvk._uniffi_allocate(pointer)
    end

    # The Object type ZcashExternalOvk.

    def readTypeZcashExternalOvk
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashExternalOvk._uniffi_allocate(pointer)
    end

    # The Object type ZcashExtractedNoteCommitment.

    def readTypeZcashExtractedNoteCommitment
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashExtractedNoteCommitment._uniffi_allocate(pointer)
    end

    # The Object type ZcashFixedFeeRule.

    def readTypeZcashFixedFeeRule
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashFixedFeeRule._uniffi_allocate(pointer)
    end

    # The Object type ZcashFixedSingleOutputChangeStrategy.

    def readTypeZcashFixedSingleOutputChangeStrategy
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashFixedSingleOutputChangeStrategy._uniffi_allocate(pointer)
    end

    # The Object type ZcashFsBlockDb.

    def readTypeZcashFsBlockDb
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashFsBlockDb._uniffi_allocate(pointer)
    end

    # The Object type ZcashFullViewingKey.

    def readTypeZcashFullViewingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashFullViewingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashIncrementalWitness.

    def readTypeZcashIncrementalWitness
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashIncrementalWitness._uniffi_allocate(pointer)
    end

    # The Object type ZcashInternalIvk.

    def readTypeZcashInternalIvk
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashInternalIvk._uniffi_allocate(pointer)
    end

    # The Object type ZcashInternalOvk.

    def readTypeZcashInternalOvk
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashInternalOvk._uniffi_allocate(pointer)
    end

    # The Object type ZcashJubjubFr.

    def readTypeZcashJubjubFr
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashJubjubFr._uniffi_allocate(pointer)
    end

    # The Object type ZcashKeyIndex.

    def readTypeZcashKeyIndex
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashKeyIndex._uniffi_allocate(pointer)
    end

    # The Object type ZcashLocalTxProver.

    def readTypeZcashLocalTxProver
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashLocalTxProver._uniffi_allocate(pointer)
    end

    # The Object type ZcashMainFixedGreedyInputSelector.

    def readTypeZcashMainFixedGreedyInputSelector
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashMainFixedGreedyInputSelector._uniffi_allocate(pointer)
    end

    # The Object type ZcashMainZip317GreedyInputSelector.

    def readTypeZcashMainZip317GreedyInputSelector
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashMainZip317GreedyInputSelector._uniffi_allocate(pointer)
    end

    # The Object type ZcashMemoBytes.

    def readTypeZcashMemoBytes
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashMemoBytes._uniffi_allocate(pointer)
    end

    # The Object type ZcashNonNegativeAmount.

    def readTypeZcashNonNegativeAmount
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashNonNegativeAmount._uniffi_allocate(pointer)
    end

    # The Object type ZcashNoteId.

    def readTypeZcashNoteId
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashNoteId._uniffi_allocate(pointer)
    end

    # The Object type ZcashNullifierDerivingKey.

    def readTypeZcashNullifierDerivingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashNullifierDerivingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardAction.

    def readTypeZcashOrchardAction
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardAction._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardAddress.

    def readTypeZcashOrchardAddress
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardAddress._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardBundle.

    def readTypeZcashOrchardBundle
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardBundle._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardDiversifier.

    def readTypeZcashOrchardDiversifier
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardDiversifier._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardDiversifierIndex.

    def readTypeZcashOrchardDiversifierIndex
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardDiversifierIndex._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardFlags.

    def readTypeZcashOrchardFlags
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardFlags._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardFullViewingKey.

    def readTypeZcashOrchardFullViewingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardFullViewingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardIncomingViewingKey.

    def readTypeZcashOrchardIncomingViewingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardIncomingViewingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardMerkleHash.

    def readTypeZcashOrchardMerkleHash
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardMerkleHash._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardMerklePath.

    def readTypeZcashOrchardMerklePath
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardMerklePath._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardNote.

    def readTypeZcashOrchardNote
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardNote._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardNoteCommitment.

    def readTypeZcashOrchardNoteCommitment
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardNoteCommitment._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardNoteValue.

    def readTypeZcashOrchardNoteValue
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardNoteValue._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardNullifier.

    def readTypeZcashOrchardNullifier
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardNullifier._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardOutgoingViewingKey.

    def readTypeZcashOrchardOutgoingViewingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardOutgoingViewingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardRandomSeed.

    def readTypeZcashOrchardRandomSeed
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardRandomSeed._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardSpendingKey.

    def readTypeZcashOrchardSpendingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardSpendingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardTransactionBuilder.

    def readTypeZcashOrchardTransactionBuilder
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardTransactionBuilder._uniffi_allocate(pointer)
    end

    # The Object type ZcashOrchardValueCommitment.

    def readTypeZcashOrchardValueCommitment
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOrchardValueCommitment._uniffi_allocate(pointer)
    end

    # The Object type ZcashOutPoint.

    def readTypeZcashOutPoint
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOutPoint._uniffi_allocate(pointer)
    end

    # The Object type ZcashOutgoingViewingKey.

    def readTypeZcashOutgoingViewingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashOutgoingViewingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashPaymentAddress.

    def readTypeZcashPaymentAddress
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashPaymentAddress._uniffi_allocate(pointer)
    end

    # The Object type ZcashProofGenerationKey.

    def readTypeZcashProofGenerationKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashProofGenerationKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashProvingKey.

    def readTypeZcashProvingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashProvingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashRatio.

    def readTypeZcashRatio
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashRatio._uniffi_allocate(pointer)
    end

    # The Object type ZcashReceivedNoteId.

    def readTypeZcashReceivedNoteId
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashReceivedNoteId._uniffi_allocate(pointer)
    end

    # The Object type ZcashReceivedSaplingNote.

    def readTypeZcashReceivedSaplingNote
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashReceivedSaplingNote._uniffi_allocate(pointer)
    end

    # The Object type ZcashRecipientAddress.

    def readTypeZcashRecipientAddress
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashRecipientAddress._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingBundle.

    def readTypeZcashSaplingBundle
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingBundle._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingDiversifiedTransmissionKey.

    def readTypeZcashSaplingDiversifiedTransmissionKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingDiversifiedTransmissionKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingExtractedNoteCommitment.

    def readTypeZcashSaplingExtractedNoteCommitment
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingExtractedNoteCommitment._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingIvk.

    def readTypeZcashSaplingIvk
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingIvk._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingMerklePath.

    def readTypeZcashSaplingMerklePath
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingMerklePath._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingMetadata.

    def readTypeZcashSaplingMetadata
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingMetadata._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingNode.

    def readTypeZcashSaplingNode
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingNode._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingNote.

    def readTypeZcashSaplingNote
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingNote._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingNoteValue.

    def readTypeZcashSaplingNoteValue
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingNoteValue._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingNullifier.

    def readTypeZcashSaplingNullifier
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingNullifier._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingOutputDescription.

    def readTypeZcashSaplingOutputDescription
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingOutputDescription._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingPublicKey.

    def readTypeZcashSaplingPublicKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingPublicKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingSpendDescription.

    def readTypeZcashSaplingSpendDescription
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingSpendDescription._uniffi_allocate(pointer)
    end

    # The Object type ZcashSaplingValueCommitment.

    def readTypeZcashSaplingValueCommitment
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSaplingValueCommitment._uniffi_allocate(pointer)
    end

    # The Object type ZcashScanRange.

    def readTypeZcashScanRange
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashScanRange._uniffi_allocate(pointer)
    end

    # The Object type ZcashScannedBlock.

    def readTypeZcashScannedBlock
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashScannedBlock._uniffi_allocate(pointer)
    end

    # The Object type ZcashScript.

    def readTypeZcashScript
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashScript._uniffi_allocate(pointer)
    end

    # The Object type ZcashSentTransactionOutput.

    def readTypeZcashSentTransactionOutput
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashSentTransactionOutput._uniffi_allocate(pointer)
    end

    # The Object type ZcashTestFixedGreedyInputSelector.

    def readTypeZcashTestFixedGreedyInputSelector
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTestFixedGreedyInputSelector._uniffi_allocate(pointer)
    end

    # The Object type ZcashTestZip317GreedyInputSelector.

    def readTypeZcashTestZip317GreedyInputSelector
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTestZip317GreedyInputSelector._uniffi_allocate(pointer)
    end

    # The Object type ZcashTransaction.

    def readTypeZcashTransaction
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTransaction._uniffi_allocate(pointer)
    end

    # The Object type ZcashTransactionBuilder.

    def readTypeZcashTransactionBuilder
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTransactionBuilder._uniffi_allocate(pointer)
    end

    # The Object type ZcashTransactionRequest.

    def readTypeZcashTransactionRequest
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTransactionRequest._uniffi_allocate(pointer)
    end

    # The Object type ZcashTransparentAddress.

    def readTypeZcashTransparentAddress
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTransparentAddress._uniffi_allocate(pointer)
    end

    # The Object type ZcashTransparentBundle.

    def readTypeZcashTransparentBundle
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTransparentBundle._uniffi_allocate(pointer)
    end

    # The Object type ZcashTreeState.

    def readTypeZcashTreeState
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTreeState._uniffi_allocate(pointer)
    end

    # The Object type ZcashTxId.

    def readTypeZcashTxId
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTxId._uniffi_allocate(pointer)
    end

    # The Object type ZcashTxIn.

    def readTypeZcashTxIn
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTxIn._uniffi_allocate(pointer)
    end

    # The Object type ZcashTxOut.

    def readTypeZcashTxOut
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTxOut._uniffi_allocate(pointer)
    end

    # The Object type ZcashTxVersion.

    def readTypeZcashTxVersion
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashTxVersion._uniffi_allocate(pointer)
    end

    # The Object type ZcashUnifiedAddress.

    def readTypeZcashUnifiedAddress
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashUnifiedAddress._uniffi_allocate(pointer)
    end

    # The Object type ZcashUnifiedFullViewingKey.

    def readTypeZcashUnifiedFullViewingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashUnifiedFullViewingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashUnifiedSpendingKey.

    def readTypeZcashUnifiedSpendingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashUnifiedSpendingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashVerifyingKey.

    def readTypeZcashVerifyingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashVerifyingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashViewingKey.

    def readTypeZcashViewingKey
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashViewingKey._uniffi_allocate(pointer)
    end

    # The Object type ZcashWalletDb.

    def readTypeZcashWalletDb
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashWalletDb._uniffi_allocate(pointer)
    end

    # The Object type ZcashWalletSaplingOutput.

    def readTypeZcashWalletSaplingOutput
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashWalletSaplingOutput._uniffi_allocate(pointer)
    end

    # The Object type ZcashWalletSaplingSpend.

    def readTypeZcashWalletSaplingSpend
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashWalletSaplingSpend._uniffi_allocate(pointer)
    end

    # The Object type ZcashWalletSummary.

    def readTypeZcashWalletSummary
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashWalletSummary._uniffi_allocate(pointer)
    end

    # The Object type ZcashWalletTransparentOutput.

    def readTypeZcashWalletTransparentOutput
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashWalletTransparentOutput._uniffi_allocate(pointer)
    end

    # The Object type ZcashWalletTx.

    def readTypeZcashWalletTx
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashWalletTx._uniffi_allocate(pointer)
    end

    # The Object type ZcashZip317FeeRule.

    def readTypeZcashZip317FeeRule
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashZip317FeeRule._uniffi_allocate(pointer)
    end

    # The Object type ZcashZip317SingleOutputChangeStrategy.

    def readTypeZcashZip317SingleOutputChangeStrategy
      pointer = FFI::Pointer.new unpack_from 8, 'Q>'
      ZcashZip317SingleOutputChangeStrategy._uniffi_allocate(pointer)
    end

    # The Record type TripleSaplingNullifierMap.

    def readTypeTripleSaplingNullifierMap
      TripleSaplingNullifierMap.new(
        readTypeZcashTxId,
        readU16,
        readSequenceTypeZcashSaplingNullifier
      )
    end

    # The Record type TupleAccountIdAndSaplingNote.

    def readTypeTupleAccountIdAndSaplingNote
      TupleAccountIdAndSaplingNote.new(
        readTypeZcashAccountId,
        readTypeZcashSaplingNote
      )
    end

    # The Record type TupleAccountIdAndSaplingNullifier.

    def readTypeTupleAccountIdAndSaplingNullifier
      TupleAccountIdAndSaplingNullifier.new(
        readTypeZcashAccountId,
        readTypeZcashSaplingNullifier
      )
    end

    # The Record type TupleAccountIdAndUnifiedSpendingKey.

    def readTypeTupleAccountIdAndUnifiedSpendingKey
      TupleAccountIdAndUnifiedSpendingKey.new(
        readTypeZcashAccountId,
        readTypeZcashUnifiedSpendingKey
      )
    end

    # The Record type TupleBlockHeightAndHash.

    def readTypeTupleBlockHeightAndHash
      TupleBlockHeightAndHash.new(
        readTypeZcashBlockHeight,
        readTypeZcashBlockHash
      )
    end

    # The Record type TupleSaplingCommitments.

    def readTypeTupleSaplingCommitments
      TupleSaplingCommitments.new(
        readTypeZcashSaplingNode,
        readTypeMerkleTreeRetention
      )
    end

    # The Record type TupleTargetAndAnchorHeight.

    def readTypeTupleTargetAndAnchorHeight
      TupleTargetAndAnchorHeight.new(
        readTypeZcashBlockHeight,
        readTypeZcashBlockHeight
      )
    end

    # The Record type ZcashAccountId.

    def readTypeZcashAccountId
      ZcashAccountId.new(
        readU32
      )
    end

    # The Record type ZcashAuthPath.

    def readTypeZcashAuthPath
      ZcashAuthPath.new(
        readTypeZcashSaplingNode
      )
    end

    # The Record type ZcashDiversifierIndexAndPaymentAddress.

    def readTypeZcashDiversifierIndexAndPaymentAddress
      ZcashDiversifierIndexAndPaymentAddress.new(
        readTypeZcashDiversifierIndex,
        readTypeZcashPaymentAddress
      )
    end

    # The Record type ZcashDiversifierIndexAndScope.

    def readTypeZcashDiversifierIndexAndScope
      ZcashDiversifierIndexAndScope.new(
        readTypeZcashDiversifierIndex,
        readTypeZcashScope
      )
    end

    # The Record type ZcashInternalOvkExternalOvk.

    def readTypeZcashInternalOvkExternalOvk
      ZcashInternalOvkExternalOvk.new(
        readTypeZcashInternalOvk,
        readTypeZcashExternalOvk
      )
    end

    # The Record type ZcashOrchardDecryptOutput.

    def readTypeZcashOrchardDecryptOutput
      ZcashOrchardDecryptOutput.new(
        readTypeZcashOrchardNote,
        readTypeZcashOrchardAddress,
        readSequenceu8
      )
    end

    # The Record type ZcashOrchardDecryptOutputForIncomingKeys.

    def readTypeZcashOrchardDecryptOutputForIncomingKeys
      ZcashOrchardDecryptOutputForIncomingKeys.new(
        readU64,
        readTypeZcashOrchardIncomingViewingKey,
        readTypeZcashOrchardNote,
        readTypeZcashOrchardAddress,
        readSequenceu8
      )
    end

    # The Record type ZcashOrchardDecryptOutputForOutgoingKeys.

    def readTypeZcashOrchardDecryptOutputForOutgoingKeys
      ZcashOrchardDecryptOutputForOutgoingKeys.new(
        readU64,
        readTypeZcashOrchardOutgoingViewingKey,
        readTypeZcashOrchardNote,
        readTypeZcashOrchardAddress,
        readSequenceu8
      )
    end

    # The Record type ZcashOrchardTransmittedNoteCiphertext.

    def readTypeZcashOrchardTransmittedNoteCiphertext
      ZcashOrchardTransmittedNoteCiphertext.new(
        readSequenceu8,
        readSequenceu8,
        readSequenceu8
      )
    end

    # The Record type ZcashPayment.

    def readTypeZcashPayment
      ZcashPayment.new(
        readTypeZcashRecipientAddress,
        readTypeZcashAmount,
        readOptionalTypeZcashMemoBytes,
        readOptionalstring,
        readOptionalstring,
        readSequenceTypeZcashPaymentParam
      )
    end

    # The Record type ZcashPaymentParam.

    def readTypeZcashPaymentParam
      ZcashPaymentParam.new(
        readString,
        readString
      )
    end

    # The Record type ZcashSentTransaction.

    def readTypeZcashSentTransaction
      ZcashSentTransaction.new(
        readTypeZcashTransaction,
        readTypeTimeOffsetDateTime,
        readTypeZcashAccountId,
        readSequenceTypeZcashSentTransactionOutput,
        readTypeZcashAmount,
        readSequenceTypeZcashOutPoint
      )
    end

    # The Record type ZcashTransactionAndSaplingMetadata.

    def readTypeZcashTransactionAndSaplingMetadata
      ZcashTransactionAndSaplingMetadata.new(
        readTypeZcashTransaction,
        readTypeZcashSaplingMetadata
      )
    end

    # The Record type ZcashTransparentAddressAndIndex.

    def readTypeZcashTransparentAddressAndIndex
      ZcashTransparentAddressAndIndex.new(
        readTypeZcashTransparentAddress,
        readU32
      )
    end

    # The Record type ZcashUnifiedAddressAndDiversifierIndex.

    def readTypeZcashUnifiedAddressAndDiversifierIndex
      ZcashUnifiedAddressAndDiversifierIndex.new(
        readTypeZcashUnifiedAddress,
        readTypeZcashDiversifierIndex
      )
    end

    # The Enum type ZcashBranchId.

    def readTypeZcashBranchId
      variant = unpack_from 4, 'l>'

      return ZcashBranchId::SPROUT if variant == 1
      return ZcashBranchId::OVERWINTER if variant == 2
      return ZcashBranchId::SAPLING if variant == 3
      return ZcashBranchId::BLOSSOM if variant == 4
      return ZcashBranchId::HEARTWOOD if variant == 5
      return ZcashBranchId::CANOPY if variant == 6
      return ZcashBranchId::NU5 if variant == 7

      raise InternalError, 'Unexpected variant tag for TypeZcashBranchId'
    end

    # The Enum type ZcashChildIndex.

    def readTypeZcashChildIndex
      variant = unpack_from 4, 'l>'

      if variant == 1
        return ZcashChildIndex::NON_HARDENED.new(
          readU32
        )
      end
      if variant == 2
        return ZcashChildIndex::HARDENED.new(
          readU32
        )
      end
      raise InternalError, 'Unexpected variant tag for TypeZcashChildIndex'
    end

    # The Enum type ZcashConsensusParameters.

    def readTypeZcashConsensusParameters
      variant = unpack_from 4, 'l>'

      return ZcashConsensusParameters::MAIN_NETWORK if variant == 1
      return ZcashConsensusParameters::TEST_NETWORK if variant == 2

      raise InternalError, 'Unexpected variant tag for TypeZcashConsensusParameters'
    end

    # The Enum type ZcashDustAction.

    def readTypeZcashDustAction
      variant = unpack_from 4, 'l>'

      return ZcashDustAction::REJECT if variant == 1
      return ZcashDustAction::ALLOW_DUST_CHANGE if variant == 2
      return ZcashDustAction::ADD_DUST_TO_FEE if variant == 3

      raise InternalError, 'Unexpected variant tag for TypeZcashDustAction'
    end

    # The Error type ZcashError

    def readTypeZcashError
      variant = unpack_from 4, 'l>'

      if variant == 1
        return ZcashError::HdWalletError.new(
          readString
        )
      end
      if variant == 2
        return ZcashError::DecodingError.new(
          readString
        )
      end
      if variant == 3
        return ZcashError::DerivationError.new(
          readString
        )
      end
      if variant == 4
        return ZcashError::InvalidAsk.new(
          readString
        )
      end
      if variant == 5
        return ZcashError::InvalidNsk.new(
          readString
        )
      end
      if variant == 6
        return ZcashError::Message.new(
          readString
        )
      end
      if variant == 7
        return ZcashError::ArrayLengthMismatch.new(
          readString
        )
      end
      if variant == 8
        return ZcashError::ValueOutOfRange.new(
          readString
        )
      end
      if variant == 9
        return ZcashError::Secp256k1Error.new(
          readString
        )
      end
      if variant == 10
        return ZcashError::Bech32DecodeError.new(
          readString
        )
      end
      if variant == 11
        return ZcashError::Bs58Error.new(
          readString
        )
      end
      if variant == 12
        return ZcashError::BuilderError.new(
          readString
        )
      end
      if variant == 13
        return ZcashError::TransparentBuilderError.new(
          readString
        )
      end
      if variant == 14
        return ZcashError::SaplingBuilderError.new(
          readString
        )
      end
      if variant == 15
        return ZcashError::OrchardBuilderError.new(
          readString
        )
      end
      if variant == 16
        return ZcashError::OrchardBuilderSpendError.new(
          readString
        )
      end
      if variant == 17
        return ZcashError::OrchardBuilderOutputError.new(
          readString
        )
      end
      if variant == 18
        return ZcashError::InsufficientFundsError.new(
          readString
        )
      end
      if variant == 19
        return ZcashError::ChangeRequiredError.new(
          readString
        )
      end
      if variant == 20
        return ZcashError::BalanceError.new(
          readString
        )
      end
      if variant == 21
        return ZcashError::IoError.new(
          readString
        )
      end
      if variant == 22
        return ZcashError::Unknown.new(
          readString
        )
      end

      raise InternalError, 'Unexpected variant tag for TypeZcashError'
    end

    # The Enum type ZcashFeeRules.

    def readTypeZcashFeeRules
      variant = unpack_from 4, 'l>'

      return ZcashFeeRules::FIXED_STANDARD.new if variant == 1

      if variant == 2
        return ZcashFeeRules::FIXED_NON_STANDARD.new(
          readU64
        )
      end
      return ZcashFeeRules::ZIP317_STANDARD.new if variant == 3

      if variant == 4
        return ZcashFeeRules::ZIP317_NON_STANDARD.new(
          readU64,
          readU64,
          readU64,
          readU64
        )
      end
      raise InternalError, 'Unexpected variant tag for TypeZcashFeeRules'
    end

    # The Enum type ZcashKeySeed.

    def readTypeZcashKeySeed
      variant = unpack_from 4, 'l>'

      return ZcashKeySeed::S128 if variant == 1
      return ZcashKeySeed::S256 if variant == 2
      return ZcashKeySeed::S512 if variant == 3

      raise InternalError, 'Unexpected variant tag for TypeZcashKeySeed'
    end

    # The Enum type ZcashKeysEra.

    def readTypeZcashKeysEra
      variant = unpack_from 4, 'l>'

      return ZcashKeysEra::ORCHARD if variant == 1

      raise InternalError, 'Unexpected variant tag for TypeZcashKeysEra'
    end

    # The Enum type ZcashMemo.

    def readTypeZcashMemo
      variant = unpack_from 4, 'l>'

      return ZcashMemo::EMPTY.new if variant == 1

      if variant == 2
        return ZcashMemo::TEXT.new(
          readString
        )
      end
      if variant == 3
        return ZcashMemo::FUTURE.new(
          readSequenceu8
        )
      end
      if variant == 4
        return ZcashMemo::ARBITRARY.new(
          readSequenceu8
        )
      end
      raise InternalError, 'Unexpected variant tag for TypeZcashMemo'
    end

    # The Enum type ZcashNullifierQuery.

    def readTypeZcashNullifierQuery
      variant = unpack_from 4, 'l>'

      return ZcashNullifierQuery::UNSPENT if variant == 1
      return ZcashNullifierQuery::ALL if variant == 2

      raise InternalError, 'Unexpected variant tag for TypeZcashNullifierQuery'
    end

    # The Enum type ZcashOrchardScope.

    def readTypeZcashOrchardScope
      variant = unpack_from 4, 'l>'

      return ZcashOrchardScope::EXTERNAL if variant == 1
      return ZcashOrchardScope::INTERNAL if variant == 2

      raise InternalError, 'Unexpected variant tag for TypeZcashOrchardScope'
    end

    # The Enum type ZcashOvkPolicy.

    def readTypeZcashOvkPolicy
      variant = unpack_from 4, 'l>'

      return ZcashOvkPolicy::SENDER.new if variant == 1

      if variant == 2
        return ZcashOvkPolicy::CUSTOM.new(
          readSequenceu8
        )
      end
      return ZcashOvkPolicy::DISCARD.new if variant == 3

      raise InternalError, 'Unexpected variant tag for TypeZcashOvkPolicy'
    end

    # The Enum type ZcashPoolType.

    def readTypeZcashPoolType
      variant = unpack_from 4, 'l>'

      return ZcashPoolType::TRANSPARENT.new if variant == 1

      if variant == 2
        return ZcashPoolType::SHIELDED.new(
          readTypeZcashShieldedProtocol
        )
      end
      raise InternalError, 'Unexpected variant tag for TypeZcashPoolType'
    end

    # The Enum type ZcashRecipient.

    def readTypeZcashRecipient
      variant = unpack_from 4, 'l>'

      if variant == 1
        return ZcashRecipient::TRANSPARENT.new(
          readSequenceu8
        )
      end
      if variant == 2
        return ZcashRecipient::SAPLING.new(
          readSequenceu8
        )
      end
      if variant == 3
        return ZcashRecipient::UNIFIED.new(
          readString,
          readTypeZcashConsensusParameters,
          readTypeZcashPoolType
        )
      end
      if variant == 4
        return ZcashRecipient::INTERNAL_ACCOUNT.new(
          readTypeZcashAccountId,
          readTypeZcashPoolType
        )
      end
      raise InternalError, 'Unexpected variant tag for TypeZcashRecipient'
    end

    # The Enum type ZcashRseed.

    def readTypeZcashRseed
      variant = unpack_from 4, 'l>'

      if variant == 1
        return ZcashRseed::BEFORE_ZIP212.new(
          readSequenceu8
        )
      end
      if variant == 2
        return ZcashRseed::AFTER_ZIP212.new(
          readSequenceu8
        )
      end
      raise InternalError, 'Unexpected variant tag for TypeZcashRseed'
    end

    # The Enum type ZcashScanPriority.

    def readTypeZcashScanPriority
      variant = unpack_from 4, 'l>'

      return ZcashScanPriority::IGNORED if variant == 1
      return ZcashScanPriority::SCANNED if variant == 2
      return ZcashScanPriority::HISTORIC if variant == 3
      return ZcashScanPriority::OPEN_ADJACENT if variant == 4
      return ZcashScanPriority::FOUND_NOTE if variant == 5
      return ZcashScanPriority::CHAIN_TIP if variant == 6
      return ZcashScanPriority::VERIFY if variant == 7

      raise InternalError, 'Unexpected variant tag for TypeZcashScanPriority'
    end

    # The Enum type ZcashScope.

    def readTypeZcashScope
      variant = unpack_from 4, 'l>'

      return ZcashScope::EXTERNAL if variant == 1
      return ZcashScope::INTERNAL if variant == 2

      raise InternalError, 'Unexpected variant tag for TypeZcashScope'
    end

    # The Enum type ZcashShieldedProtocol.

    def readTypeZcashShieldedProtocol
      variant = unpack_from 4, 'l>'

      return ZcashShieldedProtocol::SAPLING if variant == 1

      raise InternalError, 'Unexpected variant tag for TypeZcashShieldedProtocol'
    end

    # The Enum type ZcashTransferType.

    def readTypeZcashTransferType
      variant = unpack_from 4, 'l>'

      return ZcashTransferType::INCOMING if variant == 1
      return ZcashTransferType::WALLET_INTERNAL if variant == 2
      return ZcashTransferType::OUTGOING if variant == 3

      raise InternalError, 'Unexpected variant tag for TypeZcashTransferType'
    end

    # The Enum type ZcashTxVersionSelection.

    def readTypeZcashTxVersionSelection
      variant = unpack_from 4, 'l>'

      if variant == 1
        return ZcashTxVersionSelection::SPROUT.new(
          readU32
        )
      end
      return ZcashTxVersionSelection::OVERWINTER.new if variant == 2
      return ZcashTxVersionSelection::SAPLING.new if variant == 3
      return ZcashTxVersionSelection::ZIP225.new if variant == 4

      raise InternalError, 'Unexpected variant tag for TypeZcashTxVersionSelection'
    end

    # The Error type ZcashWalletMigrationError

    def readTypeZcashWalletMigrationError
      variant = unpack_from 4, 'l>'

      if variant == 1
        return ZcashWalletMigrationError::SeedRequired.new(
          readString
        )
      end
      if variant == 2
        return ZcashWalletMigrationError::CorruptedData.new(
          readString
        )
      end
      if variant == 3
        return ZcashWalletMigrationError::DbError.new(
          readString
        )
      end
      if variant == 4
        return ZcashWalletMigrationError::BalanceError.new(
          readString
        )
      end
      if variant == 5
        return ZcashWalletMigrationError::CommitmentTreeError.new(
          readString
        )
      end

      raise InternalError, 'Unexpected variant tag for TypeZcashWalletMigrationError'
    end

    # The Error type ZcashZip321Error

    def readTypeZcashZip321Error
      variant = unpack_from 4, 'l>'

      if variant == 1
        return ZcashZip321Error::TooManyPayments.new(
          readU32
        )
      end
      if variant == 2
        return ZcashZip321Error::TransparentMemo.new(
          readU32
        )
      end
      if variant == 3
        return ZcashZip321Error::RecipientMissing.new(
          readU32
        )
      end
      if variant == 4
        return ZcashZip321Error::ParseError.new(
          readString
        )
      end

      raise InternalError, 'Unexpected variant tag for TypeZcashZip321Error'
    end

    # The Optional<T> type for u64.

    def readOptionalu64
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readU64
      else
        raise InternalError, 'Unexpected flag byte for Optionalu64'
      end
    end

    # The Optional<T> type for string.

    def readOptionalstring
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readString
      else
        raise InternalError, 'Unexpected flag byte for Optionalstring'
      end
    end

    # The Optional<T> type for TypeZcashAccountPubKey.

    def readOptionalTypeZcashAccountPubKey
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashAccountPubKey
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashAccountPubKey'
      end
    end

    # The Optional<T> type for TypeZcashAmount.

    def readOptionalTypeZcashAmount
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashAmount
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashAmount'
      end
    end

    # The Optional<T> type for TypeZcashBlockHash.

    def readOptionalTypeZcashBlockHash
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashBlockHash
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashBlockHash'
      end
    end

    # The Optional<T> type for TypeZcashBlockHeight.

    def readOptionalTypeZcashBlockHeight
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashBlockHeight
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashBlockHeight'
      end
    end

    # The Optional<T> type for TypeZcashBlockMeta.

    def readOptionalTypeZcashBlockMeta
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashBlockMeta
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashBlockMeta'
      end
    end

    # The Optional<T> type for TypeZcashBlockMetadata.

    def readOptionalTypeZcashBlockMetadata
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashBlockMetadata
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashBlockMetadata'
      end
    end

    # The Optional<T> type for TypeZcashDiversifiableFullViewingKey.

    def readOptionalTypeZcashDiversifiableFullViewingKey
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashDiversifiableFullViewingKey
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashDiversifiableFullViewingKey'
      end
    end

    # The Optional<T> type for TypeZcashMemoBytes.

    def readOptionalTypeZcashMemoBytes
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashMemoBytes
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashMemoBytes'
      end
    end

    # The Optional<T> type for TypeZcashOrchardAddress.

    def readOptionalTypeZcashOrchardAddress
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashOrchardAddress
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardAddress'
      end
    end

    # The Optional<T> type for TypeZcashOrchardBundle.

    def readOptionalTypeZcashOrchardBundle
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashOrchardBundle
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardBundle'
      end
    end

    # The Optional<T> type for TypeZcashOrchardDiversifierIndex.

    def readOptionalTypeZcashOrchardDiversifierIndex
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashOrchardDiversifierIndex
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardDiversifierIndex'
      end
    end

    # The Optional<T> type for TypeZcashOrchardFullViewingKey.

    def readOptionalTypeZcashOrchardFullViewingKey
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashOrchardFullViewingKey
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardFullViewingKey'
      end
    end

    # The Optional<T> type for TypeZcashOrchardOutgoingViewingKey.

    def readOptionalTypeZcashOrchardOutgoingViewingKey
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashOrchardOutgoingViewingKey
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardOutgoingViewingKey'
      end
    end

    # The Optional<T> type for TypeZcashOutgoingViewingKey.

    def readOptionalTypeZcashOutgoingViewingKey
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashOutgoingViewingKey
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOutgoingViewingKey'
      end
    end

    # The Optional<T> type for TypeZcashPaymentAddress.

    def readOptionalTypeZcashPaymentAddress
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashPaymentAddress
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashPaymentAddress'
      end
    end

    # The Optional<T> type for TypeZcashRatio.

    def readOptionalTypeZcashRatio
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashRatio
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashRatio'
      end
    end

    # The Optional<T> type for TypeZcashSaplingBundle.

    def readOptionalTypeZcashSaplingBundle
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashSaplingBundle
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashSaplingBundle'
      end
    end

    # The Optional<T> type for TypeZcashSaplingMerklePath.

    def readOptionalTypeZcashSaplingMerklePath
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashSaplingMerklePath
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashSaplingMerklePath'
      end
    end

    # The Optional<T> type for TypeZcashTransparentAddress.

    def readOptionalTypeZcashTransparentAddress
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashTransparentAddress
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashTransparentAddress'
      end
    end

    # The Optional<T> type for TypeZcashTransparentBundle.

    def readOptionalTypeZcashTransparentBundle
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashTransparentBundle
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashTransparentBundle'
      end
    end

    # The Optional<T> type for TypeZcashUnifiedAddress.

    def readOptionalTypeZcashUnifiedAddress
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashUnifiedAddress
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashUnifiedAddress'
      end
    end

    # The Optional<T> type for TypeZcashWalletSummary.

    def readOptionalTypeZcashWalletSummary
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashWalletSummary
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashWalletSummary'
      end
    end

    # The Optional<T> type for TypeTupleAccountIdAndSaplingNote.

    def readOptionalTypeTupleAccountIdAndSaplingNote
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeTupleAccountIdAndSaplingNote
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeTupleAccountIdAndSaplingNote'
      end
    end

    # The Optional<T> type for TypeTupleBlockHeightAndHash.

    def readOptionalTypeTupleBlockHeightAndHash
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeTupleBlockHeightAndHash
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeTupleBlockHeightAndHash'
      end
    end

    # The Optional<T> type for TypeTupleTargetAndAnchorHeight.

    def readOptionalTypeTupleTargetAndAnchorHeight
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeTupleTargetAndAnchorHeight
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeTupleTargetAndAnchorHeight'
      end
    end

    # The Optional<T> type for TypeZcashAccountId.

    def readOptionalTypeZcashAccountId
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashAccountId
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashAccountId'
      end
    end

    # The Optional<T> type for TypeZcashDiversifierIndexAndPaymentAddress.

    def readOptionalTypeZcashDiversifierIndexAndPaymentAddress
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashDiversifierIndexAndPaymentAddress
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashDiversifierIndexAndPaymentAddress'
      end
    end

    # The Optional<T> type for TypeZcashDiversifierIndexAndScope.

    def readOptionalTypeZcashDiversifierIndexAndScope
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashDiversifierIndexAndScope
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashDiversifierIndexAndScope'
      end
    end

    # The Optional<T> type for TypeZcashUnifiedAddressAndDiversifierIndex.

    def readOptionalTypeZcashUnifiedAddressAndDiversifierIndex
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashUnifiedAddressAndDiversifierIndex
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashUnifiedAddressAndDiversifierIndex'
      end
    end

    # The Optional<T> type for TypeZcashOrchardScope.

    def readOptionalTypeZcashOrchardScope
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readTypeZcashOrchardScope
      else
        raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardScope'
      end
    end

    # The Optional<T> type for Sequenceu8.

    def readOptionalSequenceu8
      flag = unpack_from 1, 'c'

      if flag.zero?
        nil
      elsif flag == 1
        readSequenceu8
      else
        raise InternalError, 'Unexpected flag byte for OptionalSequenceu8'
      end
    end

    # The Sequence<T> type for u8.

    def readSequenceu8
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readU8
      end

      items
    end

    # The Sequence<T> type for u32.

    def readSequenceu32
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readU32
      end

      items
    end

    # The Sequence<T> type for u64.

    def readSequenceu64
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readU64
      end

      items
    end

    # The Sequence<T> type for TypeZcashBlockHeight.

    def readSequenceTypeZcashBlockHeight
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashBlockHeight
      end

      items
    end

    # The Sequence<T> type for TypeZcashBlockMeta.

    def readSequenceTypeZcashBlockMeta
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashBlockMeta
      end

      items
    end

    # The Sequence<T> type for TypeZcashCommitmentTreeRoot.

    def readSequenceTypeZcashCommitmentTreeRoot
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashCommitmentTreeRoot
      end

      items
    end

    # The Sequence<T> type for TypeZcashDecryptedOutput.

    def readSequenceTypeZcashDecryptedOutput
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashDecryptedOutput
      end

      items
    end

    # The Sequence<T> type for TypeZcashOrchardAction.

    def readSequenceTypeZcashOrchardAction
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashOrchardAction
      end

      items
    end

    # The Sequence<T> type for TypeZcashOrchardIncomingViewingKey.

    def readSequenceTypeZcashOrchardIncomingViewingKey
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashOrchardIncomingViewingKey
      end

      items
    end

    # The Sequence<T> type for TypeZcashOrchardMerkleHash.

    def readSequenceTypeZcashOrchardMerkleHash
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashOrchardMerkleHash
      end

      items
    end

    # The Sequence<T> type for TypeZcashOrchardOutgoingViewingKey.

    def readSequenceTypeZcashOrchardOutgoingViewingKey
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashOrchardOutgoingViewingKey
      end

      items
    end

    # The Sequence<T> type for TypeZcashOrchardSpendingKey.

    def readSequenceTypeZcashOrchardSpendingKey
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashOrchardSpendingKey
      end

      items
    end

    # The Sequence<T> type for TypeZcashOutPoint.

    def readSequenceTypeZcashOutPoint
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashOutPoint
      end

      items
    end

    # The Sequence<T> type for TypeZcashReceivedNoteId.

    def readSequenceTypeZcashReceivedNoteId
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashReceivedNoteId
      end

      items
    end

    # The Sequence<T> type for TypeZcashReceivedSaplingNote.

    def readSequenceTypeZcashReceivedSaplingNote
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashReceivedSaplingNote
      end

      items
    end

    # The Sequence<T> type for TypeZcashSaplingNullifier.

    def readSequenceTypeZcashSaplingNullifier
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashSaplingNullifier
      end

      items
    end

    # The Sequence<T> type for TypeZcashSaplingOutputDescription.

    def readSequenceTypeZcashSaplingOutputDescription
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashSaplingOutputDescription
      end

      items
    end

    # The Sequence<T> type for TypeZcashSaplingSpendDescription.

    def readSequenceTypeZcashSaplingSpendDescription
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashSaplingSpendDescription
      end

      items
    end

    # The Sequence<T> type for TypeZcashScanRange.

    def readSequenceTypeZcashScanRange
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashScanRange
      end

      items
    end

    # The Sequence<T> type for TypeZcashScannedBlock.

    def readSequenceTypeZcashScannedBlock
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashScannedBlock
      end

      items
    end

    # The Sequence<T> type for TypeZcashSentTransactionOutput.

    def readSequenceTypeZcashSentTransactionOutput
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashSentTransactionOutput
      end

      items
    end

    # The Sequence<T> type for TypeZcashTransparentAddress.

    def readSequenceTypeZcashTransparentAddress
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashTransparentAddress
      end

      items
    end

    # The Sequence<T> type for TypeZcashTxIn.

    def readSequenceTypeZcashTxIn
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashTxIn
      end

      items
    end

    # The Sequence<T> type for TypeZcashTxOut.

    def readSequenceTypeZcashTxOut
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashTxOut
      end

      items
    end

    # The Sequence<T> type for TypeZcashWalletSaplingOutput.

    def readSequenceTypeZcashWalletSaplingOutput
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashWalletSaplingOutput
      end

      items
    end

    # The Sequence<T> type for TypeZcashWalletSaplingSpend.

    def readSequenceTypeZcashWalletSaplingSpend
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashWalletSaplingSpend
      end

      items
    end

    # The Sequence<T> type for TypeZcashWalletTransparentOutput.

    def readSequenceTypeZcashWalletTransparentOutput
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashWalletTransparentOutput
      end

      items
    end

    # The Sequence<T> type for TypeZcashWalletTx.

    def readSequenceTypeZcashWalletTx
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashWalletTx
      end

      items
    end

    # The Sequence<T> type for TypeTripleSaplingNullifierMap.

    def readSequenceTypeTripleSaplingNullifierMap
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeTripleSaplingNullifierMap
      end

      items
    end

    # The Sequence<T> type for TypeTupleAccountIdAndSaplingNullifier.

    def readSequenceTypeTupleAccountIdAndSaplingNullifier
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeTupleAccountIdAndSaplingNullifier
      end

      items
    end

    # The Sequence<T> type for TypeTupleSaplingCommitments.

    def readSequenceTypeTupleSaplingCommitments
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeTupleSaplingCommitments
      end

      items
    end

    # The Sequence<T> type for TypeZcashAuthPath.

    def readSequenceTypeZcashAuthPath
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashAuthPath
      end

      items
    end

    # The Sequence<T> type for TypeZcashOrchardDecryptOutputForIncomingKeys.

    def readSequenceTypeZcashOrchardDecryptOutputForIncomingKeys
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashOrchardDecryptOutputForIncomingKeys
      end

      items
    end

    # The Sequence<T> type for TypeZcashOrchardDecryptOutputForOutgoingKeys.

    def readSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashOrchardDecryptOutputForOutgoingKeys
      end

      items
    end

    # The Sequence<T> type for TypeZcashPayment.

    def readSequenceTypeZcashPayment
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashPayment
      end

      items
    end

    # The Sequence<T> type for TypeZcashPaymentParam.

    def readSequenceTypeZcashPaymentParam
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashPaymentParam
      end

      items
    end

    # The Sequence<T> type for TypeZcashChildIndex.

    def readSequenceTypeZcashChildIndex
      count = unpack_from 4, 'l>'

      raise InternalError, 'Unexpected negative sequence length' if count.negative?

      items = []

      count.times do
        items.append readTypeZcashChildIndex
      end

      items
    end

    # The Map<T> type for TypeZcashAccountBalance.

    def readMapStringTypeZcashAccountBalance
      count = unpack_from 4, 'l>'
      raise InternalError, 'Unexpected negative map size' if count.negative?

      items = {}
      count.times do
        key = readString
        items[key] = readTypeZcashAccountBalance
      end

      items
    end

    def readMapStringTypeZcashAddressMetadata
      count = unpack_from 4, 'l>'
      raise InternalError, 'Unexpected negative map size' if count.negative?

      items = {}
      count.times do
        key = readString
        items[key] = readTypeZcashAddressMetadata
      end

      items
    end

    def readMapStringTypeZcashAmount
      count = unpack_from 4, 'l>'
      raise InternalError, 'Unexpected negative map size' if count.negative?

      items = {}
      count.times do
        key = readString
        items[key] = readTypeZcashAmount
      end

      items
    end

    def readMapTypeZcashAccountIdTypeZcashUnifiedFullViewingKey
      count = unpack_from 4, 'l>'
      raise InternalError, 'Unexpected negative map size' if count.negative?

      items = {}
      count.times do
        key = readString
        items[key] = readTypeZcashUnifiedFullViewingKey
      end

      items
    end

    def unpack_from(size, format)
      raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

      value = @rbuf.data.get_bytes(@offset, size).unpack format

      @offset += size

      # TODO: verify this
      raise 'more than one element!!!' if value.size > 1

      value[0]
    end
  end

  private_constant :RustBufferStream

  # Helper for structured writing of values into a RustBuffer.
  class RustBufferBuilder
    def initialize
      @rust_buf = RustBuffer.alloc 16
      @rust_buf.len = 0
    end

    def finalize
      rbuf = @rust_buf

      @rust_buf = nil

      rbuf
    end

    def discard
      return if @rust_buf.nil?

      rbuf = finalize
      rbuf.free
    end

    def write(value)
      reserve(value.bytes.size) do
        @rust_buf.data.put_array_of_char @rust_buf.len, value.bytes
      end
    end

    def write_U8(v)
      v = Zcash.uniffi_in_range(v, 'u8', 0, 2**8)
      pack_into(1, 'c', v)
    end

    def write_U16(v)
      v = Zcash.uniffi_in_range(v, 'u16', 0, 2**16)
      pack_into(2, 'S>', v)
    end

    def write_U32(v)
      v = Zcash.uniffi_in_range(v, 'u32', 0, 2**32)
      pack_into(4, 'L>', v)
    end

    def write_U64(v)
      v = Zcash.uniffi_in_range(v, 'u64', 0, 2**64)
      pack_into(8, 'Q>', v)
    end

    def write_I64(v)
      v = Zcash.uniffi_in_range(v, 'i64', -2**63, 2**63)
      pack_into(8, 'q>', v)
    end

    def write_Bool(v)
      pack_into(1, 'c', v ? 1 : 0)
    end

    def write_String(v)
      v = Zcash.uniffi_utf8(v)
      pack_into 4, 'l>', v.bytes.size
      write v
    end

    # The Object type MerkleTreeFrontier.

    def write_TypeMerkleTreeFrontier(obj)
      pointer = MerkleTreeFrontier._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type MerkleTreePosition.

    def write_TypeMerkleTreePosition(obj)
      pointer = MerkleTreePosition._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type MerkleTreeRetention.

    def write_TypeMerkleTreeRetention(obj)
      pointer = MerkleTreeRetention._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type SecpSecretKey.

    def write_TypeSecpSecretKey(obj)
      pointer = SecpSecretKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type TestSupport.

    def write_TypeTestSupport(obj)
      pointer = TestSupport._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type TimeOffsetDateTime.

    def write_TypeTimeOffsetDateTime(obj)
      pointer = TimeOffsetDateTime._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashAccountBalance.

    def write_TypeZcashAccountBalance(obj)
      pointer = ZcashAccountBalance._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashAccountBirthday.

    def write_TypeZcashAccountBirthday(obj)
      pointer = ZcashAccountBirthday._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashAccountPrivKey.

    def write_TypeZcashAccountPrivKey(obj)
      pointer = ZcashAccountPrivKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashAccountPubKey.

    def write_TypeZcashAccountPubKey(obj)
      pointer = ZcashAccountPubKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashAddressMetadata.

    def write_TypeZcashAddressMetadata(obj)
      pointer = ZcashAddressMetadata._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashAmount.

    def write_TypeZcashAmount(obj)
      pointer = ZcashAmount._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashAnchor.

    def write_TypeZcashAnchor(obj)
      pointer = ZcashAnchor._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashBalance.

    def write_TypeZcashBalance(obj)
      pointer = ZcashBalance._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashBlockHash.

    def write_TypeZcashBlockHash(obj)
      pointer = ZcashBlockHash._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashBlockHeight.

    def write_TypeZcashBlockHeight(obj)
      pointer = ZcashBlockHeight._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashBlockMeta.

    def write_TypeZcashBlockMeta(obj)
      pointer = ZcashBlockMeta._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashBlockMetadata.

    def write_TypeZcashBlockMetadata(obj)
      pointer = ZcashBlockMetadata._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashCommitmentTree.

    def write_TypeZcashCommitmentTree(obj)
      pointer = ZcashCommitmentTree._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashCommitmentTreeRoot.

    def write_TypeZcashCommitmentTreeRoot(obj)
      pointer = ZcashCommitmentTreeRoot._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashDecryptedOutput.

    def write_TypeZcashDecryptedOutput(obj)
      pointer = ZcashDecryptedOutput._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashDecryptedTransaction.

    def write_TypeZcashDecryptedTransaction(obj)
      pointer = ZcashDecryptedTransaction._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashDiversifiableFullViewingKey.

    def write_TypeZcashDiversifiableFullViewingKey(obj)
      pointer = ZcashDiversifiableFullViewingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashDiversifier.

    def write_TypeZcashDiversifier(obj)
      pointer = ZcashDiversifier._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashDiversifierIndex.

    def write_TypeZcashDiversifierIndex(obj)
      pointer = ZcashDiversifierIndex._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashDustOutputPolicy.

    def write_TypeZcashDustOutputPolicy(obj)
      pointer = ZcashDustOutputPolicy._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashExpandedSpendingKey.

    def write_TypeZcashExpandedSpendingKey(obj)
      pointer = ZcashExpandedSpendingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashExtendedFullViewingKey.

    def write_TypeZcashExtendedFullViewingKey(obj)
      pointer = ZcashExtendedFullViewingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashExtendedPrivKey.

    def write_TypeZcashExtendedPrivKey(obj)
      pointer = ZcashExtendedPrivKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashExtendedSpendingKey.

    def write_TypeZcashExtendedSpendingKey(obj)
      pointer = ZcashExtendedSpendingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashExternalIvk.

    def write_TypeZcashExternalIvk(obj)
      pointer = ZcashExternalIvk._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashExternalOvk.

    def write_TypeZcashExternalOvk(obj)
      pointer = ZcashExternalOvk._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashExtractedNoteCommitment.

    def write_TypeZcashExtractedNoteCommitment(obj)
      pointer = ZcashExtractedNoteCommitment._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashFixedFeeRule.

    def write_TypeZcashFixedFeeRule(obj)
      pointer = ZcashFixedFeeRule._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashFixedSingleOutputChangeStrategy.

    def write_TypeZcashFixedSingleOutputChangeStrategy(obj)
      pointer = ZcashFixedSingleOutputChangeStrategy._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashFsBlockDb.

    def write_TypeZcashFsBlockDb(obj)
      pointer = ZcashFsBlockDb._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashFullViewingKey.

    def write_TypeZcashFullViewingKey(obj)
      pointer = ZcashFullViewingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashIncrementalWitness.

    def write_TypeZcashIncrementalWitness(obj)
      pointer = ZcashIncrementalWitness._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashInternalIvk.

    def write_TypeZcashInternalIvk(obj)
      pointer = ZcashInternalIvk._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashInternalOvk.

    def write_TypeZcashInternalOvk(obj)
      pointer = ZcashInternalOvk._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashJubjubFr.

    def write_TypeZcashJubjubFr(obj)
      pointer = ZcashJubjubFr._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashKeyIndex.

    def write_TypeZcashKeyIndex(obj)
      pointer = ZcashKeyIndex._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashLocalTxProver.

    def write_TypeZcashLocalTxProver(obj)
      pointer = ZcashLocalTxProver._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashMainFixedGreedyInputSelector.

    def write_TypeZcashMainFixedGreedyInputSelector(obj)
      pointer = ZcashMainFixedGreedyInputSelector._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashMainZip317GreedyInputSelector.

    def write_TypeZcashMainZip317GreedyInputSelector(obj)
      pointer = ZcashMainZip317GreedyInputSelector._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashMemoBytes.

    def write_TypeZcashMemoBytes(obj)
      pointer = ZcashMemoBytes._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashNonNegativeAmount.

    def write_TypeZcashNonNegativeAmount(obj)
      pointer = ZcashNonNegativeAmount._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashNoteId.

    def write_TypeZcashNoteId(obj)
      pointer = ZcashNoteId._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashNullifierDerivingKey.

    def write_TypeZcashNullifierDerivingKey(obj)
      pointer = ZcashNullifierDerivingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardAction.

    def write_TypeZcashOrchardAction(obj)
      pointer = ZcashOrchardAction._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardAddress.

    def write_TypeZcashOrchardAddress(obj)
      pointer = ZcashOrchardAddress._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardBundle.

    def write_TypeZcashOrchardBundle(obj)
      pointer = ZcashOrchardBundle._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardDiversifier.

    def write_TypeZcashOrchardDiversifier(obj)
      pointer = ZcashOrchardDiversifier._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardDiversifierIndex.

    def write_TypeZcashOrchardDiversifierIndex(obj)
      pointer = ZcashOrchardDiversifierIndex._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardFlags.

    def write_TypeZcashOrchardFlags(obj)
      pointer = ZcashOrchardFlags._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardFullViewingKey.

    def write_TypeZcashOrchardFullViewingKey(obj)
      pointer = ZcashOrchardFullViewingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardIncomingViewingKey.

    def write_TypeZcashOrchardIncomingViewingKey(obj)
      pointer = ZcashOrchardIncomingViewingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardMerkleHash.

    def write_TypeZcashOrchardMerkleHash(obj)
      pointer = ZcashOrchardMerkleHash._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardMerklePath.

    def write_TypeZcashOrchardMerklePath(obj)
      pointer = ZcashOrchardMerklePath._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardNote.

    def write_TypeZcashOrchardNote(obj)
      pointer = ZcashOrchardNote._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardNoteCommitment.

    def write_TypeZcashOrchardNoteCommitment(obj)
      pointer = ZcashOrchardNoteCommitment._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardNoteValue.

    def write_TypeZcashOrchardNoteValue(obj)
      pointer = ZcashOrchardNoteValue._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardNullifier.

    def write_TypeZcashOrchardNullifier(obj)
      pointer = ZcashOrchardNullifier._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardOutgoingViewingKey.

    def write_TypeZcashOrchardOutgoingViewingKey(obj)
      pointer = ZcashOrchardOutgoingViewingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardRandomSeed.

    def write_TypeZcashOrchardRandomSeed(obj)
      pointer = ZcashOrchardRandomSeed._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardSpendingKey.

    def write_TypeZcashOrchardSpendingKey(obj)
      pointer = ZcashOrchardSpendingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardTransactionBuilder.

    def write_TypeZcashOrchardTransactionBuilder(obj)
      pointer = ZcashOrchardTransactionBuilder._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOrchardValueCommitment.

    def write_TypeZcashOrchardValueCommitment(obj)
      pointer = ZcashOrchardValueCommitment._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOutPoint.

    def write_TypeZcashOutPoint(obj)
      pointer = ZcashOutPoint._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashOutgoingViewingKey.

    def write_TypeZcashOutgoingViewingKey(obj)
      pointer = ZcashOutgoingViewingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashPaymentAddress.

    def write_TypeZcashPaymentAddress(obj)
      pointer = ZcashPaymentAddress._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashProofGenerationKey.

    def write_TypeZcashProofGenerationKey(obj)
      pointer = ZcashProofGenerationKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashProvingKey.

    def write_TypeZcashProvingKey(obj)
      pointer = ZcashProvingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashRatio.

    def write_TypeZcashRatio(obj)
      pointer = ZcashRatio._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashReceivedNoteId.

    def write_TypeZcashReceivedNoteId(obj)
      pointer = ZcashReceivedNoteId._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashReceivedSaplingNote.

    def write_TypeZcashReceivedSaplingNote(obj)
      pointer = ZcashReceivedSaplingNote._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashRecipientAddress.

    def write_TypeZcashRecipientAddress(obj)
      pointer = ZcashRecipientAddress._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingBundle.

    def write_TypeZcashSaplingBundle(obj)
      pointer = ZcashSaplingBundle._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingDiversifiedTransmissionKey.

    def write_TypeZcashSaplingDiversifiedTransmissionKey(obj)
      pointer = ZcashSaplingDiversifiedTransmissionKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingExtractedNoteCommitment.

    def write_TypeZcashSaplingExtractedNoteCommitment(obj)
      pointer = ZcashSaplingExtractedNoteCommitment._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingIvk.

    def write_TypeZcashSaplingIvk(obj)
      pointer = ZcashSaplingIvk._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingMerklePath.

    def write_TypeZcashSaplingMerklePath(obj)
      pointer = ZcashSaplingMerklePath._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingMetadata.

    def write_TypeZcashSaplingMetadata(obj)
      pointer = ZcashSaplingMetadata._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingNode.

    def write_TypeZcashSaplingNode(obj)
      pointer = ZcashSaplingNode._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingNote.

    def write_TypeZcashSaplingNote(obj)
      pointer = ZcashSaplingNote._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingNoteValue.

    def write_TypeZcashSaplingNoteValue(obj)
      pointer = ZcashSaplingNoteValue._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingNullifier.

    def write_TypeZcashSaplingNullifier(obj)
      pointer = ZcashSaplingNullifier._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingOutputDescription.

    def write_TypeZcashSaplingOutputDescription(obj)
      pointer = ZcashSaplingOutputDescription._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingPublicKey.

    def write_TypeZcashSaplingPublicKey(obj)
      pointer = ZcashSaplingPublicKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingSpendDescription.

    def write_TypeZcashSaplingSpendDescription(obj)
      pointer = ZcashSaplingSpendDescription._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSaplingValueCommitment.

    def write_TypeZcashSaplingValueCommitment(obj)
      pointer = ZcashSaplingValueCommitment._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashScanRange.

    def write_TypeZcashScanRange(obj)
      pointer = ZcashScanRange._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashScannedBlock.

    def write_TypeZcashScannedBlock(obj)
      pointer = ZcashScannedBlock._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashScript.

    def write_TypeZcashScript(obj)
      pointer = ZcashScript._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashSentTransactionOutput.

    def write_TypeZcashSentTransactionOutput(obj)
      pointer = ZcashSentTransactionOutput._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTestFixedGreedyInputSelector.

    def write_TypeZcashTestFixedGreedyInputSelector(obj)
      pointer = ZcashTestFixedGreedyInputSelector._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTestZip317GreedyInputSelector.

    def write_TypeZcashTestZip317GreedyInputSelector(obj)
      pointer = ZcashTestZip317GreedyInputSelector._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTransaction.

    def write_TypeZcashTransaction(obj)
      pointer = ZcashTransaction._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTransactionBuilder.

    def write_TypeZcashTransactionBuilder(obj)
      pointer = ZcashTransactionBuilder._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTransactionRequest.

    def write_TypeZcashTransactionRequest(obj)
      pointer = ZcashTransactionRequest._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTransparentAddress.

    def write_TypeZcashTransparentAddress(obj)
      pointer = ZcashTransparentAddress._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTransparentBundle.

    def write_TypeZcashTransparentBundle(obj)
      pointer = ZcashTransparentBundle._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTreeState.

    def write_TypeZcashTreeState(obj)
      pointer = ZcashTreeState._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTxId.

    def write_TypeZcashTxId(obj)
      pointer = ZcashTxId._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTxIn.

    def write_TypeZcashTxIn(obj)
      pointer = ZcashTxIn._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTxOut.

    def write_TypeZcashTxOut(obj)
      pointer = ZcashTxOut._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashTxVersion.

    def write_TypeZcashTxVersion(obj)
      pointer = ZcashTxVersion._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashUnifiedAddress.

    def write_TypeZcashUnifiedAddress(obj)
      pointer = ZcashUnifiedAddress._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashUnifiedFullViewingKey.

    def write_TypeZcashUnifiedFullViewingKey(obj)
      pointer = ZcashUnifiedFullViewingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashUnifiedSpendingKey.

    def write_TypeZcashUnifiedSpendingKey(obj)
      pointer = ZcashUnifiedSpendingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashVerifyingKey.

    def write_TypeZcashVerifyingKey(obj)
      pointer = ZcashVerifyingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashViewingKey.

    def write_TypeZcashViewingKey(obj)
      pointer = ZcashViewingKey._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashWalletDb.

    def write_TypeZcashWalletDb(obj)
      pointer = ZcashWalletDb._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashWalletSaplingOutput.

    def write_TypeZcashWalletSaplingOutput(obj)
      pointer = ZcashWalletSaplingOutput._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashWalletSaplingSpend.

    def write_TypeZcashWalletSaplingSpend(obj)
      pointer = ZcashWalletSaplingSpend._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashWalletSummary.

    def write_TypeZcashWalletSummary(obj)
      pointer = ZcashWalletSummary._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashWalletTransparentOutput.

    def write_TypeZcashWalletTransparentOutput(obj)
      pointer = ZcashWalletTransparentOutput._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashWalletTx.

    def write_TypeZcashWalletTx(obj)
      pointer = ZcashWalletTx._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashZip317FeeRule.

    def write_TypeZcashZip317FeeRule(obj)
      pointer = ZcashZip317FeeRule._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Object type ZcashZip317SingleOutputChangeStrategy.

    def write_TypeZcashZip317SingleOutputChangeStrategy(obj)
      pointer = ZcashZip317SingleOutputChangeStrategy._uniffi_lower obj
      pack_into(8, 'Q>', pointer.address)
    end

    # The Record type TripleSaplingNullifierMap.

    def write_TypeTripleSaplingNullifierMap(v)
      write_TypeZcashTxId(v.txid)
      write_U16(v.tx_idx)
      write_SequenceTypeZcashSaplingNullifier(v.nullifiers)
    end

    # The Record type TupleAccountIdAndSaplingNote.

    def write_TypeTupleAccountIdAndSaplingNote(v)
      write_TypeZcashAccountId(v.account_id)
      write_TypeZcashSaplingNote(v.sapling_note)
    end

    # The Record type TupleAccountIdAndSaplingNullifier.

    def write_TypeTupleAccountIdAndSaplingNullifier(v)
      write_TypeZcashAccountId(v.account_id)
      write_TypeZcashSaplingNullifier(v.sapling_nullifier)
    end

    # The Record type TupleAccountIdAndUnifiedSpendingKey.

    def write_TypeTupleAccountIdAndUnifiedSpendingKey(v)
      write_TypeZcashAccountId(v.account_id)
      write_TypeZcashUnifiedSpendingKey(v.unified_spending_key)
    end

    # The Record type TupleBlockHeightAndHash.

    def write_TypeTupleBlockHeightAndHash(v)
      write_TypeZcashBlockHeight(v.block_height)
      write_TypeZcashBlockHash(v.block_hash)
    end

    # The Record type TupleSaplingCommitments.

    def write_TypeTupleSaplingCommitments(v)
      write_TypeZcashSaplingNode(v.node)
      write_TypeMerkleTreeRetention(v.retention)
    end

    # The Record type TupleTargetAndAnchorHeight.

    def write_TypeTupleTargetAndAnchorHeight(v)
      write_TypeZcashBlockHeight(v.target_height)
      write_TypeZcashBlockHeight(v.anchor_height)
    end

    # The Record type ZcashAccountId.

    def write_TypeZcashAccountId(v)
      write_U32(v.id)
    end

    # The Record type ZcashAuthPath.

    def write_TypeZcashAuthPath(v)
      write_TypeZcashSaplingNode(v.node)
    end

    # The Record type ZcashDiversifierIndexAndPaymentAddress.

    def write_TypeZcashDiversifierIndexAndPaymentAddress(v)
      write_TypeZcashDiversifierIndex(v.diversifier_index)
      write_TypeZcashPaymentAddress(v.address)
    end

    # The Record type ZcashDiversifierIndexAndScope.

    def write_TypeZcashDiversifierIndexAndScope(v)
      write_TypeZcashDiversifierIndex(v.diversifier_index)
      write_TypeZcashScope(v.scope)
    end

    # The Record type ZcashInternalOvkExternalOvk.

    def write_TypeZcashInternalOvkExternalOvk(v)
      write_TypeZcashInternalOvk(v.internal_ovk)
      write_TypeZcashExternalOvk(v.external_ovk)
    end

    # The Record type ZcashOrchardDecryptOutput.

    def write_TypeZcashOrchardDecryptOutput(v)
      write_TypeZcashOrchardNote(v.note)
      write_TypeZcashOrchardAddress(v.address)
      write_Sequenceu8(v.data)
    end

    # The Record type ZcashOrchardDecryptOutputForIncomingKeys.

    def write_TypeZcashOrchardDecryptOutputForIncomingKeys(v)
      write_U64(v.idx)
      write_TypeZcashOrchardIncomingViewingKey(v.key)
      write_TypeZcashOrchardNote(v.note)
      write_TypeZcashOrchardAddress(v.address)
      write_Sequenceu8(v.data)
    end

    # The Record type ZcashOrchardDecryptOutputForOutgoingKeys.

    def write_TypeZcashOrchardDecryptOutputForOutgoingKeys(v)
      write_U64(v.idx)
      write_TypeZcashOrchardOutgoingViewingKey(v.key)
      write_TypeZcashOrchardNote(v.note)
      write_TypeZcashOrchardAddress(v.address)
      write_Sequenceu8(v.data)
    end

    # The Record type ZcashOrchardTransmittedNoteCiphertext.

    def write_TypeZcashOrchardTransmittedNoteCiphertext(v)
      write_Sequenceu8(v.epk_bytes)
      write_Sequenceu8(v.enc_ciphertext)
      write_Sequenceu8(v.out_ciphertext)
    end

    # The Record type ZcashPayment.

    def write_TypeZcashPayment(v)
      write_TypeZcashRecipientAddress(v.recipient_address)
      write_TypeZcashAmount(v.amount)
      write_OptionalTypeZcashMemoBytes(v.memo)
      write_Optionalstring(v.label)
      write_Optionalstring(v.message)
      write_SequenceTypeZcashPaymentParam(v.other_params)
    end

    # The Record type ZcashPaymentParam.

    def write_TypeZcashPaymentParam(v)
      write_String(v.key)
      write_String(v.value)
    end

    # The Record type ZcashSentTransaction.

    def write_TypeZcashSentTransaction(v)
      write_TypeZcashTransaction(v.tx)
      write_TypeTimeOffsetDateTime(v.created)
      write_TypeZcashAccountId(v.account)
      write_SequenceTypeZcashSentTransactionOutput(v.outputs)
      write_TypeZcashAmount(v.fee_amount)
      write_SequenceTypeZcashOutPoint(v.utxos_spent)
    end

    # The Record type ZcashTransactionAndSaplingMetadata.

    def write_TypeZcashTransactionAndSaplingMetadata(v)
      write_TypeZcashTransaction(v.transaction)
      write_TypeZcashSaplingMetadata(v.sapling_metadata)
    end

    # The Record type ZcashTransparentAddressAndIndex.

    def write_TypeZcashTransparentAddressAndIndex(v)
      write_TypeZcashTransparentAddress(v.transparent_address)
      write_U32(v.index)
    end

    # The Record type ZcashUnifiedAddressAndDiversifierIndex.

    def write_TypeZcashUnifiedAddressAndDiversifierIndex(v)
      write_TypeZcashUnifiedAddress(v.address)
      write_TypeZcashDiversifierIndex(v.diversifier_index)
    end

    # The Enum type ZcashBranchId.

    def write_TypeZcashBranchId(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashChildIndex.

    def write_TypeZcashChildIndex(v)
      if v.non_hardened?
        pack_into(4, 'l>', 1)
        write_U32(v.v)
      end
      return unless v.hardened?

      pack_into(4, 'l>', 2)
      write_U32(v.v)
    end

    # The Enum type ZcashConsensusParameters.

    def write_TypeZcashConsensusParameters(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashDustAction.

    def write_TypeZcashDustAction(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashFeeRules.

    def write_TypeZcashFeeRules(v)
      pack_into(4, 'l>', 1) if v.fixed_standard?
      if v.fixed_non_standard?
        pack_into(4, 'l>', 2)
        write_U64(v.amount)
      end
      pack_into(4, 'l>', 3) if v.zip317_standard?
      return unless v.zip317_non_standard?

      pack_into(4, 'l>', 4)
      write_U64(v.marginal_fee)
      write_U64(v.grace_actions)
      write_U64(v.p2pkh_standard_input_size)
      write_U64(v.p2pkh_standard_output_size)
    end

    # The Enum type ZcashKeySeed.

    def write_TypeZcashKeySeed(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashKeysEra.

    def write_TypeZcashKeysEra(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashMemo.

    def write_TypeZcashMemo(v)
      pack_into(4, 'l>', 1) if v.empty?
      if v.text?
        pack_into(4, 'l>', 2)
        write_String(v.v)
      end
      if v.future?
        pack_into(4, 'l>', 3)
        write_Sequenceu8(v.v)
      end
      return unless v.arbitrary?

      pack_into(4, 'l>', 4)
      write_Sequenceu8(v.v)
    end

    # The Enum type ZcashNullifierQuery.

    def write_TypeZcashNullifierQuery(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashOrchardScope.

    def write_TypeZcashOrchardScope(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashOvkPolicy.

    def write_TypeZcashOvkPolicy(v)
      pack_into(4, 'l>', 1) if v.sender?
      if v.custom?
        pack_into(4, 'l>', 2)
        write_Sequenceu8(v.bytes)
      end
      return unless v.discard?

      pack_into(4, 'l>', 3)
    end

    # The Enum type ZcashPoolType.

    def write_TypeZcashPoolType(v)
      pack_into(4, 'l>', 1) if v.transparent?
      return unless v.shielded?

      pack_into(4, 'l>', 2)
      write_TypeZcashShieldedProtocol(v.v)
    end

    # The Enum type ZcashRecipient.

    def write_TypeZcashRecipient(v)
      if v.transparent?
        pack_into(4, 'l>', 1)
        write_Sequenceu8(v.script)
      end
      if v.sapling?
        pack_into(4, 'l>', 2)
        write_Sequenceu8(v.payment_address_bytes)
      end
      if v.unified?
        pack_into(4, 'l>', 3)
        write_String(v.uae)
        write_TypeZcashConsensusParameters(v.params)
        write_TypeZcashPoolType(v.zpt)
      end
      return unless v.internal_account?

      pack_into(4, 'l>', 4)
      write_TypeZcashAccountId(v.aid)
      write_TypeZcashPoolType(v.zpt)
    end

    # The Enum type ZcashRseed.

    def write_TypeZcashRseed(v)
      if v.before_zip212?
        pack_into(4, 'l>', 1)
        write_Sequenceu8(v.fr_data)
      end
      return unless v.after_zip212?

      pack_into(4, 'l>', 2)
      write_Sequenceu8(v.data)
    end

    # The Enum type ZcashScanPriority.

    def write_TypeZcashScanPriority(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashScope.

    def write_TypeZcashScope(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashShieldedProtocol.

    def write_TypeZcashShieldedProtocol(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashTransferType.

    def write_TypeZcashTransferType(v)
      pack_into(4, 'l>', v)
    end

    # The Enum type ZcashTxVersionSelection.

    def write_TypeZcashTxVersionSelection(v)
      if v.sprout?
        pack_into(4, 'l>', 1)
        write_U32(v.v)
      end
      pack_into(4, 'l>', 2) if v.overwinter?
      pack_into(4, 'l>', 3) if v.sapling?
      return unless v.zip225?

      pack_into(4, 'l>', 4)
    end

    # The Optional<T> type for u64.

    def write_Optionalu64(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_U64(v)
      end
    end

    # The Optional<T> type for string.

    def write_Optionalstring(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_String(v)
      end
    end

    # The Optional<T> type for TypeZcashAccountPubKey.

    def write_OptionalTypeZcashAccountPubKey(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashAccountPubKey(v)
      end
    end

    # The Optional<T> type for TypeZcashAmount.

    def write_OptionalTypeZcashAmount(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashAmount(v)
      end
    end

    # The Optional<T> type for TypeZcashBlockHash.

    def write_OptionalTypeZcashBlockHash(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashBlockHash(v)
      end
    end

    # The Optional<T> type for TypeZcashBlockHeight.

    def write_OptionalTypeZcashBlockHeight(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashBlockHeight(v)
      end
    end

    # The Optional<T> type for TypeZcashBlockMeta.

    def write_OptionalTypeZcashBlockMeta(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashBlockMeta(v)
      end
    end

    # The Optional<T> type for TypeZcashBlockMetadata.

    def write_OptionalTypeZcashBlockMetadata(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashBlockMetadata(v)
      end
    end

    # The Optional<T> type for TypeZcashDiversifiableFullViewingKey.

    def write_OptionalTypeZcashDiversifiableFullViewingKey(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashDiversifiableFullViewingKey(v)
      end
    end

    # The Optional<T> type for TypeZcashMemoBytes.

    def write_OptionalTypeZcashMemoBytes(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashMemoBytes(v)
      end
    end

    # The Optional<T> type for TypeZcashOrchardAddress.

    def write_OptionalTypeZcashOrchardAddress(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashOrchardAddress(v)
      end
    end

    # The Optional<T> type for TypeZcashOrchardBundle.

    def write_OptionalTypeZcashOrchardBundle(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashOrchardBundle(v)
      end
    end

    # The Optional<T> type for TypeZcashOrchardDiversifierIndex.

    def write_OptionalTypeZcashOrchardDiversifierIndex(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashOrchardDiversifierIndex(v)
      end
    end

    # The Optional<T> type for TypeZcashOrchardFullViewingKey.

    def write_OptionalTypeZcashOrchardFullViewingKey(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashOrchardFullViewingKey(v)
      end
    end

    # The Optional<T> type for TypeZcashOrchardOutgoingViewingKey.

    def write_OptionalTypeZcashOrchardOutgoingViewingKey(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashOrchardOutgoingViewingKey(v)
      end
    end

    # The Optional<T> type for TypeZcashOutgoingViewingKey.

    def write_OptionalTypeZcashOutgoingViewingKey(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashOutgoingViewingKey(v)
      end
    end

    # The Optional<T> type for TypeZcashPaymentAddress.

    def write_OptionalTypeZcashPaymentAddress(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashPaymentAddress(v)
      end
    end

    # The Optional<T> type for TypeZcashRatio.

    def write_OptionalTypeZcashRatio(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashRatio(v)
      end
    end

    # The Optional<T> type for TypeZcashSaplingBundle.

    def write_OptionalTypeZcashSaplingBundle(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashSaplingBundle(v)
      end
    end

    # The Optional<T> type for TypeZcashSaplingMerklePath.

    def write_OptionalTypeZcashSaplingMerklePath(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashSaplingMerklePath(v)
      end
    end

    # The Optional<T> type for TypeZcashTransparentAddress.

    def write_OptionalTypeZcashTransparentAddress(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashTransparentAddress(v)
      end
    end

    # The Optional<T> type for TypeZcashTransparentBundle.

    def write_OptionalTypeZcashTransparentBundle(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashTransparentBundle(v)
      end
    end

    # The Optional<T> type for TypeZcashUnifiedAddress.

    def write_OptionalTypeZcashUnifiedAddress(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashUnifiedAddress(v)
      end
    end

    # The Optional<T> type for TypeZcashWalletSummary.

    def write_OptionalTypeZcashWalletSummary(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashWalletSummary(v)
      end
    end

    # The Optional<T> type for TypeTupleAccountIdAndSaplingNote.

    def write_OptionalTypeTupleAccountIdAndSaplingNote(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeTupleAccountIdAndSaplingNote(v)
      end
    end

    # The Optional<T> type for TypeTupleBlockHeightAndHash.

    def write_OptionalTypeTupleBlockHeightAndHash(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeTupleBlockHeightAndHash(v)
      end
    end

    # The Optional<T> type for TypeTupleTargetAndAnchorHeight.

    def write_OptionalTypeTupleTargetAndAnchorHeight(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeTupleTargetAndAnchorHeight(v)
      end
    end

    # The Optional<T> type for TypeZcashAccountId.

    def write_OptionalTypeZcashAccountId(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashAccountId(v)
      end
    end

    # The Optional<T> type for TypeZcashDiversifierIndexAndPaymentAddress.

    def write_OptionalTypeZcashDiversifierIndexAndPaymentAddress(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashDiversifierIndexAndPaymentAddress(v)
      end
    end

    # The Optional<T> type for TypeZcashDiversifierIndexAndScope.

    def write_OptionalTypeZcashDiversifierIndexAndScope(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashDiversifierIndexAndScope(v)
      end
    end

    # The Optional<T> type for TypeZcashUnifiedAddressAndDiversifierIndex.

    def write_OptionalTypeZcashUnifiedAddressAndDiversifierIndex(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashUnifiedAddressAndDiversifierIndex(v)
      end
    end

    # The Optional<T> type for TypeZcashOrchardScope.

    def write_OptionalTypeZcashOrchardScope(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_TypeZcashOrchardScope(v)
      end
    end

    # The Optional<T> type for Sequenceu8.

    def write_OptionalSequenceu8(v)
      if v.nil?
        pack_into(1, 'c', 0)
      else
        pack_into(1, 'c', 1)
        write_Sequenceu8(v)
      end
    end

    # The Sequence<T> type for u8.

    def write_Sequenceu8(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_U8(item)
      end
    end

    # The Sequence<T> type for u32.

    def write_Sequenceu32(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_U32(item)
      end
    end

    # The Sequence<T> type for u64.

    def write_Sequenceu64(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_U64(item)
      end
    end

    # The Sequence<T> type for TypeZcashBlockHeight.

    def write_SequenceTypeZcashBlockHeight(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashBlockHeight(item)
      end
    end

    # The Sequence<T> type for TypeZcashBlockMeta.

    def write_SequenceTypeZcashBlockMeta(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashBlockMeta(item)
      end
    end

    # The Sequence<T> type for TypeZcashCommitmentTreeRoot.

    def write_SequenceTypeZcashCommitmentTreeRoot(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashCommitmentTreeRoot(item)
      end
    end

    # The Sequence<T> type for TypeZcashDecryptedOutput.

    def write_SequenceTypeZcashDecryptedOutput(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashDecryptedOutput(item)
      end
    end

    # The Sequence<T> type for TypeZcashOrchardAction.

    def write_SequenceTypeZcashOrchardAction(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashOrchardAction(item)
      end
    end

    # The Sequence<T> type for TypeZcashOrchardIncomingViewingKey.

    def write_SequenceTypeZcashOrchardIncomingViewingKey(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashOrchardIncomingViewingKey(item)
      end
    end

    # The Sequence<T> type for TypeZcashOrchardMerkleHash.

    def write_SequenceTypeZcashOrchardMerkleHash(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashOrchardMerkleHash(item)
      end
    end

    # The Sequence<T> type for TypeZcashOrchardOutgoingViewingKey.

    def write_SequenceTypeZcashOrchardOutgoingViewingKey(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashOrchardOutgoingViewingKey(item)
      end
    end

    # The Sequence<T> type for TypeZcashOrchardSpendingKey.

    def write_SequenceTypeZcashOrchardSpendingKey(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashOrchardSpendingKey(item)
      end
    end

    # The Sequence<T> type for TypeZcashOutPoint.

    def write_SequenceTypeZcashOutPoint(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashOutPoint(item)
      end
    end

    # The Sequence<T> type for TypeZcashReceivedNoteId.

    def write_SequenceTypeZcashReceivedNoteId(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashReceivedNoteId(item)
      end
    end

    # The Sequence<T> type for TypeZcashReceivedSaplingNote.

    def write_SequenceTypeZcashReceivedSaplingNote(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashReceivedSaplingNote(item)
      end
    end

    # The Sequence<T> type for TypeZcashSaplingNullifier.

    def write_SequenceTypeZcashSaplingNullifier(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashSaplingNullifier(item)
      end
    end

    # The Sequence<T> type for TypeZcashSaplingOutputDescription.

    def write_SequenceTypeZcashSaplingOutputDescription(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashSaplingOutputDescription(item)
      end
    end

    # The Sequence<T> type for TypeZcashSaplingSpendDescription.

    def write_SequenceTypeZcashSaplingSpendDescription(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashSaplingSpendDescription(item)
      end
    end

    # The Sequence<T> type for TypeZcashScanRange.

    def write_SequenceTypeZcashScanRange(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashScanRange(item)
      end
    end

    # The Sequence<T> type for TypeZcashScannedBlock.

    def write_SequenceTypeZcashScannedBlock(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashScannedBlock(item)
      end
    end

    # The Sequence<T> type for TypeZcashSentTransactionOutput.

    def write_SequenceTypeZcashSentTransactionOutput(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashSentTransactionOutput(item)
      end
    end

    # The Sequence<T> type for TypeZcashTransparentAddress.

    def write_SequenceTypeZcashTransparentAddress(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashTransparentAddress(item)
      end
    end

    # The Sequence<T> type for TypeZcashTxIn.

    def write_SequenceTypeZcashTxIn(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashTxIn(item)
      end
    end

    # The Sequence<T> type for TypeZcashTxOut.

    def write_SequenceTypeZcashTxOut(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashTxOut(item)
      end
    end

    # The Sequence<T> type for TypeZcashWalletSaplingOutput.

    def write_SequenceTypeZcashWalletSaplingOutput(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashWalletSaplingOutput(item)
      end
    end

    # The Sequence<T> type for TypeZcashWalletSaplingSpend.

    def write_SequenceTypeZcashWalletSaplingSpend(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashWalletSaplingSpend(item)
      end
    end

    # The Sequence<T> type for TypeZcashWalletTransparentOutput.

    def write_SequenceTypeZcashWalletTransparentOutput(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashWalletTransparentOutput(item)
      end
    end

    # The Sequence<T> type for TypeZcashWalletTx.

    def write_SequenceTypeZcashWalletTx(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashWalletTx(item)
      end
    end

    # The Sequence<T> type for TypeTripleSaplingNullifierMap.

    def write_SequenceTypeTripleSaplingNullifierMap(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeTripleSaplingNullifierMap(item)
      end
    end

    # The Sequence<T> type for TypeTupleAccountIdAndSaplingNullifier.

    def write_SequenceTypeTupleAccountIdAndSaplingNullifier(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeTupleAccountIdAndSaplingNullifier(item)
      end
    end

    # The Sequence<T> type for TypeTupleSaplingCommitments.

    def write_SequenceTypeTupleSaplingCommitments(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeTupleSaplingCommitments(item)
      end
    end

    # The Sequence<T> type for TypeZcashAuthPath.

    def write_SequenceTypeZcashAuthPath(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashAuthPath(item)
      end
    end

    # The Sequence<T> type for TypeZcashOrchardDecryptOutputForIncomingKeys.

    def write_SequenceTypeZcashOrchardDecryptOutputForIncomingKeys(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashOrchardDecryptOutputForIncomingKeys(item)
      end
    end

    # The Sequence<T> type for TypeZcashOrchardDecryptOutputForOutgoingKeys.

    def write_SequenceTypeZcashOrchardDecryptOutputForOutgoingKeys(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashOrchardDecryptOutputForOutgoingKeys(item)
      end
    end

    # The Sequence<T> type for TypeZcashPayment.

    def write_SequenceTypeZcashPayment(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashPayment(item)
      end
    end

    # The Sequence<T> type for TypeZcashPaymentParam.

    def write_SequenceTypeZcashPaymentParam(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashPaymentParam(item)
      end
    end

    # The Sequence<T> type for TypeZcashChildIndex.

    def write_SequenceTypeZcashChildIndex(items)
      pack_into(4, 'l>', items.size)

      items.each do |item|
        write_TypeZcashChildIndex(item)
      end
    end

    # The Map<T> type for TypeZcashAccountBalance.

    def write_MapStringTypeZcashAccountBalance(items)
      pack_into(4, 'l>', items.size)

      items.each do |k, v|
        write_String(k)
        write_TypeZcashAccountBalance(v)
      end
    end

    def write_MapStringTypeZcashAddressMetadata(items)
      pack_into(4, 'l>', items.size)

      items.each do |k, v|
        write_String(k)
        write_TypeZcashAddressMetadata(v)
      end
    end

    def write_MapStringTypeZcashAmount(items)
      pack_into(4, 'l>', items.size)

      items.each do |k, v|
        write_String(k)
        write_TypeZcashAmount(v)
      end
    end

    def write_MapTypeZcashAccountIdTypeZcashUnifiedFullViewingKey(items)
      pack_into(4, 'l>', items.size)

      items.each do |k, v|
        write_String(k)
        write_TypeZcashUnifiedFullViewingKey(v)
      end
    end

    private

    def reserve(num_bytes)
      @rust_buf = RustBuffer.reserve(@rust_buf, num_bytes) if @rust_buf.len + num_bytes > @rust_buf.capacity

      yield

      @rust_buf.len += num_bytes
    end

    def pack_into(size, format, value)
      reserve(size) do
        @rust_buf.data.put_array_of_char @rust_buf.len, [value].pack(format).bytes
      end
    end
  end

  private_constant :RustBufferBuilder

  # Error definitions
  class RustCallStatus < FFI::Struct
    layout :code, :int8,
           :error_buf, RustBuffer

    def code
      self[:code]
    end

    def error_buf
      self[:error_buf]
    end

    def to_s
      "RustCallStatus(code=#{self[:code]})"
    end
  end

  # These match the values from the uniffi::rustcalls module
  CALL_SUCCESS = 0
  CALL_ERROR = 1
  CALL_PANIC = 2

  class ZcashError
    HdWalletError = Class.new StandardError
    DecodingError = Class.new StandardError
    DerivationError = Class.new StandardError
    InvalidAsk = Class.new StandardError
    InvalidNsk = Class.new StandardError
    Message = Class.new StandardError
    ArrayLengthMismatch = Class.new StandardError
    ValueOutOfRange = Class.new StandardError
    Secp256k1Error = Class.new StandardError
    Bech32DecodeError = Class.new StandardError
    Bs58Error = Class.new StandardError
    BuilderError = Class.new StandardError
    TransparentBuilderError = Class.new StandardError
    SaplingBuilderError = Class.new StandardError
    OrchardBuilderError = Class.new StandardError
    OrchardBuilderSpendError = Class.new StandardError
    OrchardBuilderOutputError = Class.new StandardError
    InsufficientFundsError = Class.new StandardError
    ChangeRequiredError = Class.new StandardError
    BalanceError = Class.new StandardError
    IoError = Class.new StandardError
    Unknown = Class.new StandardError
  end

  module ZcashWalletMigrationError
    class SeedRequired < StandardError
      def initialize(v)
        @v = v
        super()
      end

      attr_reader :v

      def to_s
        "#{self.class.name}(v=#{@v.inspect})"
      end
    end

    class CorruptedData < StandardError
      def initialize(v)
        @v = v
        super()
      end

      attr_reader :v

      def to_s
        "#{self.class.name}(v=#{@v.inspect})"
      end
    end

    class DbError < StandardError
      def initialize(v)
        @v = v
        super()
      end

      attr_reader :v

      def to_s
        "#{self.class.name}(v=#{@v.inspect})"
      end
    end

    class BalanceError < StandardError
      def initialize(v)
        @v = v
        super()
      end

      attr_reader :v

      def to_s
        "#{self.class.name}(v=#{@v.inspect})"
      end
    end

    class CommitmentTreeError < StandardError
      def initialize(v)
        @v = v
        super()
      end

      attr_reader :v

      def to_s
        "#{self.class.name}(v=#{@v.inspect})"
      end
    end
  end

  module ZcashZip321Error
    class TooManyPayments < StandardError
      def initialize(v)
        @v = v
        super()
      end

      attr_reader :v

      def to_s
        "#{self.class.name}(v=#{@v.inspect})"
      end
    end

    class TransparentMemo < StandardError
      def initialize(v)
        @v = v
        super()
      end

      attr_reader :v

      def to_s
        "#{self.class.name}(v=#{@v.inspect})"
      end
    end

    class RecipientMissing < StandardError
      def initialize(v)
        @v = v
        super()
      end

      attr_reader :v

      def to_s
        "#{self.class.name}(v=#{@v.inspect})"
      end
    end

    class ParseError < StandardError
      def initialize(v)
        @v = v
        super()
      end

      attr_reader :v

      def to_s
        "#{self.class.name}(v=#{@v.inspect})"
      end
    end
  end

  # Map error modules to the RustBuffer method name that reads them
  ERROR_MODULE_TO_READER_METHOD = {

    ZcashError => :readTypeZcashError,

    ZcashWalletMigrationError => :readTypeZcashWalletMigrationError,

    ZcashZip321Error => :readTypeZcashZip321Error

  }.freeze

  private_constant :ERROR_MODULE_TO_READER_METHOD, :CALL_SUCCESS, :CALL_ERROR, :CALL_PANIC,
                   :RustCallStatus

  def self.consume_buffer_into_error(error_module, rust_buffer)
    rust_buffer.consumeWithStream do |stream|
      reader_method = ERROR_MODULE_TO_READER_METHOD[error_module]
      return stream.send(reader_method)
    end
  end

  class InternalError < StandardError
  end

  def self.rust_call(fn_name, *args)
    # Call a rust function
    rust_call_with_error(nil, fn_name, *args)
  end

  def self.rust_call_with_error(error_module, fn_name, *args)
    # Call a rust function and handle errors
    #
    # Use this when the rust function returns a Result<>.  error_module must be the error_module that corresponds to that Result.

    # NOTE: RustCallStatus.new zeroes out the struct, which is exactly what we
    # want to pass to Rust (code=0, error_buf=RustBuffer(len=0, capacity=0,
    # data=NULL))
    status = RustCallStatus.new
    args << status

    result = UniFFILib.public_send(fn_name, *args)

    case status.code
    when CALL_SUCCESS
      result
    when CALL_ERROR
      raise consume_buffer_into_error(error_module, status.error_buf) unless error_module.nil?

      status.error_buf.free
      raise InternalError, 'CALL_ERROR with no error_module set'

    when CALL_PANIC
      # When the rust code sees a panic, it tries to construct a RustBuffer
      # with the message.  But if that code panics, then it just sends back
      # an empty buffer.
      raise InternalError, status.error_buf.consumeIntoString if status.error_buf.len.positive?

      raise InternalError, 'Rust panic'

    else
      raise InternalError, "Unknown call status: #{status.code}"
    end
  end

  private_class_method :consume_buffer_into_error

  # This is how we find and load the dynamic library provided by the component.
  # For now we just look it up by name.
  module UniFFILib
    extend FFI::Library

    ffi_lib 'uniffi_zcash'

    attach_function :uniffi_uniffi_zcash_fn_free_merkletreefrontier,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_merkletreeposition,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_merkletreeretention,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_secpsecretkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_secpsecretkey_new,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_secpsecretkey_serialize_secret,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_testsupport,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_testsupport_from_csv_file,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_testsupport_get_as_string,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_testsupport_get_as_u32,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_method_testsupport_get_as_u32_array,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_testsupport_get_as_u64,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :uint64
    attach_function :uniffi_uniffi_zcash_fn_method_testsupport_get_as_u64_array,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_testsupport_get_as_u8_array,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_timeoffsetdatetime,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_zcashaccountbalance,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashaccountbalance_zero,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountbalance_sapling_spendable_value,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountbalance_total,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountbalance_unshielded,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashaccountbirthday,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashaccountbirthday_from_treestate,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountbirthday_height,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountbirthday_recover_until,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountbirthday_sapling_frontier,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashaccountprivkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashaccountprivkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashaccountprivkey_from_extended_privkey,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashaccountprivkey_from_seed,
                    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_derive_external_secret_key,
                    [:pointer, :uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_derive_internal_secret_key,
                    [:pointer, :uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_to_account_pubkey,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashaccountpubkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashaccountpubkey_new,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_derive_external_ivk,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_derive_internal_ivk,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_external_ovk,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_internal_ovk,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_ovks_for_shielding,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_serialize,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashaddressmetadata,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashaddressmetadata_new,
                    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaddressmetadata_account,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashaddressmetadata_diversifier_index,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashamount,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashamount_new,
                    [:int64, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashamount_zero,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashamount_value,
                    [:pointer, RustCallStatus.by_ref],
                    :int64
    attach_function :uniffi_uniffi_zcash_fn_free_zcashanchor,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashanchor_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashanchor_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashbalance,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashbalance_zero,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashbalance_total,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashblockhash,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashblockhash_from_slice,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashblockheight,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashblockheight_new,
                    [:uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashblockheight_value,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_free_zcashblockmeta,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashblockmeta_new,
                    [:pointer, :pointer, :uint32, :uint32, :uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashblockmeta_block_file_path,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashblockmetadata,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashblockmetadata_from_parts,
                    [:pointer, :pointer, :uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashblockmetadata_block_hash,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashblockmetadata_block_height,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashblockmetadata_sapling_tree_size,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_free_zcashcommitmenttree,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashcommitmenttree_empty,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashcommitmenttree_append,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_zcashcommitmenttreeroot,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashcommitmenttreeroot_from_parts,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashcommitmenttreeroot_root_hash,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashcommitmenttreeroot_subtree_end_height,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashdecryptedoutput,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdecryptedoutput_account,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdecryptedoutput_index,
                    [:pointer, RustCallStatus.by_ref],
                    :uint64
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdecryptedoutput_memo,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdecryptedoutput_note,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdecryptedoutput_transfer_type,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashdecryptedtransaction,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_zcashdiversifiablefullviewingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashdiversifiablefullviewingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_change_address,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_decrypt_diversifier,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_default_address,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_diversified_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_diversified_change_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_find_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_fvk,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_ivk,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_nk,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_ovk,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashdiversifier,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashdiversifier_new,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifier_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashdiversifierindex,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashdiversifierindex_from_u32,
                    [:uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashdiversifierindex_from_u64,
                    [:uint64, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashdiversifierindex_new,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifierindex_increment,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifierindex_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdiversifierindex_to_u32,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_free_zcashdustoutputpolicy,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashdustoutputpolicy_new,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdustoutputpolicy_action,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashdustoutputpolicy_dust_threshold,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashexpandedspendingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashexpandedspendingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashexpandedspendingkey_from_spending_key,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashexpandedspendingkey_proof_generation_key,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashexpandedspendingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashextendedfullviewingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextendedfullviewingkey_decode,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextendedfullviewingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_default_address,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_derive_child,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_derive_internal,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_encode,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_find_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_to_diversifiable_full_viewing_key,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashextendedprivkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_random,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_random_with_seed_size,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_with_seed,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedprivkey_derive_private_key,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedprivkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashextendedspendingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_decode,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_from_path,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_master,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_default_address,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_derive_child,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_derive_internal,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_encode,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_to_diversifiable_full_viewing_key,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashexternalivk,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashexternalivk_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashexternalivk_default_address,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashexternalivk_derive_address,
                    [:pointer, :uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashexternalivk_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashexternalovk,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashexternalovk_as_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashextractednotecommitment,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashextractednotecommitment_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashextractednotecommitment_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashfixedfeerule,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashfixedfeerule_non_standard,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashfixedfeerule_standard,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashfixedfeerule_fixed_fee,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashfixedsingleoutputchangestrategy,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashfixedsingleoutputchangestrategy_new,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashfsblockdb,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashfsblockdb_for_path,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashfsblockdb_find_block,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashfsblockdb_get_max_cached_height,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashfsblockdb_initialize,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashfsblockdb_write_block_metadata,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_zcashfullviewingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashfullviewingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashfullviewingkey_from_expanded_spending_key,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashfullviewingkey_ovk,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashfullviewingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashfullviewingkey_vk,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashincrementalwitness,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashincrementalwitness_from_tree,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashincrementalwitness_append,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashincrementalwitness_path,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashinternalivk,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashinternalivk_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashinternalivk_default_address,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashinternalivk_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashinternalovk,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashinternalovk_as_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashjubjubfr,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashjubjubfr_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashjubjubfr_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashkeyindex,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashkeyindex_from_index,
                    [:uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashkeyindex_from_u32,
                    [:uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashkeyindex_hardened_from_normalize_index,
                    [:uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashkeyindex_is_valid,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashkeyindex_normalize_index,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_method_zcashkeyindex_raw_index,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_free_zcashlocaltxprover,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashlocaltxprover_from_bytes,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashlocaltxprover_new,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashlocaltxprover_with_default_location,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashmainfixedgreedyinputselector,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashmainfixedgreedyinputselector_new,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashmainzip317greedyinputselector,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashmainzip317greedyinputselector_new,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashmemobytes,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashmemobytes_empty,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashmemobytes_new,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashmemobytes_data,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashnonnegativeamount,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashnonnegativeamount_from_nonnegative_i64,
                    [:int64, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashnonnegativeamount_from_u64,
                    [:uint64, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashnonnegativeamount_zero,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashnonnegativeamount_value,
                    [:pointer, RustCallStatus.by_ref],
                    :uint64
    attach_function :uniffi_uniffi_zcash_fn_free_zcashnoteid,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashnoteid_new,
                    [:pointer, RustBuffer.by_value, :uint16, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashnullifierderivingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashnullifierderivingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashnullifierderivingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardaction,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardaction_cmx,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardaction_cv_net,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardaction_encrypted_note,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardaction_nullifier,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardaddress,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardaddress_from_raw_address_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardaddress_diversifier,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardaddress_to_raw_address_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardbundle,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_actions,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_anchor,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_decrypt_output_with_key,
                    [:pointer, :uint64, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_decrypt_output_with_keys,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_flags,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_recover_output_with_ovk,
                    [:pointer, :uint64, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_recover_outputs_with_ovks,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_value_balance,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_verify_proof,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorcharddiversifier,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifier_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorcharddiversifier_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorcharddiversifierindex,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifierindex_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifierindex_from_u32,
                    [:uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifierindex_from_u64,
                    [:uint64, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorcharddiversifierindex_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardflags,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardflags_from_byte,
                    [:uint8, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardflags_from_parts,
                    [:int8, :int8, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardflags_outputs_enabled,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardflags_spends_enabled,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardflags_to_byte,
                    [:pointer, RustCallStatus.by_ref],
                    :uint8
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardfullviewingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardfullviewingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_address,
                    [:pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_address_at,
                    [:pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_scope_for_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_to_ivk,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_to_ovk,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardincomingviewingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardincomingviewingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_address_at,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_diversifier_index,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardmerklehash,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardmerklehash_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardmerklehash_from_cmx,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardmerklehash_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardmerklepath,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardmerklepath_from_parts,
                    [:uint32, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardmerklepath_root,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardnote,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardnote_from_parts,
                    [:pointer, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardnote_commitment,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardnote_recipient,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardnote_value,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardnotecommitment,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardnotecommitment_to_extracted_note_commitment,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardnotevalue,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardnotevalue_from_raw,
                    [:uint64, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardnotevalue_value,
                    [:pointer, RustCallStatus.by_ref],
                    :uint64
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardnullifier,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardnullifier_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardnullifier_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardoutgoingviewingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardoutgoingviewingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardoutgoingviewingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardrandomseed,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardrandomseed_from_bytes,
                    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardrandomseed_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardspendingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardspendingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardspendingkey_from_zip32_seed,
                    [RustBuffer.by_value, :uint32, :uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardspendingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardspendingkey_to_fvk,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardtransactionbuilder,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashorchardtransactionbuilder_new,
                    [RustBuffer.by_value, :pointer, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardtransactionbuilder_add_recipient,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardtransactionbuilder_add_spend,
                    [:pointer, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardtransactionbuilder_build,
                    [:pointer, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashorchardvaluecommitment,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashorchardvaluecommitment_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashoutpoint,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashoutpoint_new,
                    [RustBuffer.by_value, :uint32, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashoutgoingviewingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashoutgoingviewingkey_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashoutgoingviewingkey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashpaymentaddress,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashpaymentaddress_decode,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashpaymentaddress_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_create_note,
                    [:pointer, :uint64, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_diversifier,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_encode,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_pk_d,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashproofgenerationkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashproofgenerationkey_to_viewing_key,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashprovingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashprovingkey_new,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashratio,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashratio_new,
                    [:uint64, :uint64, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashratio_denominator,
                    [:pointer, RustCallStatus.by_ref],
                    :uint64
    attach_function :uniffi_uniffi_zcash_fn_method_zcashratio_numerator,
                    [:pointer, RustCallStatus.by_ref],
                    :uint64
    attach_function :uniffi_uniffi_zcash_fn_free_zcashreceivednoteid,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_zcashreceivedsaplingnote,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashreceivedsaplingnote_diversifier,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashreceivedsaplingnote_internal_note_id,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashreceivedsaplingnote_note_commitment_tree_position,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashreceivedsaplingnote_value,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashrecipientaddress,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_decode,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_shielded,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_transparent,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_unified,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashrecipientaddress_encode,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingbundle,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingbundle_shielded_outputs,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingbundle_shielded_spends,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingbundle_value_balance,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingdiversifiedtransmissionkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingextractednotecommitment,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashsaplingextractednotecommitment_new,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingextractednotecommitment_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingivk,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingivk_to_payment_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingivk_to_repr,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingmerklepath,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingmerklepath_auth_path,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingmerklepath_position,
                    [:pointer, RustCallStatus.by_ref],
                    :uint64
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingmetadata,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashsaplingmetadata_new,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingmetadata_output_index,
                    [:pointer, :uint64, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingmetadata_spend_index,
                    [:pointer, :uint64, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingnode,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashsaplingnode_from_cmu,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingnote,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashsaplingnote_from_parts,
                    [:pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingnote_cmu,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingnote_value,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingnotevalue,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashsaplingnotevalue_from_raw,
                    [:uint64, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingnotevalue_inner,
                    [:pointer, RustCallStatus.by_ref],
                    :uint64
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingnullifier,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingnullifier_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingoutputdescription,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingoutputdescription_cmu,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingoutputdescription_cv,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingpublickey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingpublickey_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingspenddescription,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_anchor,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_cv,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_nullifier,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_rk,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsaplingvaluecommitment,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsaplingvaluecommitment_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashscanrange,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashscanrange_from_parts,
                    [:pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscanrange_block_range,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscanrange_is_empty,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscanrange_len,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscanrange_priority,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashscannedblock,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashscannedblock_from_parts,
                    [:pointer, :uint32, RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscannedblock_block_hash,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscannedblock_block_time,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscannedblock_height,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscannedblock_metadata,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscannedblock_sapling_commitments,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscannedblock_sapling_nullifier_map,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscannedblock_transactions,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashscript,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashscript_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashscript_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashsenttransactionoutput,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashsenttransactionoutput_from_parts,
                    [:uint32, RustBuffer.by_value, :pointer, RustBuffer.by_value, RustBuffer.by_value,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsenttransactionoutput_memo,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsenttransactionoutput_output_index,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsenttransactionoutput_recipient,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsenttransactionoutput_sapling_change_to,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashsenttransactionoutput_value,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtestfixedgreedyinputselector,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtestfixedgreedyinputselector_new,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtestzip317greedyinputselector,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtestzip317greedyinputselector_new,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtransaction,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtransaction_from_bytes,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransaction_consensus_branch_id,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransaction_expiry_height,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransaction_lock_time,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransaction_orchard_bundle,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransaction_sapling_bundle,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransaction_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransaction_transparent_bundle,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransaction_txid,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransaction_version,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtransactionbuilder,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtransactionbuilder_new,
                    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_sapling_output,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_sapling_spend,
                    [:pointer, :pointer, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_transparent_input,
                    [:pointer, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_transparent_output,
                    [:pointer, :pointer, :pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_build,
                    [:pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtransactionrequest,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtransactionrequest_empty,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtransactionrequest_from_uri,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtransactionrequest_new,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransactionrequest_payments,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransactionrequest_to_uri,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtransparentaddress,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtransparentaddress_decode,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtransparentaddress_from_public_key,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtransparentaddress_from_script,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_encode,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_is_public_key,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_is_script,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_script,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtransparentbundle,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransparentbundle_is_coinbase,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransparentbundle_vin,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtransparentbundle_vout,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtreestate,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtreestate_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtreestate_new,
                    [RustBuffer.by_value, :uint64, RustBuffer.by_value, :uint32, RustBuffer.by_value, RustBuffer.by_value,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtxid,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtxid_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxid_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxid_to_hex_string,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtxin,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxin_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtxout,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtxout_new,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxout_recipient_address,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxout_script_pubkey,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxout_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxout_value,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashtxversion,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtxversion_from_bytes,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashtxversion_suggested_for_branch,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxversion_has_orchard,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxversion_has_overwinter,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxversion_has_sapling,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxversion_has_sprout,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxversion_header,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxversion_selection,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxversion_to_bytes,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashtxversion_version_group_id,
                    [:pointer, RustCallStatus.by_ref],
                    :uint32
    attach_function :uniffi_uniffi_zcash_fn_free_zcashunifiedaddress,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashunifiedaddress_decode,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashunifiedaddress_new,
                    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_encode,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_orchard,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_sapling,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_transparent,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashunifiedfullviewingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashunifiedfullviewingkey_decode,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashunifiedfullviewingkey_new,
                    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_default_address,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_encode,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_find_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_orchard,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_sapling,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_transparent,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashunifiedspendingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashunifiedspendingkey_from_bytes,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashunifiedspendingkey_from_seed,
                    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_orchard,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_sapling,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_to_bytes,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_to_unified_full_viewing_key,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_transparent,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashverifyingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashverifyingkey_new,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashviewingkey,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashviewingkey_ivk,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashviewingkey_to_payment_address,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashwalletdb,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashwalletdb_for_path,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_block_fully_scanned,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_block_max_scanned,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_block_metadata,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_chain_height,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_create_account,
                    [:pointer, RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_account_birthday,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_account_for_ufvk,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_block_hash,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_current_address,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_max_height_hash,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_memo,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_min_unspent_height,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_next_available_address,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_sapling_nullifiers,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_spendable_sapling_notes,
                    [:pointer, RustBuffer.by_value, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_target_and_anchor_heights,
                    [:pointer, :uint32, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_transaction,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_transparent_balances,
                    [:pointer, RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_transparent_receivers,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_tx_height,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_unified_full_viewing_keys,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_unspent_transparent_outputs,
                    [:pointer, :pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_wallet_birthday,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_wallet_summary,
                    [:pointer, :uint32, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_initialize,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_is_valid_account_extfvk,
                    [:pointer, RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_put_blocks,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_put_received_transparent_utxo,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :int64
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_put_sapling_subtree_roots,
                    [:pointer, :uint64, RustBuffer.by_value, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_select_spendable_sapling_notes,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_store_decrypted_tx,
                    [:pointer, :pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_store_sent_tx,
                    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_suggest_scan_ranges,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_truncate_to_height,
                    [:pointer, :uint32, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletdb_update_chain_tip,
                    [:pointer, :uint32, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_zcashwalletsaplingoutput,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_zcashwalletsaplingspend,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_free_zcashwalletsummary,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashwalletsummary_new,
                    [RustBuffer.by_value, :pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletsummary_account_balances,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletsummary_chain_tip_height,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletsummary_fully_scanned_height,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletsummary_is_synced,
                    [:pointer, RustCallStatus.by_ref],
                    :int8
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwalletsummary_scan_progress,
                    [:pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_free_zcashwallettransparentoutput,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashwallettransparentoutput_from_parts,
                    [:pointer, :pointer, :pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_height,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_outpoint,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_recipient_address,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_txout,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_value,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashwallettx,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashwallettx_new,
                    [:pointer, :uint32, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashzip317feerule,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashzip317feerule_non_standard,
                    [:pointer, :uint64, :uint64, :uint64, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashzip317feerule_standard,
                    [RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_method_zcashzip317feerule_marginal_fee,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_free_zcashzip317singleoutputchangestrategy,
                    [:pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_constructor_zcashzip317singleoutputchangestrategy_new,
                    [:pointer, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_decode_extended_full_viewing_key,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_decode_extended_spending_key,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_decode_payment_address,
                    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_decode_transparent_address,
                    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_decrypt_and_store_transaction,
                    [RustBuffer.by_value, :pointer, :pointer, RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_func_decrypt_transaction,
                    [RustBuffer.by_value, :pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_func_encode_extended_full_viewing_key,
                    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_func_encode_extended_spending_key,
                    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_func_encode_payment_address,
                    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_func_encode_payment_address_p,
                    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_func_encode_transparent_address,
                    [RustBuffer.by_value, RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_func_encode_transparent_address_p,
                    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_fn_func_scan_cached_blocks,
                    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, :pointer, :uint32,
                     RustCallStatus.by_ref],
                    :void
    attach_function :uniffi_uniffi_zcash_fn_func_shield_transparent_funds_main_fixed,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, :uint64, :pointer, RustBuffer.by_value, :pointer, :uint32,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_shield_transparent_funds_main_zip317,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, :uint64, :pointer, RustBuffer.by_value, :pointer, :uint32,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_shield_transparent_funds_test_fixed,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, :uint64, :pointer, RustBuffer.by_value, :pointer, :uint32,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_shield_transparent_funds_test_zip317,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, :uint64, :pointer, RustBuffer.by_value, :pointer, :uint32,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_spend_main_fixed,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, :pointer, :pointer, RustBuffer.by_value, :uint32,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_spend_main_zip317,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, :pointer, :pointer, RustBuffer.by_value, :uint32,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_spend_test_fixed,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, :pointer, :pointer, RustBuffer.by_value, :uint32,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :uniffi_uniffi_zcash_fn_func_spend_test_zip317,
                    [:pointer, RustBuffer.by_value, :pointer, :pointer, :pointer, :pointer, RustBuffer.by_value, :uint32,
                     RustCallStatus.by_ref],
                    :pointer
    attach_function :ffi_uniffi_zcash_rustbuffer_alloc,
                    [:int32, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :ffi_uniffi_zcash_rustbuffer_from_bytes,
                    [ForeignBytes, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :ffi_uniffi_zcash_rustbuffer_free,
                    [RustBuffer.by_value, RustCallStatus.by_ref],
                    :void
    attach_function :ffi_uniffi_zcash_rustbuffer_reserve,
                    [RustBuffer.by_value, :int32, RustCallStatus.by_ref],
                    RustBuffer.by_value
    attach_function :uniffi_uniffi_zcash_checksum_func_decode_extended_full_viewing_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_decode_extended_spending_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_decode_payment_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_decode_transparent_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_decrypt_and_store_transaction,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_decrypt_transaction,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_encode_extended_full_viewing_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_encode_extended_spending_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_encode_payment_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_encode_payment_address_p,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_encode_transparent_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_encode_transparent_address_p,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_scan_cached_blocks,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_shield_transparent_funds_main_fixed,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_shield_transparent_funds_main_zip317,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_shield_transparent_funds_test_fixed,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_shield_transparent_funds_test_zip317,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_spend_main_fixed,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_spend_main_zip317,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_spend_test_fixed,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_func_spend_test_zip317,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_secpsecretkey_serialize_secret,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_testsupport_get_as_string,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_testsupport_get_as_u32,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_testsupport_get_as_u32_array,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_testsupport_get_as_u64,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_testsupport_get_as_u64_array,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_testsupport_get_as_u8_array,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountbalance_sapling_spendable_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountbalance_total,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountbalance_unshielded,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountbirthday_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountbirthday_recover_until,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountbirthday_sapling_frontier,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountprivkey_derive_external_secret_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountprivkey_derive_internal_secret_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountprivkey_to_account_pubkey,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountprivkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_derive_external_ivk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_derive_internal_ivk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_external_ovk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_internal_ovk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_ovks_for_shielding,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaccountpubkey_serialize,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaddressmetadata_account,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashaddressmetadata_diversifier_index,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashamount_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashanchor_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashbalance_total,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashblockheight_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashblockmeta_block_file_path,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashblockmetadata_block_hash,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashblockmetadata_block_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashblockmetadata_sapling_tree_size,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashcommitmenttree_append,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashcommitmenttreeroot_root_hash,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashcommitmenttreeroot_subtree_end_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdecryptedoutput_account,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdecryptedoutput_index,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdecryptedoutput_memo,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdecryptedoutput_note,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdecryptedoutput_transfer_type,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_change_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_decrypt_diversifier,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_default_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_diversified_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_diversified_change_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_find_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_fvk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_to_ivk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_to_nk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifiablefullviewingkey_to_ovk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifier_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifierindex_increment,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifierindex_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdiversifierindex_to_u32,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdustoutputpolicy_action,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashdustoutputpolicy_dust_threshold,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashexpandedspendingkey_proof_generation_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashexpandedspendingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_default_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_derive_child,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_derive_internal,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_encode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_find_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedfullviewingkey_to_diversifiable_full_viewing_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedprivkey_derive_private_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedprivkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_default_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_derive_child,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_derive_internal,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_encode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextendedspendingkey_to_diversifiable_full_viewing_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashexternalivk_default_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashexternalivk_derive_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashexternalivk_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashexternalovk_as_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashextractednotecommitment_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashfixedfeerule_fixed_fee,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashfsblockdb_find_block,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashfsblockdb_get_max_cached_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashfsblockdb_initialize,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashfsblockdb_write_block_metadata,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashfullviewingkey_ovk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashfullviewingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashfullviewingkey_vk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashincrementalwitness_append,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashincrementalwitness_path,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashinternalivk_default_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashinternalivk_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashinternalovk_as_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashjubjubfr_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashkeyindex_is_valid,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashkeyindex_normalize_index,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashkeyindex_raw_index,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashmemobytes_data,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashnonnegativeamount_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashnullifierderivingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardaction_cmx,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardaction_cv_net,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardaction_encrypted_note,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardaction_nullifier,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardaddress_diversifier,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardaddress_to_raw_address_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_actions,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_anchor,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_decrypt_output_with_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_decrypt_output_with_keys,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_flags,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_recover_output_with_ovk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_recover_outputs_with_ovks,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_value_balance,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardbundle_verify_proof,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorcharddiversifier_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorcharddiversifierindex_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardflags_outputs_enabled,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardflags_spends_enabled,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardflags_to_byte,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_address_at,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_scope_for_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_to_ivk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardfullviewingkey_to_ovk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardincomingviewingkey_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardincomingviewingkey_address_at,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardincomingviewingkey_diversifier_index,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardincomingviewingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardmerklehash_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardmerklepath_root,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardnote_commitment,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardnote_recipient,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardnote_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardnotecommitment_to_extracted_note_commitment,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardnotevalue_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardnullifier_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardoutgoingviewingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardrandomseed_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardspendingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardspendingkey_to_fvk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardtransactionbuilder_add_recipient,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardtransactionbuilder_add_spend,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardtransactionbuilder_build,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashorchardvaluecommitment_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashoutgoingviewingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashpaymentaddress_create_note,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashpaymentaddress_diversifier,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashpaymentaddress_encode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashpaymentaddress_pk_d,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashpaymentaddress_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashproofgenerationkey_to_viewing_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashratio_denominator,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashratio_numerator,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashreceivedsaplingnote_diversifier,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashreceivedsaplingnote_internal_note_id,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashreceivedsaplingnote_note_commitment_tree_position,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashreceivedsaplingnote_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashrecipientaddress_encode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingbundle_shielded_outputs,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingbundle_shielded_spends,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingbundle_value_balance,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingextractednotecommitment_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingivk_to_payment_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingivk_to_repr,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingmerklepath_auth_path,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingmerklepath_position,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingmetadata_output_index,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingmetadata_spend_index,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingnote_cmu,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingnote_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingnotevalue_inner,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingnullifier_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingoutputdescription_cmu,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingoutputdescription_cv,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingpublickey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingspenddescription_anchor,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingspenddescription_cv,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingspenddescription_nullifier,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingspenddescription_rk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsaplingvaluecommitment_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscanrange_block_range,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscanrange_is_empty,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscanrange_len,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscanrange_priority,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscannedblock_block_hash,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscannedblock_block_time,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscannedblock_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscannedblock_metadata,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscannedblock_sapling_commitments,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscannedblock_sapling_nullifier_map,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscannedblock_transactions,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashscript_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsenttransactionoutput_memo,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsenttransactionoutput_output_index,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsenttransactionoutput_recipient,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsenttransactionoutput_sapling_change_to,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashsenttransactionoutput_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransaction_consensus_branch_id,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransaction_expiry_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransaction_lock_time,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransaction_orchard_bundle,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransaction_sapling_bundle,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransaction_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransaction_transparent_bundle,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransaction_txid,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransaction_version,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransactionbuilder_add_sapling_output,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransactionbuilder_add_sapling_spend,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransactionbuilder_add_transparent_input,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransactionbuilder_add_transparent_output,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransactionbuilder_build,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransactionrequest_payments,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransactionrequest_to_uri,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransparentaddress_encode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransparentaddress_is_public_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransparentaddress_is_script,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransparentaddress_script,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransparentaddress_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransparentbundle_is_coinbase,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransparentbundle_vin,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtransparentbundle_vout,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxid_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxid_to_hex_string,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxin_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxout_recipient_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxout_script_pubkey,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxout_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxout_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxversion_has_orchard,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxversion_has_overwinter,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxversion_has_sapling,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxversion_has_sprout,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxversion_header,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxversion_selection,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxversion_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashtxversion_version_group_id,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedaddress_encode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedaddress_orchard,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedaddress_sapling,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedaddress_transparent,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_default_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_encode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_find_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_orchard,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_sapling,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedfullviewingkey_transparent,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedspendingkey_orchard,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedspendingkey_sapling,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedspendingkey_to_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedspendingkey_to_unified_full_viewing_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashunifiedspendingkey_transparent,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashviewingkey_ivk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashviewingkey_to_payment_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_block_fully_scanned,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_block_max_scanned,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_block_metadata,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_chain_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_create_account,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_account_birthday,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_account_for_ufvk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_block_hash,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_current_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_max_height_hash,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_memo,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_min_unspent_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_next_available_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_sapling_nullifiers,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_spendable_sapling_notes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_target_and_anchor_heights,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_transaction,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_transparent_balances,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_transparent_receivers,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_tx_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_unified_full_viewing_keys,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_unspent_transparent_outputs,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_wallet_birthday,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_get_wallet_summary,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_initialize,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_is_valid_account_extfvk,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_put_blocks,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_put_received_transparent_utxo,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_put_sapling_subtree_roots,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_select_spendable_sapling_notes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_store_decrypted_tx,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_store_sent_tx,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_suggest_scan_ranges,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_truncate_to_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletdb_update_chain_tip,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletsummary_account_balances,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletsummary_chain_tip_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletsummary_fully_scanned_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletsummary_is_synced,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwalletsummary_scan_progress,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwallettransparentoutput_height,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwallettransparentoutput_outpoint,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwallettransparentoutput_recipient_address,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwallettransparentoutput_txout,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashwallettransparentoutput_value,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_method_zcashzip317feerule_marginal_fee,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_secpsecretkey_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_testsupport_from_csv_file,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashaccountbalance_zero,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashaccountbirthday_from_treestate,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashaccountprivkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashaccountprivkey_from_extended_privkey,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashaccountprivkey_from_seed,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashaccountpubkey_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashaddressmetadata_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashamount_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashamount_zero,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashanchor_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashbalance_zero,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashblockhash_from_slice,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashblockheight_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashblockmeta_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashblockmetadata_from_parts,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashcommitmenttree_empty,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashcommitmenttreeroot_from_parts,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashdiversifiablefullviewingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashdiversifier_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashdiversifierindex_from_u32,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashdiversifierindex_from_u64,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashdiversifierindex_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashdustoutputpolicy_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashexpandedspendingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashexpandedspendingkey_from_spending_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextendedfullviewingkey_decode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextendedfullviewingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextendedprivkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextendedprivkey_random,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextendedprivkey_random_with_seed_size,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextendedprivkey_with_seed,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextendedspendingkey_decode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextendedspendingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextendedspendingkey_from_path,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextendedspendingkey_master,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashexternalivk_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashextractednotecommitment_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashfixedfeerule_non_standard,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashfixedfeerule_standard,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashfixedsingleoutputchangestrategy_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashfsblockdb_for_path,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashfullviewingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashfullviewingkey_from_expanded_spending_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashincrementalwitness_from_tree,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashinternalivk_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashjubjubfr_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashkeyindex_from_index,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashkeyindex_from_u32,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashkeyindex_hardened_from_normalize_index,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashlocaltxprover_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashlocaltxprover_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashlocaltxprover_with_default_location,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashmainfixedgreedyinputselector_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashmainzip317greedyinputselector_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashmemobytes_empty,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashmemobytes_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashnonnegativeamount_from_nonnegative_i64,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashnonnegativeamount_from_u64,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashnonnegativeamount_zero,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashnoteid_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashnullifierderivingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardaddress_from_raw_address_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorcharddiversifier_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorcharddiversifierindex_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorcharddiversifierindex_from_u32,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorcharddiversifierindex_from_u64,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardflags_from_byte,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardflags_from_parts,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardfullviewingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardincomingviewingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardmerklehash_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardmerklehash_from_cmx,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardmerklepath_from_parts,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardnote_from_parts,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardnotevalue_from_raw,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardnullifier_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardoutgoingviewingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardrandomseed_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardspendingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardspendingkey_from_zip32_seed,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashorchardtransactionbuilder_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashoutpoint_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashoutgoingviewingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashpaymentaddress_decode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashpaymentaddress_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashprovingkey_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashratio_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashrecipientaddress_decode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashrecipientaddress_shielded,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashrecipientaddress_transparent,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashrecipientaddress_unified,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashsaplingextractednotecommitment_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashsaplingmetadata_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashsaplingnode_from_cmu,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashsaplingnote_from_parts,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashsaplingnotevalue_from_raw,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashscanrange_from_parts,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashscannedblock_from_parts,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashscript_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashsenttransactionoutput_from_parts,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtestfixedgreedyinputselector_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtestzip317greedyinputselector_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtransaction_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtransactionbuilder_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtransactionrequest_empty,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtransactionrequest_from_uri,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtransactionrequest_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtransparentaddress_decode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtransparentaddress_from_public_key,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtransparentaddress_from_script,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtreestate_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtreestate_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtxid_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtxout_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtxversion_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashtxversion_suggested_for_branch,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashunifiedaddress_decode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashunifiedaddress_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashunifiedfullviewingkey_decode,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashunifiedfullviewingkey_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashunifiedspendingkey_from_bytes,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashunifiedspendingkey_from_seed,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashverifyingkey_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashwalletdb_for_path,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashwalletsummary_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashwallettransparentoutput_from_parts,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashwallettx_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashzip317feerule_non_standard,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashzip317feerule_standard,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :uniffi_uniffi_zcash_checksum_constructor_zcashzip317singleoutputchangestrategy_new,
                    [RustCallStatus.by_ref],
                    :uint16
    attach_function :ffi_uniffi_zcash_uniffi_contract_version,
                    [RustCallStatus.by_ref],
                    :uint32
  end

  # Public interface members begin here.

  class ZcashBranchId
    SPROUT = 1
    OVERWINTER = 2
    SAPLING = 3
    BLOSSOM = 4
    HEARTWOOD = 5
    CANOPY = 6
    NU5 = 7
  end

  class ZcashChildIndex
    def initialize
      raise 'ZcashChildIndex cannot be instantiated directly'
    end

    # Each enum variant is a nested class of the enum itself.
    class NON_HARDENED
      attr_reader :v

      def initialize(v)
        @v = v
      end

      def to_s
        "ZcashChildIndex::NON_HARDENED(v=#{@v})"
      end

      def ==(other)
        return false unless other.non_hardened?
        return false if @v != other.v

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def non_hardened?
        instance_of? ZcashChildIndex::NON_HARDENED
      end

      def hardened?
        instance_of? ZcashChildIndex::HARDENED
      end
    end

    class HARDENED
      attr_reader :v

      def initialize(v)
        @v = v
      end

      def to_s
        "ZcashChildIndex::HARDENED(v=#{@v})"
      end

      def ==(other)
        return false unless other.hardened?
        return false if @v != other.v

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def non_hardened?
        instance_of? ZcashChildIndex::NON_HARDENED
      end

      def hardened?
        instance_of? ZcashChildIndex::HARDENED
      end
    end
  end

  class ZcashConsensusParameters
    MAIN_NETWORK = 1
    TEST_NETWORK = 2
  end

  class ZcashDustAction
    REJECT = 1
    ALLOW_DUST_CHANGE = 2
    ADD_DUST_TO_FEE = 3
  end

  class ZcashFeeRules
    def initialize
      raise 'ZcashFeeRules cannot be instantiated directly'
    end

    # Each enum variant is a nested class of the enum itself.
    class FIXED_STANDARD
      def initialize; end

      def to_s
        'ZcashFeeRules::FIXED_STANDARD()'
      end

      def ==(other)
        return false unless other.fixed_standard?

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def fixed_standard?
        instance_of? ZcashFeeRules::FIXED_STANDARD
      end

      def fixed_non_standard?
        instance_of? ZcashFeeRules::FIXED_NON_STANDARD
      end

      def zip317_standard?
        instance_of? ZcashFeeRules::ZIP317_STANDARD
      end

      def zip317_non_standard?
        instance_of? ZcashFeeRules::ZIP317_NON_STANDARD
      end
    end

    class FIXED_NON_STANDARD
      attr_reader :amount

      def initialize(amount)
        @amount = amount
      end

      def to_s
        "ZcashFeeRules::FIXED_NON_STANDARD(amount=#{@amount})"
      end

      def ==(other)
        return false unless other.fixed_non_standard?
        return false if @amount != other.amount

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def fixed_standard?
        instance_of? ZcashFeeRules::FIXED_STANDARD
      end

      def fixed_non_standard?
        instance_of? ZcashFeeRules::FIXED_NON_STANDARD
      end

      def zip317_standard?
        instance_of? ZcashFeeRules::ZIP317_STANDARD
      end

      def zip317_non_standard?
        instance_of? ZcashFeeRules::ZIP317_NON_STANDARD
      end
    end

    class ZIP317_STANDARD
      def initialize; end

      def to_s
        'ZcashFeeRules::ZIP317_STANDARD()'
      end

      def ==(other)
        return false unless other.zip317_standard?

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def fixed_standard?
        instance_of? ZcashFeeRules::FIXED_STANDARD
      end

      def fixed_non_standard?
        instance_of? ZcashFeeRules::FIXED_NON_STANDARD
      end

      def zip317_standard?
        instance_of? ZcashFeeRules::ZIP317_STANDARD
      end

      def zip317_non_standard?
        instance_of? ZcashFeeRules::ZIP317_NON_STANDARD
      end
    end

    class ZIP317_NON_STANDARD
      attr_reader :marginal_fee, :grace_actions, :p2pkh_standard_input_size, :p2pkh_standard_output_size

      def initialize(marginal_fee, grace_actions, p2pkh_standard_input_size, p2pkh_standard_output_size)
        @marginal_fee = marginal_fee
        @grace_actions = grace_actions
        @p2pkh_standard_input_size = p2pkh_standard_input_size
        @p2pkh_standard_output_size = p2pkh_standard_output_size
      end

      def to_s
        "ZcashFeeRules::ZIP317_NON_STANDARD(marginal_fee=#{@marginal_fee}, grace_actions=#{@grace_actions}, p2pkh_standard_input_size=#{@p2pkh_standard_input_size}, p2pkh_standard_output_size=#{@p2pkh_standard_output_size})"
      end

      def ==(other)
        return false unless other.zip317_non_standard?
        return false if @marginal_fee != other.marginal_fee
        return false if @grace_actions != other.grace_actions
        return false if @p2pkh_standard_input_size != other.p2pkh_standard_input_size
        return false if @p2pkh_standard_output_size != other.p2pkh_standard_output_size

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def fixed_standard?
        instance_of? ZcashFeeRules::FIXED_STANDARD
      end

      def fixed_non_standard?
        instance_of? ZcashFeeRules::FIXED_NON_STANDARD
      end

      def zip317_standard?
        instance_of? ZcashFeeRules::ZIP317_STANDARD
      end

      def zip317_non_standard?
        instance_of? ZcashFeeRules::ZIP317_NON_STANDARD
      end
    end
  end

  class ZcashKeySeed
    S128 = 1
    S256 = 2
    S512 = 3
  end

  class ZcashKeysEra
    ORCHARD = 1
  end

  class ZcashMemo
    def initialize
      raise 'ZcashMemo cannot be instantiated directly'
    end

    # Each enum variant is a nested class of the enum itself.
    class EMPTY
      def initialize; end

      def to_s
        'ZcashMemo::EMPTY()'
      end

      def ==(other)
        return false unless other.empty?

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def empty?
        instance_of? ZcashMemo::EMPTY
      end

      def text?
        instance_of? ZcashMemo::TEXT
      end

      def future?
        instance_of? ZcashMemo::FUTURE
      end

      def arbitrary?
        instance_of? ZcashMemo::ARBITRARY
      end
    end

    class TEXT
      attr_reader :v

      def initialize(v)
        @v = v
      end

      def to_s
        "ZcashMemo::TEXT(v=#{@v})"
      end

      def ==(other)
        return false unless other.text?
        return false if @v != other.v

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def empty?
        instance_of? ZcashMemo::EMPTY
      end

      def text?
        instance_of? ZcashMemo::TEXT
      end

      def future?
        instance_of? ZcashMemo::FUTURE
      end

      def arbitrary?
        instance_of? ZcashMemo::ARBITRARY
      end
    end

    class FUTURE
      attr_reader :v

      def initialize(v)
        @v = v
      end

      def to_s
        "ZcashMemo::FUTURE(v=#{@v})"
      end

      def ==(other)
        return false unless other.future?
        return false if @v != other.v

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def empty?
        instance_of? ZcashMemo::EMPTY
      end

      def text?
        instance_of? ZcashMemo::TEXT
      end

      def future?
        instance_of? ZcashMemo::FUTURE
      end

      def arbitrary?
        instance_of? ZcashMemo::ARBITRARY
      end
    end

    class ARBITRARY
      attr_reader :v

      def initialize(v)
        @v = v
      end

      def to_s
        "ZcashMemo::ARBITRARY(v=#{@v})"
      end

      def ==(other)
        return false unless other.arbitrary?
        return false if @v != other.v

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def empty?
        instance_of? ZcashMemo::EMPTY
      end

      def text?
        instance_of? ZcashMemo::TEXT
      end

      def future?
        instance_of? ZcashMemo::FUTURE
      end

      def arbitrary?
        instance_of? ZcashMemo::ARBITRARY
      end
    end
  end

  class ZcashNullifierQuery
    UNSPENT = 1
    ALL = 2
  end

  class ZcashOrchardScope
    EXTERNAL = 1
    INTERNAL = 2
  end

  class ZcashOvkPolicy
    def initialize
      raise 'ZcashOvkPolicy cannot be instantiated directly'
    end

    # Each enum variant is a nested class of the enum itself.
    class SENDER
      def initialize; end

      def to_s
        'ZcashOvkPolicy::SENDER()'
      end

      def ==(other)
        return false unless other.sender?

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def sender?
        instance_of? ZcashOvkPolicy::SENDER
      end

      def custom?
        instance_of? ZcashOvkPolicy::CUSTOM
      end

      def discard?
        instance_of? ZcashOvkPolicy::DISCARD
      end
    end

    class CUSTOM
      attr_reader :bytes

      def initialize(bytes)
        @bytes = bytes
      end

      def to_s
        "ZcashOvkPolicy::CUSTOM(bytes=#{@bytes})"
      end

      def ==(other)
        return false unless other.custom?
        return false if @bytes != other.bytes

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def sender?
        instance_of? ZcashOvkPolicy::SENDER
      end

      def custom?
        instance_of? ZcashOvkPolicy::CUSTOM
      end

      def discard?
        instance_of? ZcashOvkPolicy::DISCARD
      end
    end

    class DISCARD
      def initialize; end

      def to_s
        'ZcashOvkPolicy::DISCARD()'
      end

      def ==(other)
        return false unless other.discard?

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def sender?
        instance_of? ZcashOvkPolicy::SENDER
      end

      def custom?
        instance_of? ZcashOvkPolicy::CUSTOM
      end

      def discard?
        instance_of? ZcashOvkPolicy::DISCARD
      end
    end
  end

  class ZcashPoolType
    def initialize
      raise 'ZcashPoolType cannot be instantiated directly'
    end

    # Each enum variant is a nested class of the enum itself.
    class TRANSPARENT
      def initialize; end

      def to_s
        'ZcashPoolType::TRANSPARENT()'
      end

      def ==(other)
        return false unless other.transparent?

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def transparent?
        instance_of? ZcashPoolType::TRANSPARENT
      end

      def shielded?
        instance_of? ZcashPoolType::SHIELDED
      end
    end

    class SHIELDED
      attr_reader :v

      def initialize(v)
        @v = v
      end

      def to_s
        "ZcashPoolType::SHIELDED(v=#{@v})"
      end

      def ==(other)
        return false unless other.shielded?
        return false if @v != other.v

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def transparent?
        instance_of? ZcashPoolType::TRANSPARENT
      end

      def shielded?
        instance_of? ZcashPoolType::SHIELDED
      end
    end
  end

  class ZcashRecipient
    def initialize
      raise 'ZcashRecipient cannot be instantiated directly'
    end

    # Each enum variant is a nested class of the enum itself.
    class TRANSPARENT
      attr_reader :script

      def initialize(script)
        @script = script
      end

      def to_s
        "ZcashRecipient::TRANSPARENT(script=#{@script})"
      end

      def ==(other)
        return false unless other.transparent?
        return false if @script != other.script

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def transparent?
        instance_of? ZcashRecipient::TRANSPARENT
      end

      def sapling?
        instance_of? ZcashRecipient::SAPLING
      end

      def unified?
        instance_of? ZcashRecipient::UNIFIED
      end

      def internal_account?
        instance_of? ZcashRecipient::INTERNAL_ACCOUNT
      end
    end

    class SAPLING
      attr_reader :payment_address_bytes

      def initialize(payment_address_bytes)
        @payment_address_bytes = payment_address_bytes
      end

      def to_s
        "ZcashRecipient::SAPLING(payment_address_bytes=#{@payment_address_bytes})"
      end

      def ==(other)
        return false unless other.sapling?
        return false if @payment_address_bytes != other.payment_address_bytes

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def transparent?
        instance_of? ZcashRecipient::TRANSPARENT
      end

      def sapling?
        instance_of? ZcashRecipient::SAPLING
      end

      def unified?
        instance_of? ZcashRecipient::UNIFIED
      end

      def internal_account?
        instance_of? ZcashRecipient::INTERNAL_ACCOUNT
      end
    end

    class UNIFIED
      attr_reader :uae, :params, :zpt

      def initialize(uae, params, zpt)
        @uae = uae
        @params = params
        @zpt = zpt
      end

      def to_s
        "ZcashRecipient::UNIFIED(uae=#{@uae}, params=#{@params}, zpt=#{@zpt})"
      end

      def ==(other)
        return false unless other.unified?
        return false if @uae != other.uae
        return false if @params != other.params
        return false if @zpt != other.zpt

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def transparent?
        instance_of? ZcashRecipient::TRANSPARENT
      end

      def sapling?
        instance_of? ZcashRecipient::SAPLING
      end

      def unified?
        instance_of? ZcashRecipient::UNIFIED
      end

      def internal_account?
        instance_of? ZcashRecipient::INTERNAL_ACCOUNT
      end
    end

    class INTERNAL_ACCOUNT
      attr_reader :aid, :zpt

      def initialize(aid, zpt)
        @aid = aid
        @zpt = zpt
      end

      def to_s
        "ZcashRecipient::INTERNAL_ACCOUNT(aid=#{@aid}, zpt=#{@zpt})"
      end

      def ==(other)
        return false unless other.internal_account?
        return false if @aid != other.aid
        return false if @zpt != other.zpt

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def transparent?
        instance_of? ZcashRecipient::TRANSPARENT
      end

      def sapling?
        instance_of? ZcashRecipient::SAPLING
      end

      def unified?
        instance_of? ZcashRecipient::UNIFIED
      end

      def internal_account?
        instance_of? ZcashRecipient::INTERNAL_ACCOUNT
      end
    end
  end

  class ZcashRseed
    def initialize
      raise 'ZcashRseed cannot be instantiated directly'
    end

    # Each enum variant is a nested class of the enum itself.
    class BEFORE_ZIP212
      attr_reader :fr_data

      def initialize(fr_data)
        @fr_data = fr_data
      end

      def to_s
        "ZcashRseed::BEFORE_ZIP212(fr_data=#{@fr_data})"
      end

      def ==(other)
        return false unless other.before_zip212?
        return false if @fr_data != other.fr_data

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def before_zip212?
        instance_of? ZcashRseed::BEFORE_ZIP212
      end

      def after_zip212?
        instance_of? ZcashRseed::AFTER_ZIP212
      end
    end

    class AFTER_ZIP212
      attr_reader :data

      def initialize(data)
        @data = data
      end

      def to_s
        "ZcashRseed::AFTER_ZIP212(data=#{@data})"
      end

      def ==(other)
        return false unless other.after_zip212?
        return false if @data != other.data

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def before_zip212?
        instance_of? ZcashRseed::BEFORE_ZIP212
      end

      def after_zip212?
        instance_of? ZcashRseed::AFTER_ZIP212
      end
    end
  end

  class ZcashScanPriority
    IGNORED = 1
    SCANNED = 2
    HISTORIC = 3
    OPEN_ADJACENT = 4
    FOUND_NOTE = 5
    CHAIN_TIP = 6
    VERIFY = 7
  end

  class ZcashScope
    EXTERNAL = 1
    INTERNAL = 2
  end

  class ZcashShieldedProtocol
    SAPLING = 1
  end

  class ZcashTransferType
    INCOMING = 1
    WALLET_INTERNAL = 2
    OUTGOING = 3
  end

  class ZcashTxVersionSelection
    def initialize
      raise 'ZcashTxVersionSelection cannot be instantiated directly'
    end

    # Each enum variant is a nested class of the enum itself.
    class SPROUT
      attr_reader :v

      def initialize(v)
        @v = v
      end

      def to_s
        "ZcashTxVersionSelection::SPROUT(v=#{@v})"
      end

      def ==(other)
        return false unless other.sprout?
        return false if @v != other.v

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def sprout?
        instance_of? ZcashTxVersionSelection::SPROUT
      end

      def overwinter?
        instance_of? ZcashTxVersionSelection::OVERWINTER
      end

      def sapling?
        instance_of? ZcashTxVersionSelection::SAPLING
      end

      def zip225?
        instance_of? ZcashTxVersionSelection::ZIP225
      end
    end

    class OVERWINTER
      def initialize; end

      def to_s
        'ZcashTxVersionSelection::OVERWINTER()'
      end

      def ==(other)
        return false unless other.overwinter?

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def sprout?
        instance_of? ZcashTxVersionSelection::SPROUT
      end

      def overwinter?
        instance_of? ZcashTxVersionSelection::OVERWINTER
      end

      def sapling?
        instance_of? ZcashTxVersionSelection::SAPLING
      end

      def zip225?
        instance_of? ZcashTxVersionSelection::ZIP225
      end
    end

    class SAPLING
      def initialize; end

      def to_s
        'ZcashTxVersionSelection::SAPLING()'
      end

      def ==(other)
        return false unless other.sapling?

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def sprout?
        instance_of? ZcashTxVersionSelection::SPROUT
      end

      def overwinter?
        instance_of? ZcashTxVersionSelection::OVERWINTER
      end

      def sapling?
        instance_of? ZcashTxVersionSelection::SAPLING
      end

      def zip225?
        instance_of? ZcashTxVersionSelection::ZIP225
      end
    end

    class ZIP225
      def initialize; end

      def to_s
        'ZcashTxVersionSelection::ZIP225()'
      end

      def ==(other)
        return false unless other.zip225?

        true
      end

      # For each variant, we have an `NAME?` method for easily checking
      # whether an instance is that variant.

      def sprout?
        instance_of? ZcashTxVersionSelection::SPROUT
      end

      def overwinter?
        instance_of? ZcashTxVersionSelection::OVERWINTER
      end

      def sapling?
        instance_of? ZcashTxVersionSelection::SAPLING
      end

      def zip225?
        instance_of? ZcashTxVersionSelection::ZIP225
      end
    end
  end

  # Record type TripleSaplingNullifierMap
  class TripleSaplingNullifierMap
    attr_reader :txid, :tx_idx, :nullifiers

    def initialize(txid, tx_idx, nullifiers)
      @txid = txid
      @tx_idx = tx_idx
      @nullifiers = nullifiers
    end

    def ==(other)
      return false if @txid != other.txid
      return false if @tx_idx != other.tx_idx
      return false if @nullifiers != other.nullifiers

      true
    end
  end

  # Record type TupleAccountIdAndSaplingNote
  class TupleAccountIdAndSaplingNote
    attr_reader :account_id, :sapling_note

    def initialize(account_id, sapling_note)
      @account_id = account_id
      @sapling_note = sapling_note
    end

    def ==(other)
      return false if @account_id != other.account_id
      return false if @sapling_note != other.sapling_note

      true
    end
  end

  # Record type TupleAccountIdAndSaplingNullifier
  class TupleAccountIdAndSaplingNullifier
    attr_reader :account_id, :sapling_nullifier

    def initialize(account_id, sapling_nullifier)
      @account_id = account_id
      @sapling_nullifier = sapling_nullifier
    end

    def ==(other)
      return false if @account_id != other.account_id
      return false if @sapling_nullifier != other.sapling_nullifier

      true
    end
  end

  # Record type TupleAccountIdAndUnifiedSpendingKey
  class TupleAccountIdAndUnifiedSpendingKey
    attr_reader :account_id, :unified_spending_key

    def initialize(account_id, unified_spending_key)
      @account_id = account_id
      @unified_spending_key = unified_spending_key
    end

    def ==(other)
      return false if @account_id != other.account_id
      return false if @unified_spending_key != other.unified_spending_key

      true
    end
  end

  # Record type TupleBlockHeightAndHash
  class TupleBlockHeightAndHash
    attr_reader :block_height, :block_hash

    def initialize(block_height, block_hash)
      @block_height = block_height
      @block_hash = block_hash
    end

    def ==(other)
      return false if @block_height != other.block_height
      return false if @block_hash != other.block_hash

      true
    end
  end

  # Record type TupleSaplingCommitments
  class TupleSaplingCommitments
    attr_reader :node, :retention

    def initialize(node, retention)
      @node = node
      @retention = retention
    end

    def ==(other)
      return false if @node != other.node
      return false if @retention != other.retention

      true
    end
  end

  # Record type TupleTargetAndAnchorHeight
  class TupleTargetAndAnchorHeight
    attr_reader :target_height, :anchor_height

    def initialize(target_height, anchor_height)
      @target_height = target_height
      @anchor_height = anchor_height
    end

    def ==(other)
      return false if @target_height != other.target_height
      return false if @anchor_height != other.anchor_height

      true
    end
  end

  # Record type ZcashAccountId
  class ZcashAccountId
    attr_reader :id

    def initialize(id)
      @id = id
    end

    def ==(other)
      return false if @id != other.id

      true
    end
  end

  # Record type ZcashAuthPath
  class ZcashAuthPath
    attr_reader :node

    def initialize(node)
      @node = node
    end

    def ==(other)
      return false if @node != other.node

      true
    end
  end

  # Record type ZcashDiversifierIndexAndPaymentAddress
  class ZcashDiversifierIndexAndPaymentAddress
    attr_reader :diversifier_index, :address

    def initialize(diversifier_index, address)
      @diversifier_index = diversifier_index
      @address = address
    end

    def ==(other)
      return false if @diversifier_index != other.diversifier_index
      return false if @address != other.address

      true
    end
  end

  # Record type ZcashDiversifierIndexAndScope
  class ZcashDiversifierIndexAndScope
    attr_reader :diversifier_index, :scope

    def initialize(diversifier_index, scope)
      @diversifier_index = diversifier_index
      @scope = scope
    end

    def ==(other)
      return false if @diversifier_index != other.diversifier_index
      return false if @scope != other.scope

      true
    end
  end

  # Record type ZcashInternalOvkExternalOvk
  class ZcashInternalOvkExternalOvk
    attr_reader :internal_ovk, :external_ovk

    def initialize(internal_ovk, external_ovk)
      @internal_ovk = internal_ovk
      @external_ovk = external_ovk
    end

    def ==(other)
      return false if @internal_ovk != other.internal_ovk
      return false if @external_ovk != other.external_ovk

      true
    end
  end

  # Record type ZcashOrchardDecryptOutput
  class ZcashOrchardDecryptOutput
    attr_reader :note, :address, :data

    def initialize(note, address, data)
      @note = note
      @address = address
      @data = data
    end

    def ==(other)
      return false if @note != other.note
      return false if @address != other.address
      return false if @data != other.data

      true
    end
  end

  # Record type ZcashOrchardDecryptOutputForIncomingKeys
  class ZcashOrchardDecryptOutputForIncomingKeys
    attr_reader :idx, :key, :note, :address, :data

    def initialize(idx, key, note, address, data)
      @idx = idx
      @key = key
      @note = note
      @address = address
      @data = data
    end

    def ==(other)
      return false if @idx != other.idx
      return false if @key != other.key
      return false if @note != other.note
      return false if @address != other.address
      return false if @data != other.data

      true
    end
  end

  # Record type ZcashOrchardDecryptOutputForOutgoingKeys
  class ZcashOrchardDecryptOutputForOutgoingKeys
    attr_reader :idx, :key, :note, :address, :data

    def initialize(idx, key, note, address, data)
      @idx = idx
      @key = key
      @note = note
      @address = address
      @data = data
    end

    def ==(other)
      return false if @idx != other.idx
      return false if @key != other.key
      return false if @note != other.note
      return false if @address != other.address
      return false if @data != other.data

      true
    end
  end

  # Record type ZcashOrchardTransmittedNoteCiphertext
  class ZcashOrchardTransmittedNoteCiphertext
    attr_reader :epk_bytes, :enc_ciphertext, :out_ciphertext

    def initialize(epk_bytes, enc_ciphertext, out_ciphertext)
      @epk_bytes = epk_bytes
      @enc_ciphertext = enc_ciphertext
      @out_ciphertext = out_ciphertext
    end

    def ==(other)
      return false if @epk_bytes != other.epk_bytes
      return false if @enc_ciphertext != other.enc_ciphertext
      return false if @out_ciphertext != other.out_ciphertext

      true
    end
  end

  # Record type ZcashPayment
  class ZcashPayment
    attr_reader :recipient_address, :amount, :memo, :label, :message, :other_params

    def initialize(recipient_address, amount, memo, label, message, other_params)
      @recipient_address = recipient_address
      @amount = amount
      @memo = memo
      @label = label
      @message = message
      @other_params = other_params
    end

    def ==(other)
      return false if @recipient_address != other.recipient_address
      return false if @amount != other.amount
      return false if @memo != other.memo
      return false if @label != other.label
      return false if @message != other.message
      return false if @other_params != other.other_params

      true
    end
  end

  # Record type ZcashPaymentParam
  class ZcashPaymentParam
    attr_reader :key, :value

    def initialize(key, value)
      @key = key
      @value = value
    end

    def ==(other)
      return false if @key != other.key
      return false if @value != other.value

      true
    end
  end

  # Record type ZcashSentTransaction
  class ZcashSentTransaction
    attr_reader :tx, :created, :account, :outputs, :fee_amount, :utxos_spent

    def initialize(tx, created, account, outputs, fee_amount, utxos_spent)
      @tx = tx
      @created = created
      @account = account
      @outputs = outputs
      @fee_amount = fee_amount
      @utxos_spent = utxos_spent
    end

    def ==(other)
      return false if @tx != other.tx
      return false if @created != other.created
      return false if @account != other.account
      return false if @outputs != other.outputs
      return false if @fee_amount != other.fee_amount
      return false if @utxos_spent != other.utxos_spent

      true
    end
  end

  # Record type ZcashTransactionAndSaplingMetadata
  class ZcashTransactionAndSaplingMetadata
    attr_reader :transaction, :sapling_metadata

    def initialize(transaction, sapling_metadata)
      @transaction = transaction
      @sapling_metadata = sapling_metadata
    end

    def ==(other)
      return false if @transaction != other.transaction
      return false if @sapling_metadata != other.sapling_metadata

      true
    end
  end

  # Record type ZcashTransparentAddressAndIndex
  class ZcashTransparentAddressAndIndex
    attr_reader :transparent_address, :index

    def initialize(transparent_address, index)
      @transparent_address = transparent_address
      @index = index
    end

    def ==(other)
      return false if @transparent_address != other.transparent_address
      return false if @index != other.index

      true
    end
  end

  # Record type ZcashUnifiedAddressAndDiversifierIndex
  class ZcashUnifiedAddressAndDiversifierIndex
    attr_reader :address, :diversifier_index

    def initialize(address, diversifier_index)
      @address = address
      @diversifier_index = diversifier_index
    end

    def ==(other)
      return false if @address != other.address
      return false if @diversifier_index != other.diversifier_index

      true
    end
  end

  def self.decode_extended_full_viewing_key(hrp, s)
    hrp = Zcash.uniffi_utf8(hrp)
    s = Zcash.uniffi_utf8(s)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_decode_extended_full_viewing_key,
                                        RustBuffer.allocFromString(hrp), RustBuffer.allocFromString(s))
    ZcashExtendedFullViewingKey._uniffi_allocate(result)
  end

  def self.decode_extended_spending_key(hrp, s)
    hrp = Zcash.uniffi_utf8(hrp)
    s = Zcash.uniffi_utf8(s)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_decode_extended_spending_key,
                                        RustBuffer.allocFromString(hrp), RustBuffer.allocFromString(s))
    ZcashExtendedSpendingKey._uniffi_allocate(result)
  end

  def self.decode_payment_address(hrp, s)
    hrp = Zcash.uniffi_utf8(hrp)
    s = Zcash.uniffi_utf8(s)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_decode_payment_address,
                                        RustBuffer.allocFromString(hrp), RustBuffer.allocFromString(s))
    ZcashPaymentAddress._uniffi_allocate(result)
  end

  def self.decode_transparent_address(pubkey_version, script_version, s)
    pubkey_version = pubkey_version.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
    script_version = script_version.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
    s = Zcash.uniffi_utf8(s)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_decode_transparent_address,
                                        RustBuffer.alloc_from_Sequenceu8(pubkey_version), RustBuffer.alloc_from_Sequenceu8(script_version), RustBuffer.allocFromString(s))
    ZcashTransparentAddress._uniffi_allocate(result)
  end

  def self.decrypt_and_store_transaction(params, z_db_data, tx)
    params = params
    z_db_data = z_db_data
    tx = tx
    Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_decrypt_and_store_transaction,
                               RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashWalletDb._uniffi_lower z_db_data), (ZcashTransaction._uniffi_lower tx))
  end

  def self.decrypt_transaction(params, height, tx, ufvks)
    params = params
    height = height
    tx = tx
    ufvks = ufvks.each.with_object({}) { |(k, v), res| res[Zcash.uniffi_utf8(k)] = v }
    result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_func_decrypt_transaction,
                             RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashBlockHeight._uniffi_lower height), (ZcashTransaction._uniffi_lower tx), RustBuffer.alloc_from_MapTypeZcashAccountIdTypeZcashUnifiedFullViewingKey(ufvks))
    result.consumeIntoSequenceTypeZcashDecryptedOutput
  end

  def self.encode_extended_full_viewing_key(hrp, extfvk)
    hrp = Zcash.uniffi_utf8(hrp)
    extfvk = extfvk
    result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_func_encode_extended_full_viewing_key,
                             RustBuffer.allocFromString(hrp), (ZcashExtendedFullViewingKey._uniffi_lower extfvk))
    result.consumeIntoString
  end

  def self.encode_extended_spending_key(hrp, extsk)
    hrp = Zcash.uniffi_utf8(hrp)
    extsk = extsk
    result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_func_encode_extended_spending_key, RustBuffer.allocFromString(hrp),
                             (ZcashExtendedSpendingKey._uniffi_lower extsk))
    result.consumeIntoString
  end

  def self.encode_payment_address(hrp, addr)
    hrp = Zcash.uniffi_utf8(hrp)
    addr = addr
    result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_func_encode_payment_address, RustBuffer.allocFromString(hrp),
                             (ZcashPaymentAddress._uniffi_lower addr))
    result.consumeIntoString
  end

  def self.encode_payment_address_p(params, addr)
    params = params
    addr = addr
    result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_func_encode_payment_address_p,
                             RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashPaymentAddress._uniffi_lower addr))
    result.consumeIntoString
  end

  def self.encode_transparent_address(pubkey_version, script_version, addr)
    pubkey_version = pubkey_version.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
    script_version = script_version.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
    addr = addr
    result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_func_encode_transparent_address,
                             RustBuffer.alloc_from_Sequenceu8(pubkey_version), RustBuffer.alloc_from_Sequenceu8(script_version), (ZcashTransparentAddress._uniffi_lower addr))
    result.consumeIntoString
  end

  def self.encode_transparent_address_p(params, addr)
    params = params
    addr = addr
    result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_func_encode_transparent_address_p,
                             RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashTransparentAddress._uniffi_lower addr))
    result.consumeIntoString
  end

  def self.scan_cached_blocks(params, fsblockdb_root, db_data_path, height, limit)
    params = params
    fsblockdb_root = Zcash.uniffi_utf8(fsblockdb_root)
    db_data_path = Zcash.uniffi_utf8(db_data_path)
    height = height
    limit = Zcash.uniffi_in_range(limit, 'u32', 0, 2**32)
    Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_scan_cached_blocks,
                               RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.allocFromString(fsblockdb_root), RustBuffer.allocFromString(db_data_path), (ZcashBlockHeight._uniffi_lower height), limit)
  end

  def self.shield_transparent_funds_main_fixed(z_db_data, params, prover, input_selector, shielding_threshold, usk, from_addrs, memo, min_confirmations)
    z_db_data = z_db_data
    params = params
    prover = prover
    input_selector = input_selector
    shielding_threshold = Zcash.uniffi_in_range(shielding_threshold, 'u64', 0, 2**64)
    usk = usk
    from_addrs = from_addrs
    memo = memo
    min_confirmations = Zcash.uniffi_in_range(min_confirmations, 'u32', 0, 2**32)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_shield_transparent_funds_main_fixed,
                                        (ZcashWalletDb._uniffi_lower z_db_data), RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashLocalTxProver._uniffi_lower prover), (ZcashMainFixedGreedyInputSelector._uniffi_lower input_selector), shielding_threshold, (ZcashUnifiedSpendingKey._uniffi_lower usk), RustBuffer.alloc_from_SequenceTypeZcashTransparentAddress(from_addrs), (ZcashMemoBytes._uniffi_lower memo), min_confirmations)
    ZcashTxId._uniffi_allocate(result)
  end

  def self.shield_transparent_funds_main_zip317(z_db_data, params, prover, input_selector, shielding_threshold, usk, from_addrs, memo, min_confirmations)
    z_db_data = z_db_data
    params = params
    prover = prover
    input_selector = input_selector
    shielding_threshold = Zcash.uniffi_in_range(shielding_threshold, 'u64', 0, 2**64)
    usk = usk
    from_addrs = from_addrs
    memo = memo
    min_confirmations = Zcash.uniffi_in_range(min_confirmations, 'u32', 0, 2**32)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_shield_transparent_funds_main_zip317,
                                        (ZcashWalletDb._uniffi_lower z_db_data), RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashLocalTxProver._uniffi_lower prover), (ZcashMainZip317GreedyInputSelector._uniffi_lower input_selector), shielding_threshold, (ZcashUnifiedSpendingKey._uniffi_lower usk), RustBuffer.alloc_from_SequenceTypeZcashTransparentAddress(from_addrs), (ZcashMemoBytes._uniffi_lower memo), min_confirmations)
    ZcashTxId._uniffi_allocate(result)
  end

  def self.shield_transparent_funds_test_fixed(z_db_data, params, prover, input_selector, shielding_threshold, usk, from_addrs, memo, min_confirmations)
    z_db_data = z_db_data
    params = params
    prover = prover
    input_selector = input_selector
    shielding_threshold = Zcash.uniffi_in_range(shielding_threshold, 'u64', 0, 2**64)
    usk = usk
    from_addrs = from_addrs
    memo = memo
    min_confirmations = Zcash.uniffi_in_range(min_confirmations, 'u32', 0, 2**32)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_shield_transparent_funds_test_fixed,
                                        (ZcashWalletDb._uniffi_lower z_db_data), RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashLocalTxProver._uniffi_lower prover), (ZcashTestFixedGreedyInputSelector._uniffi_lower input_selector), shielding_threshold, (ZcashUnifiedSpendingKey._uniffi_lower usk), RustBuffer.alloc_from_SequenceTypeZcashTransparentAddress(from_addrs), (ZcashMemoBytes._uniffi_lower memo), min_confirmations)
    ZcashTxId._uniffi_allocate(result)
  end

  def self.shield_transparent_funds_test_zip317(z_db_data, params, prover, input_selector, shielding_threshold, usk, from_addrs, memo, min_confirmations)
    z_db_data = z_db_data
    params = params
    prover = prover
    input_selector = input_selector
    shielding_threshold = Zcash.uniffi_in_range(shielding_threshold, 'u64', 0, 2**64)
    usk = usk
    from_addrs = from_addrs
    memo = memo
    min_confirmations = Zcash.uniffi_in_range(min_confirmations, 'u32', 0, 2**32)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_shield_transparent_funds_test_zip317,
                                        (ZcashWalletDb._uniffi_lower z_db_data), RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashLocalTxProver._uniffi_lower prover), (ZcashTestZip317GreedyInputSelector._uniffi_lower input_selector), shielding_threshold, (ZcashUnifiedSpendingKey._uniffi_lower usk), RustBuffer.alloc_from_SequenceTypeZcashTransparentAddress(from_addrs), (ZcashMemoBytes._uniffi_lower memo), min_confirmations)
    ZcashTxId._uniffi_allocate(result)
  end

  def self.spend_main_fixed(z_db_data, params, prover, input_selector, usk, request, ovk_policy, min_confirmations)
    z_db_data = z_db_data
    params = params
    prover = prover
    input_selector = input_selector
    usk = usk
    request = request
    ovk_policy = ovk_policy
    min_confirmations = Zcash.uniffi_in_range(min_confirmations, 'u32', 0, 2**32)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_spend_main_fixed,
                                        (ZcashWalletDb._uniffi_lower z_db_data), RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashLocalTxProver._uniffi_lower prover), (ZcashMainFixedGreedyInputSelector._uniffi_lower input_selector), (ZcashUnifiedSpendingKey._uniffi_lower usk), (ZcashTransactionRequest._uniffi_lower request), RustBuffer.alloc_from_TypeZcashOvkPolicy(ovk_policy), min_confirmations)
    ZcashTxId._uniffi_allocate(result)
  end

  def self.spend_main_zip317(z_db_data, params, prover, input_selector, usk, request, ovk_policy, min_confirmations)
    z_db_data = z_db_data
    params = params
    prover = prover
    input_selector = input_selector
    usk = usk
    request = request
    ovk_policy = ovk_policy
    min_confirmations = Zcash.uniffi_in_range(min_confirmations, 'u32', 0, 2**32)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_spend_main_zip317,
                                        (ZcashWalletDb._uniffi_lower z_db_data), RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashLocalTxProver._uniffi_lower prover), (ZcashMainZip317GreedyInputSelector._uniffi_lower input_selector), (ZcashUnifiedSpendingKey._uniffi_lower usk), (ZcashTransactionRequest._uniffi_lower request), RustBuffer.alloc_from_TypeZcashOvkPolicy(ovk_policy), min_confirmations)
    ZcashTxId._uniffi_allocate(result)
  end

  def self.spend_test_fixed(z_db_data, params, prover, input_selector, usk, request, ovk_policy, min_confirmations)
    z_db_data = z_db_data
    params = params
    prover = prover
    input_selector = input_selector
    usk = usk
    request = request
    ovk_policy = ovk_policy
    min_confirmations = Zcash.uniffi_in_range(min_confirmations, 'u32', 0, 2**32)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_spend_test_fixed,
                                        (ZcashWalletDb._uniffi_lower z_db_data), RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashLocalTxProver._uniffi_lower prover), (ZcashTestFixedGreedyInputSelector._uniffi_lower input_selector), (ZcashUnifiedSpendingKey._uniffi_lower usk), (ZcashTransactionRequest._uniffi_lower request), RustBuffer.alloc_from_TypeZcashOvkPolicy(ovk_policy), min_confirmations)
    ZcashTxId._uniffi_allocate(result)
  end

  def self.spend_test_zip317(z_db_data, params, prover, input_selector, usk, request, ovk_policy, min_confirmations)
    z_db_data = z_db_data
    params = params
    prover = prover
    input_selector = input_selector
    usk = usk
    request = request
    ovk_policy = ovk_policy
    min_confirmations = Zcash.uniffi_in_range(min_confirmations, 'u32', 0, 2**32)
    result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_func_spend_test_zip317,
                                        (ZcashWalletDb._uniffi_lower z_db_data), RustBuffer.alloc_from_TypeZcashConsensusParameters(params), (ZcashLocalTxProver._uniffi_lower prover), (ZcashTestZip317GreedyInputSelector._uniffi_lower input_selector), (ZcashUnifiedSpendingKey._uniffi_lower usk), (ZcashTransactionRequest._uniffi_lower request), RustBuffer.alloc_from_TypeZcashOvkPolicy(ovk_policy), min_confirmations)
    ZcashTxId._uniffi_allocate(result)
  end

  class MerkleTreeFrontier
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_merkletreefrontier,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a MerkleTreeFrontier instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end
  end

  class MerkleTreePosition
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_merkletreeposition,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a MerkleTreePosition instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end
  end

  class MerkleTreeRetention
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_merkletreeretention,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a MerkleTreeRetention instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end
  end

  class SecpSecretKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_secpsecretkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a SecpSecretKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      pointer = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_constructor_secpsecretkey_new,
                                           RustBuffer.alloc_from_Sequenceu8(data))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def serialize_secret
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_secpsecretkey_serialize_secret, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class TestSupport
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_testsupport,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a TestSupport instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_csv_file
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_testsupport_from_csv_file))
    end

    def get_as_string(key)
      key = Zcash.uniffi_utf8(key)
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_testsupport_get_as_string, @pointer,
                               RustBuffer.allocFromString(key))
      result.consumeIntoString
    end

    def get_as_u32(key)
      key = Zcash.uniffi_utf8(key)
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_testsupport_get_as_u32, @pointer,
                               RustBuffer.allocFromString(key))
      result.to_i
    end

    def get_as_u32_array(key)
      key = Zcash.uniffi_utf8(key)
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_testsupport_get_as_u32_array, @pointer,
                               RustBuffer.allocFromString(key))
      result.consumeIntoSequenceu32
    end

    def get_as_u64(key)
      key = Zcash.uniffi_utf8(key)
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_testsupport_get_as_u64, @pointer,
                               RustBuffer.allocFromString(key))
      result.to_i
    end

    def get_as_u64_array(key)
      key = Zcash.uniffi_utf8(key)
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_testsupport_get_as_u64_array, @pointer,
                               RustBuffer.allocFromString(key))
      result.consumeIntoSequenceu64
    end

    def get_as_u8_array(key)
      key = Zcash.uniffi_utf8(key)
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_testsupport_get_as_u8_array, @pointer,
                               RustBuffer.allocFromString(key))
      result.consumeIntoSequenceu8
    end
  end

  class TimeOffsetDateTime
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_timeoffsetdatetime,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a TimeOffsetDateTime instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end
  end

  class ZcashAccountBalance
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashaccountbalance,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashAccountBalance instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.zero
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashaccountbalance_zero))
    end

    def sapling_spendable_value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountbalance_sapling_spendable_value, @pointer)
      ZcashNonNegativeAmount._uniffi_allocate(result)
    end

    def total
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountbalance_total, @pointer)
      ZcashNonNegativeAmount._uniffi_allocate(result)
    end

    def unshielded
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountbalance_unshielded, @pointer)
      ZcashNonNegativeAmount._uniffi_allocate(result)
    end
  end

  class ZcashAccountBirthday
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashaccountbirthday,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashAccountBirthday instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_treestate(treestate, recover_until)
      treestate = treestate
      recover_until = (recover_until || nil)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashaccountbirthday_from_treestate, (ZcashTreeState._uniffi_lower treestate), RustBuffer.alloc_from_OptionalTypeZcashBlockHeight(recover_until)))
    end

    def height
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountbirthday_height, @pointer)
      ZcashBlockHeight._uniffi_allocate(result)
    end

    def recover_until
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountbirthday_recover_until, @pointer)
      result.consumeIntoOptionalTypeZcashBlockHeight
    end

    def sapling_frontier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountbirthday_sapling_frontier, @pointer)
      MerkleTreeFrontier._uniffi_allocate(result)
    end
  end

  class ZcashAccountPrivKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashaccountprivkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashAccountPrivKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashaccountprivkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def self.from_extended_privkey(key)
      key = key
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(
                         :uniffi_uniffi_zcash_fn_constructor_zcashaccountprivkey_from_extended_privkey, (ZcashExtendedPrivKey._uniffi_lower key)
                       ))
    end

    def self.from_seed(params, seed, account_id)
      params = params
      seed = seed.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      account_id = account_id
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashaccountprivkey_from_seed, RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.alloc_from_Sequenceu8(seed), RustBuffer.alloc_from_TypeZcashAccountId(account_id)))
    end

    def derive_external_secret_key(child_index)
      child_index = Zcash.uniffi_in_range(child_index, 'u32', 0, 2**32)
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_derive_external_secret_key, @pointer, child_index)
      SecpSecretKey._uniffi_allocate(result)
    end

    def derive_internal_secret_key(child_index)
      child_index = Zcash.uniffi_in_range(child_index, 'u32', 0, 2**32)
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_derive_internal_secret_key, @pointer, child_index)
      SecpSecretKey._uniffi_allocate(result)
    end

    def to_account_pubkey
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_to_account_pubkey, @pointer)
      ZcashAccountPubKey._uniffi_allocate(result)
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountprivkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashAccountPubKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashaccountpubkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashAccountPubKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      pointer = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_constructor_zcashaccountpubkey_new,
                                           RustBuffer.alloc_from_Sequenceu8(data))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def derive_external_ivk
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_derive_external_ivk, @pointer)
      ZcashExternalIvk._uniffi_allocate(result)
    end

    def derive_internal_ivk
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_derive_internal_ivk, @pointer)
      ZcashInternalIvk._uniffi_allocate(result)
    end

    def external_ovk
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_external_ovk, @pointer)
      ZcashExternalOvk._uniffi_allocate(result)
    end

    def internal_ovk
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_internal_ovk, @pointer)
      ZcashInternalOvk._uniffi_allocate(result)
    end

    def ovks_for_shielding
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_ovks_for_shielding, @pointer)
      result.consumeIntoTypeZcashInternalOvkExternalOvk
    end

    def serialize
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaccountpubkey_serialize, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashAddressMetadata
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashaddressmetadata,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashAddressMetadata instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(account, diversifier_index)
      account = account
      diversifier_index = diversifier_index
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashaddressmetadata_new,
                                RustBuffer.alloc_from_TypeZcashAccountId(account), (ZcashDiversifierIndex._uniffi_lower diversifier_index))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def account
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaddressmetadata_account, @pointer)
      result.consumeIntoTypeZcashAccountId
    end

    def diversifier_index
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashaddressmetadata_diversifier_index, @pointer)
      ZcashDiversifierIndex._uniffi_allocate(result)
    end
  end

  class ZcashAmount
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashamount,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashAmount instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(amount)
      amount = Zcash.uniffi_in_range(amount, 'i64', -2**63, 2**63)
      pointer = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_constructor_zcashamount_new, amount)
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def self.zero
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashamount_zero))
    end

    def value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashamount_value, @pointer)
      result.to_i
    end
  end

  class ZcashAnchor
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashanchor,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashAnchor instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashanchor_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashanchor_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashBalance
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashbalance,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashBalance instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.zero
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashbalance_zero))
    end

    def total
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashbalance_total, @pointer)
      ZcashNonNegativeAmount._uniffi_allocate(result)
    end
  end

  class ZcashBlockHash
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashblockhash,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashBlockHash instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_slice(from_bytes)
      from_bytes = from_bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashblockhash_from_slice,
                                       RustBuffer.alloc_from_Sequenceu8(from_bytes)))
    end
  end

  class ZcashBlockHeight
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashblockheight,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashBlockHeight instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(v)
      v = Zcash.uniffi_in_range(v, 'u32', 0, 2**32)
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashblockheight_new, v)
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashblockheight_value, @pointer)
      result.to_i
    end
  end

  class ZcashBlockMeta
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashblockmeta,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashBlockMeta instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(height, block_hash, block_time, sapling_outputs_count, orchard_actions_count)
      height = height
      block_hash = block_hash
      block_time = Zcash.uniffi_in_range(block_time, 'u32', 0, 2**32)
      sapling_outputs_count = Zcash.uniffi_in_range(sapling_outputs_count, 'u32', 0, 2**32)
      orchard_actions_count = Zcash.uniffi_in_range(orchard_actions_count, 'u32', 0, 2**32)
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashblockmeta_new,
                                (ZcashBlockHeight._uniffi_lower height), (ZcashBlockHash._uniffi_lower block_hash), block_time, sapling_outputs_count, orchard_actions_count)
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def block_file_path(blocks_dir)
      blocks_dir = Zcash.uniffi_utf8(blocks_dir)
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashblockmeta_block_file_path, @pointer,
                               RustBuffer.allocFromString(blocks_dir))
      result.consumeIntoString
    end
  end

  class ZcashBlockMetadata
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashblockmetadata,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashBlockMetadata instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_parts(block_height, block_hash, sapling_tree_size)
      block_height = block_height
      block_hash = block_hash
      sapling_tree_size = Zcash.uniffi_in_range(sapling_tree_size, 'u32', 0, 2**32)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashblockmetadata_from_parts,
                                       (ZcashBlockHeight._uniffi_lower block_height), (ZcashBlockHash._uniffi_lower block_hash), sapling_tree_size))
    end

    def block_hash
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashblockmetadata_block_hash, @pointer)
      ZcashBlockHash._uniffi_allocate(result)
    end

    def block_height
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashblockmetadata_block_height, @pointer)
      ZcashBlockHeight._uniffi_allocate(result)
    end

    def sapling_tree_size
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashblockmetadata_sapling_tree_size, @pointer)
      result.to_i
    end
  end

  class ZcashCommitmentTree
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashcommitmenttree,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashCommitmentTree instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.empty
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashcommitmenttree_empty))
    end

    def append(node)
      node = node
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashcommitmenttree_append, @pointer,
                                 (ZcashSaplingNode._uniffi_lower node))
    end
  end

  class ZcashCommitmentTreeRoot
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashcommitmenttreeroot,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashCommitmentTreeRoot instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_parts(subtree_end_height, root_hash)
      subtree_end_height = subtree_end_height
      root_hash = root_hash
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashcommitmenttreeroot_from_parts,
                                       (ZcashBlockHeight._uniffi_lower subtree_end_height), (ZcashSaplingNode._uniffi_lower root_hash)))
    end

    def root_hash
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashcommitmenttreeroot_root_hash, @pointer)
      ZcashSaplingNode._uniffi_allocate(result)
    end

    def subtree_end_height
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashcommitmenttreeroot_subtree_end_height, @pointer)
      ZcashBlockHeight._uniffi_allocate(result)
    end
  end

  class ZcashDecryptedOutput
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashdecryptedoutput,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashDecryptedOutput instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def account
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdecryptedoutput_account, @pointer)
      result.consumeIntoTypeZcashAccountId
    end

    def index
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdecryptedoutput_index, @pointer)
      result.to_i
    end

    def memo
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdecryptedoutput_memo, @pointer)
      ZcashMemoBytes._uniffi_allocate(result)
    end

    def note
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdecryptedoutput_note, @pointer)
      ZcashSaplingNote._uniffi_allocate(result)
    end

    def transfer_type
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdecryptedoutput_transfer_type, @pointer)
      result.consumeIntoTypeZcashTransferType
    end
  end

  class ZcashDecryptedTransaction
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashdecryptedtransaction,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashDecryptedTransaction instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end
  end

  class ZcashDiversifiableFullViewingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashdiversifiablefullviewingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashDiversifiableFullViewingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashdiversifiablefullviewingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def address(j)
      j = j
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_address, @pointer,
                               (ZcashDiversifierIndex._uniffi_lower j))
      result.consumeIntoOptionalTypeZcashPaymentAddress
    end

    def change_address
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_change_address, @pointer)
      result.consumeIntoTypeZcashDiversifierIndexAndPaymentAddress
    end

    def decrypt_diversifier(addr)
      addr = addr
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_decrypt_diversifier,
                               @pointer, (ZcashPaymentAddress._uniffi_lower addr))
      result.consumeIntoOptionalTypeZcashDiversifierIndexAndScope
    end

    def default_address
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_default_address,
                               @pointer)
      result.consumeIntoTypeZcashDiversifierIndexAndPaymentAddress
    end

    def diversified_address(diversifier)
      diversifier = diversifier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_diversified_address,
                               @pointer, (ZcashDiversifier._uniffi_lower diversifier))
      result.consumeIntoOptionalTypeZcashPaymentAddress
    end

    def diversified_change_address(diversifier)
      diversifier = diversifier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_diversified_change_address,
                               @pointer, (ZcashDiversifier._uniffi_lower diversifier))
      result.consumeIntoOptionalTypeZcashPaymentAddress
    end

    def find_address(j)
      j = j
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_find_address, @pointer,
                               (ZcashDiversifierIndex._uniffi_lower j))
      result.consumeIntoOptionalTypeZcashDiversifierIndexAndPaymentAddress
    end

    def fvk
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_fvk, @pointer)
      ZcashFullViewingKey._uniffi_allocate(result)
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end

    def to_ivk(scope)
      scope = scope
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_ivk, @pointer,
                               RustBuffer.alloc_from_TypeZcashScope(scope))
      ZcashSaplingIvk._uniffi_allocate(result)
    end

    def to_nk(scope)
      scope = scope
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_nk, @pointer,
                               RustBuffer.alloc_from_TypeZcashScope(scope))
      ZcashNullifierDerivingKey._uniffi_allocate(result)
    end

    def to_ovk(scope)
      scope = scope
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifiablefullviewingkey_to_ovk, @pointer,
                               RustBuffer.alloc_from_TypeZcashScope(scope))
      ZcashOutgoingViewingKey._uniffi_allocate(result)
    end
  end

  class ZcashDiversifier
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashdiversifier,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashDiversifier instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      pointer = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_constructor_zcashdiversifier_new,
                                           RustBuffer.alloc_from_Sequenceu8(bytes))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifier_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashDiversifierIndex
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashdiversifierindex,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashDiversifierIndex instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashdiversifierindex_new)
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def self.from_u32(i)
      i = Zcash.uniffi_in_range(i, 'u32', 0, 2**32)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashdiversifierindex_from_u32, i))
    end

    def self.from_u64(i)
      i = Zcash.uniffi_in_range(i, 'u64', 0, 2**64)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashdiversifierindex_from_u64, i))
    end

    def increment
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashdiversifierindex_increment, @pointer)
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdiversifierindex_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end

    def to_u32
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashdiversifierindex_to_u32,
                                          @pointer)
      result.to_i
    end
  end

  class ZcashDustOutputPolicy
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashdustoutputpolicy,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashDustOutputPolicy instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(action, dust_threshold)
      action = action
      dust_threshold = (dust_threshold || nil)
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashdustoutputpolicy_new,
                                RustBuffer.alloc_from_TypeZcashDustAction(action), RustBuffer.alloc_from_OptionalTypeZcashAmount(dust_threshold))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def action
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdustoutputpolicy_action, @pointer)
      result.consumeIntoTypeZcashDustAction
    end

    def dust_threshold
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashdustoutputpolicy_dust_threshold, @pointer)
      result.consumeIntoOptionalTypeZcashAmount
    end
  end

  class ZcashExpandedSpendingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashexpandedspendingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashExpandedSpendingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(b)
      b = b.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashexpandedspendingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(b)))
    end

    def self.from_spending_key(sk)
      sk = sk.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(
                         :uniffi_uniffi_zcash_fn_constructor_zcashexpandedspendingkey_from_spending_key, RustBuffer.alloc_from_Sequenceu8(sk)
                       ))
    end

    def proof_generation_key
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashexpandedspendingkey_proof_generation_key, @pointer)
      ZcashProofGenerationKey._uniffi_allocate(result)
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashexpandedspendingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashExtendedFullViewingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashextendedfullviewingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashExtendedFullViewingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.decode(params, input)
      params = params
      input = Zcash.uniffi_utf8(input)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashextendedfullviewingkey_decode, RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.allocFromString(input)))
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashextendedfullviewingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def address(j)
      j = j
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_address, @pointer,
                               (ZcashDiversifierIndex._uniffi_lower j))
      result.consumeIntoOptionalTypeZcashPaymentAddress
    end

    def default_address
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_default_address, @pointer)
      result.consumeIntoTypeZcashDiversifierIndexAndPaymentAddress
    end

    def derive_child(i)
      i = i
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_derive_child, @pointer, RustBuffer.alloc_from_TypeZcashChildIndex(i))
      ZcashExtendedFullViewingKey._uniffi_allocate(result)
    end

    def derive_internal
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_derive_internal, @pointer)
      ZcashExtendedFullViewingKey._uniffi_allocate(result)
    end

    def encode(params)
      params = params
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_encode, @pointer,
                               RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
      result.consumeIntoString
    end

    def find_address(j)
      j = j
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_find_address, @pointer,
                               (ZcashDiversifierIndex._uniffi_lower j))
      result.consumeIntoOptionalTypeZcashDiversifierIndexAndPaymentAddress
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end

    def to_diversifiable_full_viewing_key
      result = Zcash.rust_call(
        :uniffi_uniffi_zcash_fn_method_zcashextendedfullviewingkey_to_diversifiable_full_viewing_key, @pointer
      )
      ZcashDiversifiableFullViewingKey._uniffi_allocate(result)
    end
  end

  class ZcashExtendedPrivKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashextendedprivkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashExtendedPrivKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def self.random
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_random))
    end

    def self.random_with_seed_size(seed_size)
      seed_size = seed_size
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_random_with_seed_size, RustBuffer.alloc_from_TypeZcashKeySeed(seed_size)))
    end

    def self.with_seed(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashextendedprivkey_with_seed, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def derive_private_key(key_index)
      key_index = key_index
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashextendedprivkey_derive_private_key, @pointer, (ZcashKeyIndex._uniffi_lower key_index))
      ZcashExtendedPrivKey._uniffi_allocate(result)
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedprivkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashExtendedSpendingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashextendedspendingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashExtendedSpendingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.decode(params, input)
      params = params
      input = Zcash.uniffi_utf8(input)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_decode, RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.allocFromString(input)))
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def self.from_path(master, path)
      master = master
      path = path
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_from_path,
                                       (ZcashExtendedSpendingKey._uniffi_lower master), RustBuffer.alloc_from_SequenceTypeZcashChildIndex(path)))
    end

    def self.master(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashextendedspendingkey_master,
                                       RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def default_address
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_default_address, @pointer)
      result.consumeIntoTypeZcashDiversifierIndexAndPaymentAddress
    end

    def derive_child(index)
      index = index
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_derive_child, @pointer,
                               RustBuffer.alloc_from_TypeZcashChildIndex(index))
      ZcashExtendedSpendingKey._uniffi_allocate(result)
    end

    def derive_internal
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_derive_internal, @pointer)
      ZcashExtendedSpendingKey._uniffi_allocate(result)
    end

    def encode(params)
      params = params
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_encode, @pointer,
                               RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
      result.consumeIntoString
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end

    def to_diversifiable_full_viewing_key
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextendedspendingkey_to_diversifiable_full_viewing_key,
                               @pointer)
      ZcashDiversifiableFullViewingKey._uniffi_allocate(result)
    end
  end

  class ZcashExternalIvk
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashexternalivk,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashExternalIvk instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashexternalivk_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def default_address
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashexternalivk_default_address, @pointer)
      result.consumeIntoTypeZcashTransparentAddressAndIndex
    end

    def derive_address(child_index)
      child_index = Zcash.uniffi_in_range(child_index, 'u32', 0, 2**32)
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashexternalivk_derive_address,
                                          @pointer, child_index)
      ZcashTransparentAddress._uniffi_allocate(result)
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashexternalivk_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashExternalOvk
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashexternalovk,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashExternalOvk instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def as_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashexternalovk_as_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashExtractedNoteCommitment
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashextractednotecommitment,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashExtractedNoteCommitment instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashextractednotecommitment_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashextractednotecommitment_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashFixedFeeRule
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashfixedfeerule,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashFixedFeeRule instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.non_standard(fixed_fee)
      fixed_fee = fixed_fee
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashfixedfeerule_non_standard,
                                       (ZcashAmount._uniffi_lower fixed_fee)))
    end

    def self.standard
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashfixedfeerule_standard))
    end

    def fixed_fee
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashfixedfeerule_fixed_fee, @pointer)
      ZcashAmount._uniffi_allocate(result)
    end
  end

  class ZcashFixedSingleOutputChangeStrategy
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashfixedsingleoutputchangestrategy,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashFixedSingleOutputChangeStrategy instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(fee_rule)
      fee_rule = fee_rule
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashfixedsingleoutputchangestrategy_new,
                                (ZcashFixedFeeRule._uniffi_lower fee_rule))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end

  class ZcashFsBlockDb
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashfsblockdb,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashFsBlockDb instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.for_path(fsblockdb_root)
      fsblockdb_root = Zcash.uniffi_utf8(fsblockdb_root)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashfsblockdb_for_path, RustBuffer.allocFromString(fsblockdb_root)))
    end

    def find_block(height)
      height = height
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashfsblockdb_find_block, @pointer,
                                          (ZcashBlockHeight._uniffi_lower height))
      result.consumeIntoOptionalTypeZcashBlockMeta
    end

    def get_max_cached_height
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashfsblockdb_get_max_cached_height,
                                          @pointer)
      result.consumeIntoOptionalTypeZcashBlockHeight
    end

    def initialize(blocks_dir)
      blocks_dir = Zcash.uniffi_utf8(blocks_dir)
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashfsblockdb_initialize, @pointer,
                                 RustBuffer.allocFromString(blocks_dir))
    end

    def write_block_metadata(block_meta)
      block_meta = block_meta
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashfsblockdb_write_block_metadata, @pointer,
                                 RustBuffer.alloc_from_SequenceTypeZcashBlockMeta(block_meta))
    end
  end

  class ZcashFullViewingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashfullviewingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashFullViewingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashfullviewingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def self.from_expanded_spending_key(expsk)
      expsk = expsk
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(
                         :uniffi_uniffi_zcash_fn_constructor_zcashfullviewingkey_from_expanded_spending_key, (ZcashExpandedSpendingKey._uniffi_lower expsk)
                       ))
    end

    def ovk
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashfullviewingkey_ovk, @pointer)
      ZcashOutgoingViewingKey._uniffi_allocate(result)
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashfullviewingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end

    def vk
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashfullviewingkey_vk, @pointer)
      ZcashViewingKey._uniffi_allocate(result)
    end
  end

  class ZcashIncrementalWitness
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashincrementalwitness,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashIncrementalWitness instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_tree(tree)
      tree = tree
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashincrementalwitness_from_tree,
                                       (ZcashCommitmentTree._uniffi_lower tree)))
    end

    def append(node)
      node = node
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashincrementalwitness_append, @pointer,
                                 (ZcashSaplingNode._uniffi_lower node))
    end

    def path
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashincrementalwitness_path, @pointer)
      result.consumeIntoOptionalTypeZcashSaplingMerklePath
    end
  end

  class ZcashInternalIvk
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashinternalivk,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashInternalIvk instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashinternalivk_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def default_address
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashinternalivk_default_address, @pointer)
      result.consumeIntoTypeZcashTransparentAddressAndIndex
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashinternalivk_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashInternalOvk
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashinternalovk,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashInternalOvk instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def as_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashinternalovk_as_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashJubjubFr
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashjubjubfr,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashJubjubFr instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashjubjubfr_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashjubjubfr_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashKeyIndex
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashkeyindex,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashKeyIndex instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_index(i)
      i = Zcash.uniffi_in_range(i, 'u32', 0, 2**32)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashkeyindex_from_index, i))
    end

    def self.from_u32(i)
      i = Zcash.uniffi_in_range(i, 'u32', 0, 2**32)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashkeyindex_from_u32, i))
    end

    def self.hardened_from_normalize_index(i)
      i = Zcash.uniffi_in_range(i, 'u32', 0, 2**32)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashkeyindex_hardened_from_normalize_index, i))
    end

    def is_valid
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashkeyindex_is_valid, @pointer)
      result == 1
    end

    def normalize_index
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashkeyindex_normalize_index, @pointer)
      result.to_i
    end

    def raw_index
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashkeyindex_raw_index, @pointer)
      result.to_i
    end
  end

  class ZcashLocalTxProver
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashlocaltxprover,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashLocalTxProver instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(spend_path, output_path)
      spend_path = Zcash.uniffi_utf8(spend_path)
      output_path = Zcash.uniffi_utf8(output_path)
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashlocaltxprover_new,
                                RustBuffer.allocFromString(spend_path), RustBuffer.allocFromString(output_path))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def self.from_bytes(spend_param_bytes, output_param_bytes)
      spend_param_bytes = spend_param_bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      output_param_bytes = output_param_bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashlocaltxprover_from_bytes,
                                       RustBuffer.alloc_from_Sequenceu8(spend_param_bytes), RustBuffer.alloc_from_Sequenceu8(output_param_bytes)))
    end

    def self.with_default_location
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashlocaltxprover_with_default_location))
    end
  end

  class ZcashMainFixedGreedyInputSelector
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashmainfixedgreedyinputselector,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashMainFixedGreedyInputSelector instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(change_strategy, dust_output_policy)
      change_strategy = change_strategy
      dust_output_policy = dust_output_policy
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashmainfixedgreedyinputselector_new,
                                (ZcashFixedSingleOutputChangeStrategy._uniffi_lower change_strategy), (ZcashDustOutputPolicy._uniffi_lower dust_output_policy))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end

  class ZcashMainZip317GreedyInputSelector
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashmainzip317greedyinputselector,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashMainZip317GreedyInputSelector instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(change_strategy, dust_output_policy)
      change_strategy = change_strategy
      dust_output_policy = dust_output_policy
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashmainzip317greedyinputselector_new,
                                (ZcashZip317SingleOutputChangeStrategy._uniffi_lower change_strategy), (ZcashDustOutputPolicy._uniffi_lower dust_output_policy))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end

  class ZcashMemoBytes
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashmemobytes,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashMemoBytes instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      pointer = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_constructor_zcashmemobytes_new,
                                           RustBuffer.alloc_from_Sequenceu8(data))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def self.empty
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashmemobytes_empty))
    end

    def data
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashmemobytes_data, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashNonNegativeAmount
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashnonnegativeamount,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashNonNegativeAmount instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_nonnegative_i64(amount)
      amount = Zcash.uniffi_in_range(amount, 'i64', -2**63, 2**63)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashnonnegativeamount_from_nonnegative_i64, amount))
    end

    def self.from_u64(amount)
      amount = Zcash.uniffi_in_range(amount, 'u64', 0, 2**64)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashnonnegativeamount_from_u64, amount))
    end

    def self.zero
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashnonnegativeamount_zero))
    end

    def value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashnonnegativeamount_value, @pointer)
      result.to_i
    end
  end

  class ZcashNoteId
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashnoteid,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashNoteId instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(txid, zsp, output_index)
      txid = txid
      zsp = zsp
      output_index = Zcash.uniffi_in_range(output_index, 'u16', 0, 2**16)
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashnoteid_new, (ZcashTxId._uniffi_lower txid),
                                RustBuffer.alloc_from_TypeZcashShieldedProtocol(zsp), output_index)
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end

  class ZcashNullifierDerivingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashnullifierderivingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashNullifierDerivingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashnullifierderivingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashnullifierderivingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashOrchardAction
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardaction,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardAction instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def cmx
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardaction_cmx, @pointer)
      ZcashExtractedNoteCommitment._uniffi_allocate(result)
    end

    def cv_net
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardaction_cv_net, @pointer)
      ZcashOrchardValueCommitment._uniffi_allocate(result)
    end

    def encrypted_note
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardaction_encrypted_note, @pointer)
      result.consumeIntoTypeZcashOrchardTransmittedNoteCiphertext
    end

    def nullifier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardaction_nullifier, @pointer)
      ZcashOrchardNullifier._uniffi_allocate(result)
    end
  end

  class ZcashOrchardAddress
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardaddress,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardAddress instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_raw_address_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardaddress_from_raw_address_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def diversifier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardaddress_diversifier, @pointer)
      ZcashOrchardDiversifier._uniffi_allocate(result)
    end

    def to_raw_address_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardaddress_to_raw_address_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashOrchardBundle
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardbundle,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardBundle instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def actions
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardbundle_actions, @pointer)
      result.consumeIntoSequenceTypeZcashOrchardAction
    end

    def anchor
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardbundle_anchor, @pointer)
      ZcashAnchor._uniffi_allocate(result)
    end

    def decrypt_output_with_key(action_idx, ivk)
      action_idx = Zcash.uniffi_in_range(action_idx, 'u64', 0, 2**64)
      ivk = ivk
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_decrypt_output_with_key, @pointer, action_idx, (ZcashOrchardIncomingViewingKey._uniffi_lower ivk))
      result.consumeIntoTypeZcashOrchardDecryptOutput
    end

    def decrypt_output_with_keys(ivks)
      ivks = ivks
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardbundle_decrypt_output_with_keys, @pointer,
                               RustBuffer.alloc_from_SequenceTypeZcashOrchardIncomingViewingKey(ivks))
      result.consumeIntoSequenceTypeZcashOrchardDecryptOutputForIncomingKeys
    end

    def flags
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardbundle_flags, @pointer)
      ZcashOrchardFlags._uniffi_allocate(result)
    end

    def recover_output_with_ovk(action_idx, ovk)
      action_idx = Zcash.uniffi_in_range(action_idx, 'u64', 0, 2**64)
      ovk = ovk
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_recover_output_with_ovk, @pointer, action_idx, (ZcashOrchardOutgoingViewingKey._uniffi_lower ovk))
      result.consumeIntoTypeZcashOrchardDecryptOutput
    end

    def recover_outputs_with_ovks(ovks)
      ovks = ovks
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardbundle_recover_outputs_with_ovks, @pointer,
                               RustBuffer.alloc_from_SequenceTypeZcashOrchardOutgoingViewingKey(ovks))
      result.consumeIntoSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys
    end

    def value_balance
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardbundle_value_balance, @pointer)
      ZcashAmount._uniffi_allocate(result)
    end

    def verify_proof(key)
      key = key
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashorchardbundle_verify_proof, @pointer,
                                 (ZcashVerifyingKey._uniffi_lower key))
    end
  end

  class ZcashOrchardDiversifier
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorcharddiversifier,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardDiversifier instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifier_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorcharddiversifier_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashOrchardDiversifierIndex
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorcharddiversifierindex,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardDiversifierIndex instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(b)
      b = b.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifierindex_from_bytes, RustBuffer.alloc_from_Sequenceu8(b)))
    end

    def self.from_u32(i)
      i = Zcash.uniffi_in_range(i, 'u32', 0, 2**32)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifierindex_from_u32,
                                       i))
    end

    def self.from_u64(i)
      i = Zcash.uniffi_in_range(i, 'u64', 0, 2**64)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashorcharddiversifierindex_from_u64,
                                       i))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorcharddiversifierindex_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashOrchardFlags
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardflags,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardFlags instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_byte(v)
      v = Zcash.uniffi_in_range(v, 'u8', 0, 2**8)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardflags_from_byte, v))
    end

    def self.from_parts(spends_enabled, outputs_enabled)
      spends_enabled = spends_enabled ? true : false
      outputs_enabled = outputs_enabled ? true : false
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashorchardflags_from_parts,
                                       (spends_enabled ? 1 : 0), (outputs_enabled ? 1 : 0)))
    end

    def outputs_enabled
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardflags_outputs_enabled, @pointer)
      result == 1
    end

    def spends_enabled
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardflags_spends_enabled, @pointer)
      result == 1
    end

    def to_byte
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardflags_to_byte, @pointer)
      result.to_i
    end
  end

  class ZcashOrchardFullViewingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardfullviewingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardFullViewingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardfullviewingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def address(d, scope)
      d = d
      scope = scope
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_address, @pointer,
                               (ZcashOrchardDiversifier._uniffi_lower d), RustBuffer.alloc_from_TypeZcashOrchardScope(scope))
      ZcashOrchardAddress._uniffi_allocate(result)
    end

    def address_at(j, scope)
      j = j
      scope = scope
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_address_at, @pointer,
                               (ZcashOrchardDiversifierIndex._uniffi_lower j), RustBuffer.alloc_from_TypeZcashOrchardScope(scope))
      ZcashOrchardAddress._uniffi_allocate(result)
    end

    def scope_for_address(address)
      address = address
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_scope_for_address, @pointer,
                               (ZcashOrchardAddress._uniffi_lower address))
      result.consumeIntoOptionalTypeZcashOrchardScope
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end

    def to_ivk(scope)
      scope = scope
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_to_ivk, @pointer,
                               RustBuffer.alloc_from_TypeZcashOrchardScope(scope))
      ZcashOrchardIncomingViewingKey._uniffi_allocate(result)
    end

    def to_ovk(scope)
      scope = scope
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardfullviewingkey_to_ovk, @pointer,
                               RustBuffer.alloc_from_TypeZcashOrchardScope(scope))
      ZcashOrchardOutgoingViewingKey._uniffi_allocate(result)
    end
  end

  class ZcashOrchardIncomingViewingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardincomingviewingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardIncomingViewingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardincomingviewingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def address(diversifier)
      diversifier = diversifier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_address, @pointer,
                               (ZcashOrchardDiversifier._uniffi_lower diversifier))
      ZcashOrchardAddress._uniffi_allocate(result)
    end

    def address_at(j)
      j = j
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_address_at, @pointer,
                               (ZcashOrchardDiversifierIndex._uniffi_lower j))
      ZcashOrchardAddress._uniffi_allocate(result)
    end

    def diversifier_index(addr)
      addr = addr
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_diversifier_index, @pointer,
                               (ZcashOrchardAddress._uniffi_lower addr))
      result.consumeIntoOptionalTypeZcashOrchardDiversifierIndex
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardincomingviewingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashOrchardMerkleHash
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardmerklehash,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardMerkleHash instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardmerklehash_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def self.from_cmx(cmx)
      cmx = cmx
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashorchardmerklehash_from_cmx,
                                       (ZcashExtractedNoteCommitment._uniffi_lower cmx)))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardmerklehash_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashOrchardMerklePath
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardmerklepath,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardMerklePath instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_parts(position, auth_path)
      position = Zcash.uniffi_in_range(position, 'u32', 0, 2**32)
      auth_path = auth_path
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardmerklepath_from_parts, position, RustBuffer.alloc_from_SequenceTypeZcashOrchardMerkleHash(auth_path)))
    end

    def root(cmx)
      cmx = cmx
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardmerklepath_root, @pointer,
                               (ZcashExtractedNoteCommitment._uniffi_lower cmx))
      ZcashAnchor._uniffi_allocate(result)
    end
  end

  class ZcashOrchardNote
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardnote,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardNote instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_parts(recipient, value, rho, rseed)
      recipient = recipient
      value = value
      rho = rho
      rseed = rseed
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardnote_from_parts, (ZcashOrchardAddress._uniffi_lower recipient), (ZcashOrchardNoteValue._uniffi_lower value), (ZcashOrchardNullifier._uniffi_lower rho), (ZcashOrchardRandomSeed._uniffi_lower rseed)))
    end

    def commitment
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardnote_commitment, @pointer)
      ZcashOrchardNoteCommitment._uniffi_allocate(result)
    end

    def recipient
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardnote_recipient, @pointer)
      ZcashOrchardAddress._uniffi_allocate(result)
    end

    def value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardnote_value, @pointer)
      ZcashOrchardNoteValue._uniffi_allocate(result)
    end
  end

  class ZcashOrchardNoteCommitment
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardnotecommitment,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardNoteCommitment instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def to_extracted_note_commitment
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardnotecommitment_to_extracted_note_commitment,
                               @pointer)
      ZcashExtractedNoteCommitment._uniffi_allocate(result)
    end
  end

  class ZcashOrchardNoteValue
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardnotevalue,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardNoteValue instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_raw(value)
      value = Zcash.uniffi_in_range(value, 'u64', 0, 2**64)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashorchardnotevalue_from_raw, value))
    end

    def value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardnotevalue_value, @pointer)
      result.to_i
    end
  end

  class ZcashOrchardNullifier
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardnullifier,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardNullifier instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardnullifier_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardnullifier_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashOrchardOutgoingViewingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardoutgoingviewingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardOutgoingViewingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardoutgoingviewingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardoutgoingviewingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashOrchardRandomSeed
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardrandomseed,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardRandomSeed instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data, rho)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      rho = rho
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardrandomseed_from_bytes, RustBuffer.alloc_from_Sequenceu8(data), (ZcashOrchardNullifier._uniffi_lower rho)))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardrandomseed_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashOrchardSpendingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardspendingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardSpendingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardspendingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def self.from_zip32_seed(seed, coin_type, account)
      seed = seed.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      coin_type = Zcash.uniffi_in_range(coin_type, 'u32', 0, 2**32)
      account = Zcash.uniffi_in_range(account, 'u32', 0, 2**32)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashorchardspendingkey_from_zip32_seed, RustBuffer.alloc_from_Sequenceu8(seed), coin_type, account))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardspendingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end

    def to_fvk
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardspendingkey_to_fvk, @pointer)
      ZcashOrchardFullViewingKey._uniffi_allocate(result)
    end
  end

  class ZcashOrchardTransactionBuilder
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardtransactionbuilder,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardTransactionBuilder instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(parameters, target_height, expiry_height, anchor, flags)
      parameters = parameters
      target_height = target_height
      expiry_height = expiry_height
      anchor = anchor
      flags = flags
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashorchardtransactionbuilder_new,
                                RustBuffer.alloc_from_TypeZcashConsensusParameters(parameters), (ZcashBlockHeight._uniffi_lower target_height), (ZcashBlockHeight._uniffi_lower expiry_height), (ZcashAnchor._uniffi_lower anchor), (ZcashOrchardFlags._uniffi_lower flags))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def add_recipient(ovk, recipient, value, memo)
      ovk = (ovk || nil)
      recipient = recipient
      value = value
      memo = (memo&.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) })
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashorchardtransactionbuilder_add_recipient,
                                 @pointer, RustBuffer.alloc_from_OptionalTypeZcashOrchardOutgoingViewingKey(ovk), (ZcashOrchardAddress._uniffi_lower recipient), (ZcashOrchardNoteValue._uniffi_lower value), RustBuffer.alloc_from_OptionalSequenceu8(memo))
    end

    def add_spend(fvk, note, merkle_path)
      fvk = fvk
      note = note
      merkle_path = merkle_path
      Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardtransactionbuilder_add_spend, @pointer,
                      (ZcashOrchardFullViewingKey._uniffi_lower fvk), (ZcashOrchardNote._uniffi_lower note), (ZcashOrchardMerklePath._uniffi_lower merkle_path))
    end

    def build(keys, sighash)
      keys = keys
      sighash = sighash.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashorchardtransactionbuilder_build,
                                          @pointer, RustBuffer.alloc_from_SequenceTypeZcashOrchardSpendingKey(keys), RustBuffer.alloc_from_Sequenceu8(sighash))
      ZcashTransaction._uniffi_allocate(result)
    end
  end

  class ZcashOrchardValueCommitment
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashorchardvaluecommitment,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOrchardValueCommitment instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashorchardvaluecommitment_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashOutPoint
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashoutpoint,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOutPoint instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(hash, n)
      hash = hash.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      n = Zcash.uniffi_in_range(n, 'u32', 0, 2**32)
      pointer = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_constructor_zcashoutpoint_new,
                                           RustBuffer.alloc_from_Sequenceu8(hash), n)
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end

  class ZcashOutgoingViewingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashoutgoingviewingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashOutgoingViewingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(b)
      b = b.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashoutgoingviewingkey_from_bytes, RustBuffer.alloc_from_Sequenceu8(b)))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashoutgoingviewingkey_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashPaymentAddress
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashpaymentaddress,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashPaymentAddress instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.decode(params, input)
      params = params
      input = Zcash.uniffi_utf8(input)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashpaymentaddress_decode, RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.allocFromString(input)))
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashpaymentaddress_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end

    def create_note(value, rseed)
      value = Zcash.uniffi_in_range(value, 'u64', 0, 2**64)
      rseed = rseed
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_create_note,
                                          @pointer, value, RustBuffer.alloc_from_TypeZcashRseed(rseed))
      ZcashSaplingNote._uniffi_allocate(result)
    end

    def diversifier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_diversifier, @pointer)
      ZcashDiversifier._uniffi_allocate(result)
    end

    def encode(params)
      params = params
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_encode, @pointer,
                               RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
      result.consumeIntoString
    end

    def pk_d
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_pk_d, @pointer)
      ZcashSaplingDiversifiedTransmissionKey._uniffi_allocate(result)
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashpaymentaddress_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashProofGenerationKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashproofgenerationkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashProofGenerationKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def to_viewing_key
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashproofgenerationkey_to_viewing_key, @pointer)
      ZcashViewingKey._uniffi_allocate(result)
    end
  end

  class ZcashProvingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashprovingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashProvingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashprovingkey_new)
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end

  class ZcashRatio
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashratio,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashRatio instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(numerator, denominator)
      numerator = Zcash.uniffi_in_range(numerator, 'u64', 0, 2**64)
      denominator = Zcash.uniffi_in_range(denominator, 'u64', 0, 2**64)
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashratio_new, numerator, denominator)
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def denominator
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashratio_denominator, @pointer)
      result.to_i
    end

    def numerator
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashratio_numerator, @pointer)
      result.to_i
    end
  end

  class ZcashReceivedNoteId
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashreceivednoteid,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashReceivedNoteId instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end
  end

  class ZcashReceivedSaplingNote
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashreceivedsaplingnote,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashReceivedSaplingNote instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def diversifier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashreceivedsaplingnote_diversifier, @pointer)
      ZcashDiversifier._uniffi_allocate(result)
    end

    def internal_note_id
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashreceivedsaplingnote_internal_note_id, @pointer)
      ZcashReceivedNoteId._uniffi_allocate(result)
    end

    def note_commitment_tree_position
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashreceivedsaplingnote_note_commitment_tree_position,
                               @pointer)
      MerkleTreePosition._uniffi_allocate(result)
    end

    def value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashreceivedsaplingnote_value, @pointer)
      ZcashAmount._uniffi_allocate(result)
    end
  end

  class ZcashRecipientAddress
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashrecipientaddress,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashRecipientAddress instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.decode(params, address)
      params = params
      address = Zcash.uniffi_utf8(address)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_decode, RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.allocFromString(address)))
    end

    def self.shielded(addr)
      addr = addr
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_shielded,
                                       (ZcashPaymentAddress._uniffi_lower addr)))
    end

    def self.transparent(addr)
      addr = addr
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_transparent,
                                       (ZcashTransparentAddress._uniffi_lower addr)))
    end

    def self.unified(addr)
      addr = addr
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashrecipientaddress_unified,
                                       (ZcashUnifiedAddress._uniffi_lower addr)))
    end

    def encode(params)
      params = params
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashrecipientaddress_encode, @pointer,
                               RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
      result.consumeIntoString
    end
  end

  class ZcashSaplingBundle
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingbundle,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingBundle instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def shielded_outputs
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingbundle_shielded_outputs, @pointer)
      result.consumeIntoSequenceTypeZcashSaplingOutputDescription
    end

    def shielded_spends
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingbundle_shielded_spends, @pointer)
      result.consumeIntoSequenceTypeZcashSaplingSpendDescription
    end

    def value_balance
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingbundle_value_balance, @pointer)
      ZcashAmount._uniffi_allocate(result)
    end
  end

  class ZcashSaplingDiversifiedTransmissionKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingdiversifiedtransmissionkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingDiversifiedTransmissionKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end
  end

  class ZcashSaplingExtractedNoteCommitment
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingextractednotecommitment,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingExtractedNoteCommitment instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      pointer = Zcash.rust_call_with_error(ZcashError,
                                           :uniffi_uniffi_zcash_fn_constructor_zcashsaplingextractednotecommitment_new, RustBuffer.alloc_from_Sequenceu8(data))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingextractednotecommitment_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashSaplingIvk
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingivk,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingIvk instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def to_payment_address(diversifier)
      diversifier = diversifier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingivk_to_payment_address, @pointer,
                               (ZcashDiversifier._uniffi_lower diversifier))
      result.consumeIntoOptionalTypeZcashPaymentAddress
    end

    def to_repr
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingivk_to_repr, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashSaplingMerklePath
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingmerklepath,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingMerklePath instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def auth_path
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingmerklepath_auth_path, @pointer)
      result.consumeIntoSequenceTypeZcashAuthPath
    end

    def position
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingmerklepath_position, @pointer)
      result.to_i
    end
  end

  class ZcashSaplingMetadata
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingmetadata,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingMetadata instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashsaplingmetadata_new)
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def output_index(n)
      n = Zcash.uniffi_in_range(n, 'u64', 0, 2**64)
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingmetadata_output_index, @pointer, n)
      result.consumeIntoOptionalu64
    end

    def spend_index(n)
      n = Zcash.uniffi_in_range(n, 'u64', 0, 2**64)
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingmetadata_spend_index, @pointer, n)
      result.consumeIntoOptionalu64
    end
  end

  class ZcashSaplingNode
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingnode,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingNode instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_cmu(cmu)
      cmu = cmu
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashsaplingnode_from_cmu,
                                       (ZcashSaplingExtractedNoteCommitment._uniffi_lower cmu)))
    end
  end

  class ZcashSaplingNote
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingnote,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingNote instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_parts(recipient, value, rseed)
      recipient = recipient
      value = value
      rseed = rseed
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashsaplingnote_from_parts, (ZcashPaymentAddress._uniffi_lower recipient), (ZcashSaplingNoteValue._uniffi_lower value), RustBuffer.alloc_from_TypeZcashRseed(rseed)))
    end

    def cmu
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingnote_cmu, @pointer)
      ZcashSaplingExtractedNoteCommitment._uniffi_allocate(result)
    end

    def value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingnote_value, @pointer)
      ZcashSaplingNoteValue._uniffi_allocate(result)
    end
  end

  class ZcashSaplingNoteValue
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingnotevalue,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingNoteValue instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_raw(data)
      data = Zcash.uniffi_in_range(data, 'u64', 0, 2**64)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashsaplingnotevalue_from_raw, data))
    end

    def inner
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingnotevalue_inner, @pointer)
      result.to_i
    end
  end

  class ZcashSaplingNullifier
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingnullifier,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingNullifier instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingnullifier_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashSaplingOutputDescription
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingoutputdescription,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingOutputDescription instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def cmu
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingoutputdescription_cmu, @pointer)
      ZcashSaplingExtractedNoteCommitment._uniffi_allocate(result)
    end

    def cv
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingoutputdescription_cv, @pointer)
      ZcashSaplingValueCommitment._uniffi_allocate(result)
    end
  end

  class ZcashSaplingPublicKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingpublickey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingPublicKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def to_bytes
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashsaplingpublickey_to_bytes,
                                          @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashSaplingSpendDescription
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingspenddescription,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingSpendDescription instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def anchor
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_anchor, @pointer)
      result.consumeIntoSequenceu8
    end

    def cv
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_cv, @pointer)
      ZcashSaplingValueCommitment._uniffi_allocate(result)
    end

    def nullifier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_nullifier, @pointer)
      ZcashSaplingNullifier._uniffi_allocate(result)
    end

    def rk
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingspenddescription_rk, @pointer)
      ZcashSaplingPublicKey._uniffi_allocate(result)
    end
  end

  class ZcashSaplingValueCommitment
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsaplingvaluecommitment,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSaplingValueCommitment instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsaplingvaluecommitment_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashScanRange
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashscanrange,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashScanRange instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_parts(start_block, end_block, priority)
      start_block = start_block
      end_block = end_block
      priority = priority
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashscanrange_from_parts,
                                       (ZcashBlockHeight._uniffi_lower start_block), (ZcashBlockHeight._uniffi_lower end_block), RustBuffer.alloc_from_TypeZcashScanPriority(priority)))
    end

    def block_range
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscanrange_block_range, @pointer)
      result.consumeIntoSequenceTypeZcashBlockHeight
    end

    def is_empty
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscanrange_is_empty, @pointer)
      result == 1
    end

    def len
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscanrange_len, @pointer)
      result.to_i
    end

    def priority
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscanrange_priority, @pointer)
      result.consumeIntoTypeZcashScanPriority
    end
  end

  class ZcashScannedBlock
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashscannedblock,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashScannedBlock instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_parts(metadata, block_time, transactions, sapling_nullifier_map, sapling_commitments)
      metadata = metadata
      block_time = Zcash.uniffi_in_range(block_time, 'u32', 0, 2**32)
      transactions = transactions
      sapling_nullifier_map = sapling_nullifier_map
      sapling_commitments = sapling_commitments
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashscannedblock_from_parts,
                                       (ZcashBlockMetadata._uniffi_lower metadata), block_time, RustBuffer.alloc_from_SequenceTypeZcashWalletTx(transactions), RustBuffer.alloc_from_SequenceTypeTripleSaplingNullifierMap(sapling_nullifier_map), RustBuffer.alloc_from_SequenceTypeTupleSaplingCommitments(sapling_commitments)))
    end

    def block_hash
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscannedblock_block_hash, @pointer)
      ZcashBlockHash._uniffi_allocate(result)
    end

    def block_time
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscannedblock_block_time, @pointer)
      result.to_i
    end

    def height
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscannedblock_height, @pointer)
      ZcashBlockHeight._uniffi_allocate(result)
    end

    def metadata
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscannedblock_metadata, @pointer)
      ZcashBlockMetadata._uniffi_allocate(result)
    end

    def sapling_commitments
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscannedblock_sapling_commitments, @pointer)
      result.consumeIntoSequenceTypeTupleSaplingCommitments
    end

    def sapling_nullifier_map
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscannedblock_sapling_nullifier_map, @pointer)
      result.consumeIntoSequenceTypeTripleSaplingNullifierMap
    end

    def transactions
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashscannedblock_transactions, @pointer)
      result.consumeIntoSequenceTypeZcashWalletTx
    end
  end

  class ZcashScript
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashscript,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashScript instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashscript_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def to_bytes
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashscript_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashSentTransactionOutput
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashsenttransactionoutput,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashSentTransactionOutput instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_parts(output_index, recipient, value, memo, sapling_change_to)
      output_index = Zcash.uniffi_in_range(output_index, 'u32', 0, 2**32)
      recipient = recipient
      value = value
      memo = (memo || nil)
      sapling_change_to = (sapling_change_to || nil)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashsenttransactionoutput_from_parts,
                                       output_index, RustBuffer.alloc_from_TypeZcashRecipient(recipient), (ZcashAmount._uniffi_lower value), RustBuffer.alloc_from_OptionalTypeZcashMemoBytes(memo), RustBuffer.alloc_from_OptionalTypeTupleAccountIdAndSaplingNote(sapling_change_to)))
    end

    def memo
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsenttransactionoutput_memo, @pointer)
      result.consumeIntoOptionalTypeZcashMemoBytes
    end

    def output_index
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsenttransactionoutput_output_index, @pointer)
      result.to_i
    end

    def recipient
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsenttransactionoutput_recipient, @pointer)
      result.consumeIntoTypeZcashRecipient
    end

    def sapling_change_to
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsenttransactionoutput_sapling_change_to, @pointer)
      result.consumeIntoOptionalTypeTupleAccountIdAndSaplingNote
    end

    def value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashsenttransactionoutput_value, @pointer)
      ZcashAmount._uniffi_allocate(result)
    end
  end

  class ZcashTestFixedGreedyInputSelector
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtestfixedgreedyinputselector,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTestFixedGreedyInputSelector instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(change_strategy, dust_output_policy)
      change_strategy = change_strategy
      dust_output_policy = dust_output_policy
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashtestfixedgreedyinputselector_new,
                                (ZcashFixedSingleOutputChangeStrategy._uniffi_lower change_strategy), (ZcashDustOutputPolicy._uniffi_lower dust_output_policy))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end

  class ZcashTestZip317GreedyInputSelector
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtestzip317greedyinputselector,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTestZip317GreedyInputSelector instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(change_strategy, dust_output_policy)
      change_strategy = change_strategy
      dust_output_policy = dust_output_policy
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashtestzip317greedyinputselector_new,
                                (ZcashZip317SingleOutputChangeStrategy._uniffi_lower change_strategy), (ZcashDustOutputPolicy._uniffi_lower dust_output_policy))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end

  class ZcashTransaction
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtransaction,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTransaction instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data, consensus_branch_id)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      consensus_branch_id = consensus_branch_id
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashtransaction_from_bytes, RustBuffer.alloc_from_Sequenceu8(data), RustBuffer.alloc_from_TypeZcashBranchId(consensus_branch_id)))
    end

    def consensus_branch_id
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransaction_consensus_branch_id, @pointer)
      result.consumeIntoTypeZcashBranchId
    end

    def expiry_height
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransaction_expiry_height, @pointer)
      ZcashBlockHeight._uniffi_allocate(result)
    end

    def lock_time
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransaction_lock_time, @pointer)
      result.to_i
    end

    def orchard_bundle
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransaction_orchard_bundle, @pointer)
      result.consumeIntoOptionalTypeZcashOrchardBundle
    end

    def sapling_bundle
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransaction_sapling_bundle, @pointer)
      result.consumeIntoOptionalTypeZcashSaplingBundle
    end

    def to_bytes
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashtransaction_to_bytes,
                                          @pointer)
      result.consumeIntoSequenceu8
    end

    def transparent_bundle
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransaction_transparent_bundle, @pointer)
      result.consumeIntoOptionalTypeZcashTransparentBundle
    end

    def txid
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransaction_txid, @pointer)
      ZcashTxId._uniffi_allocate(result)
    end

    def version
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransaction_version, @pointer)
      ZcashTxVersion._uniffi_allocate(result)
    end
  end

  class ZcashTransactionBuilder
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtransactionbuilder,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTransactionBuilder instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(parameters, block_height)
      parameters = parameters
      block_height = block_height
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashtransactionbuilder_new,
                                RustBuffer.alloc_from_TypeZcashConsensusParameters(parameters), (ZcashBlockHeight._uniffi_lower block_height))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def add_sapling_output(ovk, to, value, memo)
      ovk = (ovk || nil)
      to = to
      value = value
      memo = memo
      Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_sapling_output, @pointer,
                      RustBuffer.alloc_from_OptionalTypeZcashOutgoingViewingKey(ovk), (ZcashPaymentAddress._uniffi_lower to), (ZcashAmount._uniffi_lower value), (ZcashMemoBytes._uniffi_lower memo))
    end

    def add_sapling_spend(extsk, diversifier, note, merkle_path)
      extsk = extsk
      diversifier = diversifier
      note = note
      merkle_path = merkle_path
      Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_sapling_spend, @pointer,
                      (ZcashExtendedSpendingKey._uniffi_lower extsk), (ZcashDiversifier._uniffi_lower diversifier), (ZcashSaplingNote._uniffi_lower note), (ZcashSaplingMerklePath._uniffi_lower merkle_path))
    end

    def add_transparent_input(sk, utxo, coin)
      sk = sk
      utxo = utxo
      coin = coin
      Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_transparent_input, @pointer,
                      (SecpSecretKey._uniffi_lower sk), (ZcashOutPoint._uniffi_lower utxo), (ZcashTxOut._uniffi_lower coin))
    end

    def add_transparent_output(to, value)
      to = to
      value = value
      Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_add_transparent_output, @pointer,
                      (ZcashTransparentAddress._uniffi_lower to), (ZcashAmount._uniffi_lower value))
    end

    def build(prover, fee_rule)
      prover = prover
      fee_rule = fee_rule
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashtransactionbuilder_build,
                                          @pointer, (ZcashLocalTxProver._uniffi_lower prover), RustBuffer.alloc_from_TypeZcashFeeRules(fee_rule))
      result.consumeIntoTypeZcashTransactionAndSaplingMetadata
    end
  end

  class ZcashTransactionRequest
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtransactionrequest,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTransactionRequest instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(payments)
      payments = payments
      pointer = Zcash.rust_call_with_error(ZcashZip321Error,
                                           :uniffi_uniffi_zcash_fn_constructor_zcashtransactionrequest_new, RustBuffer.alloc_from_SequenceTypeZcashPayment(payments))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def self.empty
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashtransactionrequest_empty))
    end

    def self.from_uri(params, uri)
      params = params
      uri = Zcash.uniffi_utf8(uri)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashZip321Error,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashtransactionrequest_from_uri, RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.allocFromString(uri)))
    end

    def payments
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransactionrequest_payments, @pointer)
      result.consumeIntoSequenceTypeZcashPayment
    end

    def to_uri(params)
      params = params
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransactionrequest_to_uri, @pointer,
                               RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
      result.consumeIntoOptionalstring
    end
  end

  class ZcashTransparentAddress
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtransparentaddress,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTransparentAddress instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.decode(params, input)
      params = params
      input = Zcash.uniffi_utf8(input)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashtransparentaddress_decode, RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.allocFromString(input)))
    end

    def self.from_public_key(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashtransparentaddress_from_public_key, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def self.from_script(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashtransparentaddress_from_script, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def encode(params)
      params = params
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_encode, @pointer,
                               RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
      result.consumeIntoString
    end

    def is_public_key
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_is_public_key, @pointer)
      result == 1
    end

    def is_script
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_is_script, @pointer)
      result == 1
    end

    def script
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_script, @pointer)
      ZcashScript._uniffi_allocate(result)
    end

    def to_bytes
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransparentaddress_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashTransparentBundle
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtransparentbundle,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTransparentBundle instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def is_coinbase
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransparentbundle_is_coinbase, @pointer)
      result == 1
    end

    def vin
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransparentbundle_vin, @pointer)
      result.consumeIntoSequenceTypeZcashTxIn
    end

    def vout
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtransparentbundle_vout, @pointer)
      result.consumeIntoSequenceTypeZcashTxOut
    end
  end

  class ZcashTreeState
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtreestate,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTreeState instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(network, height, hash, time, sapling_tree, orchard_tree)
      network = Zcash.uniffi_utf8(network)
      height = Zcash.uniffi_in_range(height, 'u64', 0, 2**64)
      hash = Zcash.uniffi_utf8(hash)
      time = Zcash.uniffi_in_range(time, 'u32', 0, 2**32)
      sapling_tree = Zcash.uniffi_utf8(sapling_tree)
      orchard_tree = Zcash.uniffi_utf8(orchard_tree)
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashtreestate_new,
                                RustBuffer.allocFromString(network), height, RustBuffer.allocFromString(hash), time, RustBuffer.allocFromString(sapling_tree), RustBuffer.allocFromString(orchard_tree))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def self.from_bytes(bytes)
      bytes = bytes.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashtreestate_from_bytes, RustBuffer.alloc_from_Sequenceu8(bytes)))
    end
  end

  class ZcashTxId
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtxid,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTxId instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashtxid_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def to_bytes
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashtxid_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end

    def to_hex_string
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashtxid_to_hex_string, @pointer)
      result.consumeIntoString
    end
  end

  class ZcashTxIn
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtxin,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTxIn instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def to_bytes
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashtxin_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end
  end

  class ZcashTxOut
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtxout,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTxOut instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(value, script_pubkey)
      value = value
      script_pubkey = script_pubkey
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashtxout_new, (ZcashAmount._uniffi_lower value),
                                (ZcashScript._uniffi_lower script_pubkey))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def recipient_address
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtxout_recipient_address, @pointer)
      result.consumeIntoOptionalTypeZcashTransparentAddress
    end

    def script_pubkey
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtxout_script_pubkey, @pointer)
      ZcashScript._uniffi_allocate(result)
    end

    def to_bytes
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashtxout_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end

    def value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtxout_value, @pointer)
      ZcashAmount._uniffi_allocate(result)
    end
  end

  class ZcashTxVersion
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashtxversion,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashTxVersion instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(data)
      data = data.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashtxversion_from_bytes, RustBuffer.alloc_from_Sequenceu8(data)))
    end

    def self.suggested_for_branch(consensus_branch_id)
      consensus_branch_id = consensus_branch_id
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashtxversion_suggested_for_branch,
                                       RustBuffer.alloc_from_TypeZcashBranchId(consensus_branch_id)))
    end

    def has_orchard
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtxversion_has_orchard, @pointer)
      result == 1
    end

    def has_overwinter
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtxversion_has_overwinter, @pointer)
      result == 1
    end

    def has_sapling
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtxversion_has_sapling, @pointer)
      result == 1
    end

    def has_sprout
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtxversion_has_sprout, @pointer)
      result == 1
    end

    def header
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtxversion_header, @pointer)
      result.to_i
    end

    def selection
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtxversion_selection, @pointer)
      result.consumeIntoTypeZcashTxVersionSelection
    end

    def to_bytes
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashtxversion_to_bytes, @pointer)
      result.consumeIntoSequenceu8
    end

    def version_group_id
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashtxversion_version_group_id, @pointer)
      result.to_i
    end
  end

  class ZcashUnifiedAddress
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashunifiedaddress,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashUnifiedAddress instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(orchard, sapling, transparent)
      orchard = (orchard || nil)
      sapling = (sapling || nil)
      transparent = (transparent || nil)
      pointer = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_constructor_zcashunifiedaddress_new,
                                           RustBuffer.alloc_from_OptionalTypeZcashOrchardAddress(orchard), RustBuffer.alloc_from_OptionalTypeZcashPaymentAddress(sapling), RustBuffer.alloc_from_OptionalTypeZcashTransparentAddress(transparent))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def self.decode(params, address)
      params = params
      address = Zcash.uniffi_utf8(address)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashunifiedaddress_decode, RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.allocFromString(address)))
    end

    def encode(params)
      params = params
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_encode, @pointer,
                               RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
      result.consumeIntoString
    end

    def orchard
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_orchard, @pointer)
      result.consumeIntoOptionalTypeZcashOrchardAddress
    end

    def sapling
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_sapling, @pointer)
      result.consumeIntoOptionalTypeZcashPaymentAddress
    end

    def transparent
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedaddress_transparent, @pointer)
      result.consumeIntoOptionalTypeZcashTransparentAddress
    end
  end

  class ZcashUnifiedFullViewingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashunifiedfullviewingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashUnifiedFullViewingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(transparent, sapling, orchard)
      transparent = (transparent || nil)
      sapling = (sapling || nil)
      orchard = (orchard || nil)
      pointer = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_constructor_zcashunifiedfullviewingkey_new,
                                           RustBuffer.alloc_from_OptionalTypeZcashAccountPubKey(transparent), RustBuffer.alloc_from_OptionalTypeZcashDiversifiableFullViewingKey(sapling), RustBuffer.alloc_from_OptionalTypeZcashOrchardFullViewingKey(orchard))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def self.decode(params, encoded)
      params = params
      encoded = Zcash.uniffi_utf8(encoded)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashunifiedfullviewingkey_decode, RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.allocFromString(encoded)))
    end

    def address(j)
      j = j
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_address, @pointer,
                               (ZcashDiversifierIndex._uniffi_lower j))
      result.consumeIntoOptionalTypeZcashUnifiedAddress
    end

    def default_address
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_default_address, @pointer)
      result.consumeIntoTypeZcashUnifiedAddressAndDiversifierIndex
    end

    def encode(params)
      params = params
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_encode, @pointer,
                               RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
      result.consumeIntoString
    end

    def find_address(j)
      j = j
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_find_address, @pointer,
                               (ZcashDiversifierIndex._uniffi_lower j))
      result.consumeIntoOptionalTypeZcashUnifiedAddressAndDiversifierIndex
    end

    def orchard
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_orchard, @pointer)
      result.consumeIntoOptionalTypeZcashOrchardFullViewingKey
    end

    def sapling
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_sapling, @pointer)
      result.consumeIntoOptionalTypeZcashDiversifiableFullViewingKey
    end

    def transparent
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedfullviewingkey_transparent, @pointer)
      result.consumeIntoOptionalTypeZcashAccountPubKey
    end
  end

  class ZcashUnifiedSpendingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashunifiedspendingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashUnifiedSpendingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_bytes(era, encoded)
      era = era
      encoded = encoded.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashunifiedspendingkey_from_bytes, RustBuffer.alloc_from_TypeZcashKeysEra(era), RustBuffer.alloc_from_Sequenceu8(encoded)))
    end

    def self.from_seed(params, seed, account_id)
      params = params
      seed = seed.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      account_id = account_id
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashunifiedspendingkey_from_seed, RustBuffer.alloc_from_TypeZcashConsensusParameters(params), RustBuffer.alloc_from_Sequenceu8(seed), RustBuffer.alloc_from_TypeZcashAccountId(account_id)))
    end

    def orchard
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_orchard, @pointer)
      ZcashOrchardSpendingKey._uniffi_allocate(result)
    end

    def sapling
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_sapling, @pointer)
      ZcashExtendedSpendingKey._uniffi_allocate(result)
    end

    def to_bytes(era)
      era = era
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_to_bytes, @pointer,
                               RustBuffer.alloc_from_TypeZcashKeysEra(era))
      result.consumeIntoSequenceu8
    end

    def to_unified_full_viewing_key
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_to_unified_full_viewing_key,
                               @pointer)
      ZcashUnifiedFullViewingKey._uniffi_allocate(result)
    end

    def transparent
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashunifiedspendingkey_transparent, @pointer)
      ZcashAccountPrivKey._uniffi_allocate(result)
    end
  end

  class ZcashVerifyingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashverifyingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashVerifyingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashverifyingkey_new)
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end

  class ZcashViewingKey
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashviewingkey,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashViewingKey instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def ivk
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashviewingkey_ivk, @pointer)
      ZcashSaplingIvk._uniffi_allocate(result)
    end

    def to_payment_address(diversifier)
      diversifier = diversifier
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashviewingkey_to_payment_address, @pointer,
                               (ZcashDiversifier._uniffi_lower diversifier))
      result.consumeIntoOptionalTypeZcashPaymentAddress
    end
  end

  class ZcashWalletDb
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashwalletdb,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashWalletDb instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.for_path(path, params)
      path = Zcash.uniffi_utf8(path)
      params = params
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashwalletdb_for_path, RustBuffer.allocFromString(path), RustBuffer.alloc_from_TypeZcashConsensusParameters(params)))
    end

    def block_fully_scanned
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_block_fully_scanned,
                                          @pointer)
      result.consumeIntoOptionalTypeZcashBlockMetadata
    end

    def block_max_scanned
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_block_max_scanned,
                                          @pointer)
      result.consumeIntoOptionalTypeZcashBlockMetadata
    end

    def block_metadata(height)
      height = height
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_block_metadata, @pointer,
                                          (ZcashBlockHeight._uniffi_lower height))
      result.consumeIntoOptionalTypeZcashBlockMetadata
    end

    def chain_height
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_chain_height,
                                          @pointer)
      result.consumeIntoOptionalTypeZcashBlockHeight
    end

    def create_account(seed, birthday)
      seed = seed.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      birthday = birthday
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_create_account, @pointer,
                                          RustBuffer.alloc_from_Sequenceu8(seed), (ZcashAccountBirthday._uniffi_lower birthday))
      result.consumeIntoTypeTupleAccountIdAndUnifiedSpendingKey
    end

    def get_account_birthday(account)
      account = account
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_account_birthday,
                                          @pointer, RustBuffer.alloc_from_TypeZcashAccountId(account))
      ZcashBlockHeight._uniffi_allocate(result)
    end

    def get_account_for_ufvk(zufvk)
      zufvk = zufvk
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_account_for_ufvk,
                                          @pointer, (ZcashUnifiedFullViewingKey._uniffi_lower zufvk))
      result.consumeIntoOptionalTypeZcashAccountId
    end

    def get_block_hash(height)
      height = height
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_block_hash, @pointer,
                                          (ZcashBlockHeight._uniffi_lower height))
      result.consumeIntoOptionalTypeZcashBlockHash
    end

    def get_current_address(aid)
      aid = aid
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_current_address,
                                          @pointer, RustBuffer.alloc_from_TypeZcashAccountId(aid))
      result.consumeIntoOptionalTypeZcashUnifiedAddress
    end

    def get_max_height_hash
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_max_height_hash,
                                          @pointer)
      result.consumeIntoOptionalTypeTupleBlockHeightAndHash
    end

    def get_memo(id_note)
      id_note = id_note
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_memo, @pointer,
                                          (ZcashNoteId._uniffi_lower id_note))
      result.consumeIntoTypeZcashMemo
    end

    def get_min_unspent_height
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_min_unspent_height,
                                          @pointer)
      result.consumeIntoOptionalTypeZcashBlockHeight
    end

    def get_next_available_address(account)
      account = account
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_next_available_address, @pointer, RustBuffer.alloc_from_TypeZcashAccountId(account))
      result.consumeIntoOptionalTypeZcashUnifiedAddress
    end

    def get_sapling_nullifiers(query)
      query = query
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_sapling_nullifiers,
                                          @pointer, RustBuffer.alloc_from_TypeZcashNullifierQuery(query))
      result.consumeIntoSequenceTypeTupleAccountIdAndSaplingNullifier
    end

    def get_spendable_sapling_notes(account, anchor_height, exclude)
      account = account
      anchor_height = anchor_height
      exclude = exclude
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_spendable_sapling_notes, @pointer, RustBuffer.alloc_from_TypeZcashAccountId(account), (ZcashBlockHeight._uniffi_lower anchor_height), RustBuffer.alloc_from_SequenceTypeZcashReceivedNoteId(exclude))
      result.consumeIntoSequenceTypeZcashReceivedSaplingNote
    end

    def get_target_and_anchor_heights(min_confirmations)
      min_confirmations = Zcash.uniffi_in_range(min_confirmations, 'u32', 0, 2**32)
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_target_and_anchor_heights, @pointer, min_confirmations)
      result.consumeIntoOptionalTypeTupleTargetAndAnchorHeight
    end

    def get_transaction(txid)
      txid = txid
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_transaction,
                                          @pointer, (ZcashTxId._uniffi_lower txid))
      ZcashTransaction._uniffi_allocate(result)
    end

    def get_transparent_balances(account, max_height)
      account = account
      max_height = max_height
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_transparent_balances, @pointer, RustBuffer.alloc_from_TypeZcashAccountId(account), (ZcashBlockHeight._uniffi_lower max_height))
      result.consumeIntoMapStringTypeZcashAmount
    end

    def get_transparent_receivers(aid)
      aid = aid
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_transparent_receivers, @pointer, RustBuffer.alloc_from_TypeZcashAccountId(aid))
      result.consumeIntoMapStringTypeZcashAddressMetadata
    end

    def get_tx_height(txid)
      txid = txid
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_tx_height, @pointer,
                                          (ZcashTxId._uniffi_lower txid))
      result.consumeIntoOptionalTypeZcashBlockHeight
    end

    def get_unified_full_viewing_keys
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_unified_full_viewing_keys, @pointer)
      result.consumeIntoMapTypeZcashAccountIdTypeZcashUnifiedFullViewingKey
    end

    def get_unspent_transparent_outputs(zta, zbh, zop)
      zta = zta
      zbh = zbh
      zop = zop
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_unspent_transparent_outputs, @pointer, (ZcashTransparentAddress._uniffi_lower zta), (ZcashBlockHeight._uniffi_lower zbh), RustBuffer.alloc_from_SequenceTypeZcashOutPoint(zop))
      result.consumeIntoSequenceTypeZcashWalletTransparentOutput
    end

    def get_wallet_birthday
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_wallet_birthday,
                                          @pointer)
      result.consumeIntoOptionalTypeZcashBlockHeight
    end

    def get_wallet_summary(min_confirmations)
      min_confirmations = Zcash.uniffi_in_range(min_confirmations, 'u32', 0, 2**32)
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_get_wallet_summary,
                                          @pointer, min_confirmations)
      result.consumeIntoOptionalTypeZcashWalletSummary
    end

    def initialize(seed)
      seed = seed.map { |v| Zcash.uniffi_in_range(v, 'u8', 0, 2**8) }
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_initialize, @pointer,
                                 RustBuffer.alloc_from_Sequenceu8(seed))
    end

    def is_valid_account_extfvk(account, extfvk)
      account = account
      extfvk = extfvk
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_is_valid_account_extfvk,
                                          @pointer, RustBuffer.alloc_from_TypeZcashAccountId(account), (ZcashExtendedFullViewingKey._uniffi_lower extfvk))
      result == 1
    end

    def put_blocks(blocks)
      blocks = blocks
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_put_blocks, @pointer,
                                 RustBuffer.alloc_from_SequenceTypeZcashScannedBlock(blocks))
    end

    def put_received_transparent_utxo(output)
      output = output
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashwalletdb_put_received_transparent_utxo, @pointer, (ZcashWalletTransparentOutput._uniffi_lower output))
      result.to_i
    end

    def put_sapling_subtree_roots(start_index, roots)
      start_index = Zcash.uniffi_in_range(start_index, 'u64', 0, 2**64)
      roots = roots
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_put_sapling_subtree_roots,
                                 @pointer, start_index, RustBuffer.alloc_from_SequenceTypeZcashCommitmentTreeRoot(roots))
    end

    def select_spendable_sapling_notes(account, target_value, anchor_height, exclude)
      account = account
      target_value = target_value
      anchor_height = anchor_height
      exclude = exclude
      result = Zcash.rust_call_with_error(ZcashError,
                                          :uniffi_uniffi_zcash_fn_method_zcashwalletdb_select_spendable_sapling_notes, @pointer, RustBuffer.alloc_from_TypeZcashAccountId(account), (ZcashAmount._uniffi_lower target_value), (ZcashBlockHeight._uniffi_lower anchor_height), RustBuffer.alloc_from_SequenceTypeZcashReceivedNoteId(exclude))
      result.consumeIntoSequenceTypeZcashReceivedSaplingNote
    end

    def store_decrypted_tx(d_tx)
      d_tx = d_tx
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_store_decrypted_tx, @pointer,
                                 (ZcashDecryptedTransaction._uniffi_lower d_tx))
    end

    def store_sent_tx(sent_tx)
      sent_tx = sent_tx
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_store_sent_tx, @pointer,
                                 RustBuffer.alloc_from_TypeZcashSentTransaction(sent_tx))
    end

    def suggest_scan_ranges
      result = Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_suggest_scan_ranges,
                                          @pointer)
      result.consumeIntoSequenceTypeZcashScanRange
    end

    def truncate_to_height(block_height)
      block_height = Zcash.uniffi_in_range(block_height, 'u32', 0, 2**32)
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_truncate_to_height, @pointer,
                                 block_height)
    end

    def update_chain_tip(tip_height)
      tip_height = Zcash.uniffi_in_range(tip_height, 'u32', 0, 2**32)
      Zcash.rust_call_with_error(ZcashError, :uniffi_uniffi_zcash_fn_method_zcashwalletdb_update_chain_tip, @pointer,
                                 tip_height)
    end
  end

  class ZcashWalletSaplingOutput
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashwalletsaplingoutput,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashWalletSaplingOutput instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end
  end

  class ZcashWalletSaplingSpend
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashwalletsaplingspend,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashWalletSaplingSpend instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end
  end

  class ZcashWalletSummary
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashwalletsummary,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashWalletSummary instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(account_balances, chain_tip_height, fully_scanned_height, scan_progress)
      account_balances = account_balances.each.with_object({}) { |(k, v), res| res[Zcash.uniffi_utf8(k)] = v }
      chain_tip_height = chain_tip_height
      fully_scanned_height = fully_scanned_height
      scan_progress = (scan_progress || nil)
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashwalletsummary_new,
                                RustBuffer.alloc_from_MapStringTypeZcashAccountBalance(account_balances), (ZcashBlockHeight._uniffi_lower chain_tip_height), (ZcashBlockHeight._uniffi_lower fully_scanned_height), RustBuffer.alloc_from_OptionalTypeZcashRatio(scan_progress))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end

    def account_balances
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashwalletsummary_account_balances, @pointer)
      result.consumeIntoMapStringTypeZcashAccountBalance
    end

    def chain_tip_height
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashwalletsummary_chain_tip_height, @pointer)
      ZcashBlockHeight._uniffi_allocate(result)
    end

    def fully_scanned_height
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashwalletsummary_fully_scanned_height, @pointer)
      ZcashBlockHeight._uniffi_allocate(result)
    end

    def is_synced
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashwalletsummary_is_synced, @pointer)
      result == 1
    end

    def scan_progress
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashwalletsummary_scan_progress, @pointer)
      result.consumeIntoOptionalTypeZcashRatio
    end
  end

  class ZcashWalletTransparentOutput
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashwallettransparentoutput,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashWalletTransparentOutput instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.from_parts(outpoint, txout, height)
      outpoint = outpoint
      txout = txout
      height = height
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashwallettransparentoutput_from_parts, (ZcashOutPoint._uniffi_lower outpoint), (ZcashTxOut._uniffi_lower txout), (ZcashBlockHeight._uniffi_lower height)))
    end

    def height
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_height, @pointer)
      ZcashBlockHeight._uniffi_allocate(result)
    end

    def outpoint
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_outpoint, @pointer)
      ZcashOutPoint._uniffi_allocate(result)
    end

    def recipient_address
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_recipient_address, @pointer)
      ZcashTransparentAddress._uniffi_allocate(result)
    end

    def txout
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_txout, @pointer)
      ZcashTxOut._uniffi_allocate(result)
    end

    def value
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashwallettransparentoutput_value, @pointer)
      ZcashAmount._uniffi_allocate(result)
    end
  end

  class ZcashWalletTx
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashwallettx,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashWalletTx instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(txid, index, sapling_spends, sapling_outputs)
      txid = txid
      index = Zcash.uniffi_in_range(index, 'u32', 0, 2**32)
      sapling_spends = sapling_spends
      sapling_outputs = sapling_outputs
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashwallettx_new, (ZcashTxId._uniffi_lower txid),
                                index, RustBuffer.alloc_from_SequenceTypeZcashWalletSaplingSpend(sapling_spends), RustBuffer.alloc_from_SequenceTypeZcashWalletSaplingOutput(sapling_outputs))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end

  class ZcashZip317FeeRule
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashzip317feerule,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashZip317FeeRule instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def self.non_standard(marginal_fee, grace_actions, p2pkh_standard_input_size, p2pkh_standard_output_size)
      marginal_fee = marginal_fee
      grace_actions = Zcash.uniffi_in_range(grace_actions, 'u64', 0, 2**64)
      p2pkh_standard_input_size = Zcash.uniffi_in_range(p2pkh_standard_input_size, 'u64', 0, 2**64)
      p2pkh_standard_output_size = Zcash.uniffi_in_range(p2pkh_standard_output_size, 'u64', 0, 2**64)
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,
                                                  :uniffi_uniffi_zcash_fn_constructor_zcashzip317feerule_non_standard, (ZcashAmount._uniffi_lower marginal_fee), grace_actions, p2pkh_standard_input_size, p2pkh_standard_output_size))
    end

    def self.standard
      # Call the (fallible) function before creating any half-baked object instances.
      # Lightly yucky way to bypass the usual "initialize" logic
      # and just create a new instance with the required pointer.
      _uniffi_allocate(Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashzip317feerule_standard))
    end

    def marginal_fee
      result = Zcash.rust_call(:uniffi_uniffi_zcash_fn_method_zcashzip317feerule_marginal_fee, @pointer)
      ZcashAmount._uniffi_allocate(result)
    end
  end

  class ZcashZip317SingleOutputChangeStrategy
    # A private helper for initializing instances of the class from a raw pointer,
    # bypassing any initialization logic and ensuring they are GC'd properly.
    def self._uniffi_allocate(pointer)
      pointer.autorelease = false
      inst = allocate
      inst.instance_variable_set :@pointer, pointer
      ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
      inst
    end

    # A private helper for registering an object finalizer.
    # N.B. it's important that this does not capture a reference
    # to the actual instance, only its underlying pointer.
    def self._uniffi_define_finalizer_by_pointer(pointer, _object_id)
      proc do |_id|
        Zcash.rust_call(
          :uniffi_uniffi_zcash_fn_free_zcashzip317singleoutputchangestrategy,
          pointer
        )
      end
    end

    # A private helper for lowering instances into a raw pointer.
    # This does an explicit typecheck, because accidentally lowering a different type of
    # object in a place where this type is expected, could lead to memory unsafety.
    def self._uniffi_lower(inst)
      raise TypeError, "Expected a ZcashZip317SingleOutputChangeStrategy instance, got #{inst}" unless inst.is_a? self

      inst.instance_variable_get :@pointer
    end

    def initialize(fee_rule)
      fee_rule = fee_rule
      pointer = Zcash.rust_call(:uniffi_uniffi_zcash_fn_constructor_zcashzip317singleoutputchangestrategy_new,
                                (ZcashZip317FeeRule._uniffi_lower fee_rule))
      @pointer = pointer
      ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, object_id))
    end
  end
end
