require 'os' 
# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .rb file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the detils of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Ruby
# helpers directly inline like we're doing here.

require 'ffi'

module Zcash
  class RustBuffer < FFI::Struct
  layout :capacity, :int32,
         :len,      :int32,
         :data,     :pointer

  def self.alloc(size)
    return Zcash.rust_call(:ffi_zcash_e53_rustbuffer_alloc, size)
  end

  def self.reserve(rbuf, additional)
    return Zcash.rust_call(:ffi_zcash_e53_rustbuffer_reserve, rbuf, additional)
  end

  def free
    Zcash.rust_call(:ffi_zcash_e53_rustbuffer_free, self)
  end

  def capacity
    self[:capacity]
  end

  def len
    self[:len]
  end

  def len=(value)
    self[:len] = value
  end

  def data
    self[:data]
  end

  def to_s
    "RustBuffer(capacity=#{capacity}, len=#{len}, data=#{data.read_bytes len})"
  end

  # The allocated buffer will be automatically freed if an error occurs, ensuring that
  # we don't accidentally leak it.
  def self.allocWithBuilder
    builder = RustBufferBuilder.new

    begin
      yield builder
    rescue => e
      builder.discard
      raise e
    end
  end

  # The RustBuffer will be freed once the context-manager exits, ensuring that we don't
  # leak it even if an error occurs.
  def consumeWithStream
    stream = RustBufferStream.new self

    yield stream

    raise RuntimeError, 'junk data left in buffer after consuming' if stream.remaining != 0
  ensure
    free
  end# The primitive String type.

  def self.allocFromString(value)
    RustBuffer.allocWithBuilder do |builder|
      builder.write value.encode('utf-8')
      return builder.finalize
    end
  end

  def consumeIntoString
    consumeWithStream do |stream|
      return stream.read(stream.remaining).force_encoding(Encoding::UTF_8)
    end
  end

  # The Record type ZcashAccountId.

  def self.alloc_from_TypeZcashAccountId(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashAccountId(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashAccountId
    consumeWithStream do |stream|
      return stream.readTypeZcashAccountId
    end
  end

  # The Record type ZcashAuthPath.

  def self.alloc_from_TypeZcashAuthPath(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashAuthPath(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashAuthPath
    consumeWithStream do |stream|
      return stream.readTypeZcashAuthPath
    end
  end

  # The Record type ZcashDiversifierIndexAndPaymentAddress.

  def self.alloc_from_TypeZcashDiversifierIndexAndPaymentAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashDiversifierIndexAndPaymentAddress(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashDiversifierIndexAndPaymentAddress
    consumeWithStream do |stream|
      return stream.readTypeZcashDiversifierIndexAndPaymentAddress
    end
  end

  # The Record type ZcashDiversifierIndexAndScope.

  def self.alloc_from_TypeZcashDiversifierIndexAndScope(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashDiversifierIndexAndScope(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashDiversifierIndexAndScope
    consumeWithStream do |stream|
      return stream.readTypeZcashDiversifierIndexAndScope
    end
  end

  # The Record type ZcashInternalOvkExternalOvk.

  def self.alloc_from_TypeZcashInternalOvkExternalOvk(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashInternalOvkExternalOvk(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashInternalOvkExternalOvk
    consumeWithStream do |stream|
      return stream.readTypeZcashInternalOvkExternalOvk
    end
  end

  # The Record type ZcashOrchardDecryptOutput.

  def self.alloc_from_TypeZcashOrchardDecryptOutput(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashOrchardDecryptOutput(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashOrchardDecryptOutput
    consumeWithStream do |stream|
      return stream.readTypeZcashOrchardDecryptOutput
    end
  end

  # The Record type ZcashOrchardDecryptOutputForIncomingKeys.

  def self.alloc_from_TypeZcashOrchardDecryptOutputForIncomingKeys(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashOrchardDecryptOutputForIncomingKeys(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashOrchardDecryptOutputForIncomingKeys
    consumeWithStream do |stream|
      return stream.readTypeZcashOrchardDecryptOutputForIncomingKeys
    end
  end

  # The Record type ZcashOrchardDecryptOutputForOutgoingKeys.

  def self.alloc_from_TypeZcashOrchardDecryptOutputForOutgoingKeys(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashOrchardDecryptOutputForOutgoingKeys(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashOrchardDecryptOutputForOutgoingKeys
    consumeWithStream do |stream|
      return stream.readTypeZcashOrchardDecryptOutputForOutgoingKeys
    end
  end

  # The Record type ZcashOrchardTransmittedNoteCiphertext.

  def self.alloc_from_TypeZcashOrchardTransmittedNoteCiphertext(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashOrchardTransmittedNoteCiphertext(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashOrchardTransmittedNoteCiphertext
    consumeWithStream do |stream|
      return stream.readTypeZcashOrchardTransmittedNoteCiphertext
    end
  end

  # The Record type ZcashPayment.

  def self.alloc_from_TypeZcashPayment(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashPayment(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashPayment
    consumeWithStream do |stream|
      return stream.readTypeZcashPayment
    end
  end

  # The Record type ZcashPaymentParam.

  def self.alloc_from_TypeZcashPaymentParam(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashPaymentParam(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashPaymentParam
    consumeWithStream do |stream|
      return stream.readTypeZcashPaymentParam
    end
  end

  # The Record type ZcashTransactionAndSaplingMetadata.

  def self.alloc_from_TypeZcashTransactionAndSaplingMetadata(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashTransactionAndSaplingMetadata(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashTransactionAndSaplingMetadata
    consumeWithStream do |stream|
      return stream.readTypeZcashTransactionAndSaplingMetadata
    end
  end

  # The Record type ZcashTransparentAddressAndIndex.

  def self.alloc_from_TypeZcashTransparentAddressAndIndex(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashTransparentAddressAndIndex(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashTransparentAddressAndIndex
    consumeWithStream do |stream|
      return stream.readTypeZcashTransparentAddressAndIndex
    end
  end

  # The Record type ZcashUnifiedAddressAndDiversifierIndex.

  def self.alloc_from_TypeZcashUnifiedAddressAndDiversifierIndex(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashUnifiedAddressAndDiversifierIndex(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashUnifiedAddressAndDiversifierIndex
    consumeWithStream do |stream|
      return stream.readTypeZcashUnifiedAddressAndDiversifierIndex
    end
  end

  # The Enum type ZcashBranchId.

  def self.alloc_from_TypeZcashBranchId(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashBranchId(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashBranchId
    consumeWithStream do |stream|
      return stream.readTypeZcashBranchId
    end
  end

  # The Enum type ZcashChildIndex.

  def self.alloc_from_TypeZcashChildIndex(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashChildIndex(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashChildIndex
    consumeWithStream do |stream|
      return stream.readTypeZcashChildIndex
    end
  end

  # The Enum type ZcashConsensusParameters.

  def self.alloc_from_TypeZcashConsensusParameters(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashConsensusParameters(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashConsensusParameters
    consumeWithStream do |stream|
      return stream.readTypeZcashConsensusParameters
    end
  end

  # The Enum type ZcashFeeRules.

  def self.alloc_from_TypeZcashFeeRules(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashFeeRules(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashFeeRules
    consumeWithStream do |stream|
      return stream.readTypeZcashFeeRules
    end
  end

  # The Enum type ZcashKeySeed.

  def self.alloc_from_TypeZcashKeySeed(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashKeySeed(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashKeySeed
    consumeWithStream do |stream|
      return stream.readTypeZcashKeySeed
    end
  end

  # The Enum type ZcashKeysEra.

  def self.alloc_from_TypeZcashKeysEra(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashKeysEra(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashKeysEra
    consumeWithStream do |stream|
      return stream.readTypeZcashKeysEra
    end
  end

  # The Enum type ZcashOrchardScope.

  def self.alloc_from_TypeZcashOrchardScope(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashOrchardScope(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashOrchardScope
    consumeWithStream do |stream|
      return stream.readTypeZcashOrchardScope
    end
  end

  # The Enum type ZcashRseed.

  def self.alloc_from_TypeZcashRseed(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashRseed(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashRseed
    consumeWithStream do |stream|
      return stream.readTypeZcashRseed
    end
  end

  # The Enum type ZcashScope.

  def self.alloc_from_TypeZcashScope(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashScope(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashScope
    consumeWithStream do |stream|
      return stream.readTypeZcashScope
    end
  end

  # The Enum type ZcashTxVersionSelection.

  def self.alloc_from_TypeZcashTxVersionSelection(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_TypeZcashTxVersionSelection(v)
      return builder.finalize
    end
  end

  def consumeIntoTypeZcashTxVersionSelection
    consumeWithStream do |stream|
      return stream.readTypeZcashTxVersionSelection
    end
  end

  # The Optional<T> type for u64.

  def self.alloc_from_Optionalu64(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalu64(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalu64
    consumeWithStream do |stream|
      return stream.readOptionalu64
    end
  end

  # The Optional<T> type for string.

  def self.alloc_from_Optionalstring(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Optionalstring(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalstring
    consumeWithStream do |stream|
      return stream.readOptionalstring
    end
  end

  # The Optional<T> type for TypeZcashAccountPubKey.

  def self.alloc_from_OptionalTypeZcashAccountPubKey(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashAccountPubKey(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashAccountPubKey
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashAccountPubKey
    end
  end

  # The Optional<T> type for TypeZcashDiversifiableFullViewingKey.

  def self.alloc_from_OptionalTypeZcashDiversifiableFullViewingKey(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashDiversifiableFullViewingKey(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashDiversifiableFullViewingKey
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashDiversifiableFullViewingKey
    end
  end

  # The Optional<T> type for TypeZcashMemoBytes.

  def self.alloc_from_OptionalTypeZcashMemoBytes(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashMemoBytes(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashMemoBytes
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashMemoBytes
    end
  end

  # The Optional<T> type for TypeZcashOrchardAddress.

  def self.alloc_from_OptionalTypeZcashOrchardAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashOrchardAddress(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashOrchardAddress
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashOrchardAddress
    end
  end

  # The Optional<T> type for TypeZcashOrchardBundle.

  def self.alloc_from_OptionalTypeZcashOrchardBundle(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashOrchardBundle(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashOrchardBundle
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashOrchardBundle
    end
  end

  # The Optional<T> type for TypeZcashOrchardDiversifierIndex.

  def self.alloc_from_OptionalTypeZcashOrchardDiversifierIndex(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashOrchardDiversifierIndex(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashOrchardDiversifierIndex
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashOrchardDiversifierIndex
    end
  end

  # The Optional<T> type for TypeZcashOrchardFullViewingKey.

  def self.alloc_from_OptionalTypeZcashOrchardFullViewingKey(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashOrchardFullViewingKey(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashOrchardFullViewingKey
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashOrchardFullViewingKey
    end
  end

  # The Optional<T> type for TypeZcashOrchardOutgoingViewingKey.

  def self.alloc_from_OptionalTypeZcashOrchardOutgoingViewingKey(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashOrchardOutgoingViewingKey(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashOrchardOutgoingViewingKey
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashOrchardOutgoingViewingKey
    end
  end

  # The Optional<T> type for TypeZcashOutgoingViewingKey.

  def self.alloc_from_OptionalTypeZcashOutgoingViewingKey(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashOutgoingViewingKey(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashOutgoingViewingKey
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashOutgoingViewingKey
    end
  end

  # The Optional<T> type for TypeZcashPaymentAddress.

  def self.alloc_from_OptionalTypeZcashPaymentAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashPaymentAddress(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashPaymentAddress
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashPaymentAddress
    end
  end

  # The Optional<T> type for TypeZcashSaplingBundle.

  def self.alloc_from_OptionalTypeZcashSaplingBundle(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashSaplingBundle(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashSaplingBundle
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashSaplingBundle
    end
  end

  # The Optional<T> type for TypeZcashSaplingMerklePath.

  def self.alloc_from_OptionalTypeZcashSaplingMerklePath(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashSaplingMerklePath(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashSaplingMerklePath
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashSaplingMerklePath
    end
  end

  # The Optional<T> type for TypeZcashTransparentAddress.

  def self.alloc_from_OptionalTypeZcashTransparentAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashTransparentAddress(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashTransparentAddress
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashTransparentAddress
    end
  end

  # The Optional<T> type for TypeZcashTransparentBundle.

  def self.alloc_from_OptionalTypeZcashTransparentBundle(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashTransparentBundle(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashTransparentBundle
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashTransparentBundle
    end
  end

  # The Optional<T> type for TypeZcashUnifiedAddress.

  def self.alloc_from_OptionalTypeZcashUnifiedAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashUnifiedAddress(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashUnifiedAddress
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashUnifiedAddress
    end
  end

  # The Optional<T> type for TypeZcashDiversifierIndexAndPaymentAddress.

  def self.alloc_from_OptionalTypeZcashDiversifierIndexAndPaymentAddress(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashDiversifierIndexAndPaymentAddress(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashDiversifierIndexAndPaymentAddress
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashDiversifierIndexAndPaymentAddress
    end
  end

  # The Optional<T> type for TypeZcashDiversifierIndexAndScope.

  def self.alloc_from_OptionalTypeZcashDiversifierIndexAndScope(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashDiversifierIndexAndScope(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashDiversifierIndexAndScope
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashDiversifierIndexAndScope
    end
  end

  # The Optional<T> type for TypeZcashUnifiedAddressAndDiversifierIndex.

  def self.alloc_from_OptionalTypeZcashUnifiedAddressAndDiversifierIndex(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashUnifiedAddressAndDiversifierIndex(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashUnifiedAddressAndDiversifierIndex
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashUnifiedAddressAndDiversifierIndex
    end
  end

  # The Optional<T> type for TypeZcashOrchardScope.

  def self.alloc_from_OptionalTypeZcashOrchardScope(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalTypeZcashOrchardScope(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalTypeZcashOrchardScope
    consumeWithStream do |stream|
      return stream.readOptionalTypeZcashOrchardScope
    end
  end

  # The Optional<T> type for Sequenceu8.

  def self.alloc_from_OptionalSequenceu8(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_OptionalSequenceu8(v)
      return builder.finalize()
    end
  end

  def consumeIntoOptionalSequenceu8
    consumeWithStream do |stream|
      return stream.readOptionalSequenceu8
    end
  end

  # The Sequence<T> type for u8.

  def self.alloc_from_Sequenceu8(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Sequenceu8(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceu8
    consumeWithStream do |stream|
      return stream.readSequenceu8
    end
  end

  # The Sequence<T> type for u32.

  def self.alloc_from_Sequenceu32(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Sequenceu32(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceu32
    consumeWithStream do |stream|
      return stream.readSequenceu32
    end
  end

  # The Sequence<T> type for u64.

  def self.alloc_from_Sequenceu64(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_Sequenceu64(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceu64
    consumeWithStream do |stream|
      return stream.readSequenceu64
    end
  end

  # The Sequence<T> type for TypeZcashOrchardAction.

  def self.alloc_from_SequenceTypeZcashOrchardAction(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashOrchardAction(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashOrchardAction
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashOrchardAction
    end
  end

  # The Sequence<T> type for TypeZcashOrchardIncomingViewingKey.

  def self.alloc_from_SequenceTypeZcashOrchardIncomingViewingKey(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashOrchardIncomingViewingKey(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashOrchardIncomingViewingKey
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashOrchardIncomingViewingKey
    end
  end

  # The Sequence<T> type for TypeZcashOrchardMerkleHash.

  def self.alloc_from_SequenceTypeZcashOrchardMerkleHash(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashOrchardMerkleHash(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashOrchardMerkleHash
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashOrchardMerkleHash
    end
  end

  # The Sequence<T> type for TypeZcashOrchardOutgoingViewingKey.

  def self.alloc_from_SequenceTypeZcashOrchardOutgoingViewingKey(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashOrchardOutgoingViewingKey(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashOrchardOutgoingViewingKey
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashOrchardOutgoingViewingKey
    end
  end

  # The Sequence<T> type for TypeZcashOrchardSpendingKey.

  def self.alloc_from_SequenceTypeZcashOrchardSpendingKey(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashOrchardSpendingKey(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashOrchardSpendingKey
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashOrchardSpendingKey
    end
  end

  # The Sequence<T> type for TypeZcashSaplingOutputDescription.

  def self.alloc_from_SequenceTypeZcashSaplingOutputDescription(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashSaplingOutputDescription(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashSaplingOutputDescription
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashSaplingOutputDescription
    end
  end

  # The Sequence<T> type for TypeZcashSaplingSpendDescription.

  def self.alloc_from_SequenceTypeZcashSaplingSpendDescription(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashSaplingSpendDescription(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashSaplingSpendDescription
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashSaplingSpendDescription
    end
  end

  # The Sequence<T> type for TypeZcashTxIn.

  def self.alloc_from_SequenceTypeZcashTxIn(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashTxIn(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashTxIn
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashTxIn
    end
  end

  # The Sequence<T> type for TypeZcashTxOut.

  def self.alloc_from_SequenceTypeZcashTxOut(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashTxOut(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashTxOut
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashTxOut
    end
  end

  # The Sequence<T> type for TypeZcashAuthPath.

  def self.alloc_from_SequenceTypeZcashAuthPath(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashAuthPath(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashAuthPath
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashAuthPath
    end
  end

  # The Sequence<T> type for TypeZcashOrchardDecryptOutputForIncomingKeys.

  def self.alloc_from_SequenceTypeZcashOrchardDecryptOutputForIncomingKeys(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashOrchardDecryptOutputForIncomingKeys(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashOrchardDecryptOutputForIncomingKeys
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashOrchardDecryptOutputForIncomingKeys
    end
  end

  # The Sequence<T> type for TypeZcashOrchardDecryptOutputForOutgoingKeys.

  def self.alloc_from_SequenceTypeZcashOrchardDecryptOutputForOutgoingKeys(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashOrchardDecryptOutputForOutgoingKeys(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys
    end
  end

  # The Sequence<T> type for TypeZcashPaymentParam.

  def self.alloc_from_SequenceTypeZcashPaymentParam(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashPaymentParam(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashPaymentParam
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashPaymentParam
    end
  end

  # The Sequence<T> type for TypeZcashChildIndex.

  def self.alloc_from_SequenceTypeZcashChildIndex(v)
    RustBuffer.allocWithBuilder do |builder|
      builder.write_SequenceTypeZcashChildIndex(v)
      return builder.finalize()
    end
  end

  def consumeIntoSequenceTypeZcashChildIndex
    consumeWithStream do |stream|
      return stream.readSequenceTypeZcashChildIndex
    end
  end

  
end

module UniFFILib
  class ForeignBytes < FFI::Struct
    layout :len,      :int32,
           :data,     :pointer

    def len
      self[:len]
    end

    def data
      self[:data]
    end

    def to_s
      "ForeignBytes(len=#{len}, data=#{data.read_bytes(len)})"
    end
  end
end

private_constant :UniFFILib
  
# Helper for structured reading of values from a RustBuffer.
class RustBufferStream

  def initialize(rbuf)
    @rbuf = rbuf
    @offset = 0
  end

  def remaining
    @rbuf.len - @offset
  end

  def read(size)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    data = @rbuf.data.get_bytes @offset, size

    @offset += size

    data
  end

  def readU8
    unpack_from 1, 'c'
  end

  def readU32
    unpack_from 4, 'L>'
  end

  def readU64
    unpack_from 8, 'Q>'
  end

  def readI64
    unpack_from 8, 'q>'
  end

  def readBool
    v = unpack_from 1, 'c'

    return false if v == 0
    return true if v == 1

    raise InternalError, 'Unexpected byte for Boolean type'
  end

  def readString
    size = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative string length' if size.negative?

    read(size).force_encoding(Encoding::UTF_8)
  end

  # The Object type SecpSecretKey.

  def readTypeSecpSecretKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return SecpSecretKey._uniffi_allocate(pointer)
  end

  # The Object type TestSupport.

  def readTypeTestSupport
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return TestSupport._uniffi_allocate(pointer)
  end

  # The Object type ZcashAccountPrivKey.

  def readTypeZcashAccountPrivKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashAccountPrivKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashAccountPubKey.

  def readTypeZcashAccountPubKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashAccountPubKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashAmount.

  def readTypeZcashAmount
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashAmount._uniffi_allocate(pointer)
  end

  # The Object type ZcashAnchor.

  def readTypeZcashAnchor
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashAnchor._uniffi_allocate(pointer)
  end

  # The Object type ZcashBlockHeight.

  def readTypeZcashBlockHeight
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashBlockHeight._uniffi_allocate(pointer)
  end

  # The Object type ZcashCommitmentTree.

  def readTypeZcashCommitmentTree
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashCommitmentTree._uniffi_allocate(pointer)
  end

  # The Object type ZcashDiversifiableFullViewingKey.

  def readTypeZcashDiversifiableFullViewingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashDiversifiableFullViewingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashDiversifier.

  def readTypeZcashDiversifier
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashDiversifier._uniffi_allocate(pointer)
  end

  # The Object type ZcashDiversifierIndex.

  def readTypeZcashDiversifierIndex
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashDiversifierIndex._uniffi_allocate(pointer)
  end

  # The Object type ZcashExpandedSpendingKey.

  def readTypeZcashExpandedSpendingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashExpandedSpendingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashExtendedFullViewingKey.

  def readTypeZcashExtendedFullViewingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashExtendedFullViewingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashExtendedPrivKey.

  def readTypeZcashExtendedPrivKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashExtendedPrivKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashExtendedSpendingKey.

  def readTypeZcashExtendedSpendingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashExtendedSpendingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashExternalIvk.

  def readTypeZcashExternalIvk
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashExternalIvk._uniffi_allocate(pointer)
  end

  # The Object type ZcashExternalOvk.

  def readTypeZcashExternalOvk
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashExternalOvk._uniffi_allocate(pointer)
  end

  # The Object type ZcashExtractedNoteCommitment.

  def readTypeZcashExtractedNoteCommitment
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashExtractedNoteCommitment._uniffi_allocate(pointer)
  end

  # The Object type ZcashFixedFeeRule.

  def readTypeZcashFixedFeeRule
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashFixedFeeRule._uniffi_allocate(pointer)
  end

  # The Object type ZcashFullViewingKey.

  def readTypeZcashFullViewingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashFullViewingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashIncrementalWitness.

  def readTypeZcashIncrementalWitness
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashIncrementalWitness._uniffi_allocate(pointer)
  end

  # The Object type ZcashInternalIvk.

  def readTypeZcashInternalIvk
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashInternalIvk._uniffi_allocate(pointer)
  end

  # The Object type ZcashInternalOvk.

  def readTypeZcashInternalOvk
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashInternalOvk._uniffi_allocate(pointer)
  end

  # The Object type ZcashJubjubFr.

  def readTypeZcashJubjubFr
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashJubjubFr._uniffi_allocate(pointer)
  end

  # The Object type ZcashKeyIndex.

  def readTypeZcashKeyIndex
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashKeyIndex._uniffi_allocate(pointer)
  end

  # The Object type ZcashLocalTxProver.

  def readTypeZcashLocalTxProver
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashLocalTxProver._uniffi_allocate(pointer)
  end

  # The Object type ZcashMemoBytes.

  def readTypeZcashMemoBytes
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashMemoBytes._uniffi_allocate(pointer)
  end

  # The Object type ZcashNullifierDerivingKey.

  def readTypeZcashNullifierDerivingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashNullifierDerivingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardAction.

  def readTypeZcashOrchardAction
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardAction._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardAddress.

  def readTypeZcashOrchardAddress
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardAddress._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardBundle.

  def readTypeZcashOrchardBundle
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardBundle._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardDiversifier.

  def readTypeZcashOrchardDiversifier
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardDiversifier._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardDiversifierIndex.

  def readTypeZcashOrchardDiversifierIndex
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardDiversifierIndex._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardFlags.

  def readTypeZcashOrchardFlags
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardFlags._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardFullViewingKey.

  def readTypeZcashOrchardFullViewingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardFullViewingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardIncomingViewingKey.

  def readTypeZcashOrchardIncomingViewingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardIncomingViewingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardMerkleHash.

  def readTypeZcashOrchardMerkleHash
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardMerkleHash._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardMerklePath.

  def readTypeZcashOrchardMerklePath
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardMerklePath._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardNote.

  def readTypeZcashOrchardNote
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardNote._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardNoteCommitment.

  def readTypeZcashOrchardNoteCommitment
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardNoteCommitment._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardNoteValue.

  def readTypeZcashOrchardNoteValue
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardNoteValue._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardNullifier.

  def readTypeZcashOrchardNullifier
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardNullifier._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardOutgoingViewingKey.

  def readTypeZcashOrchardOutgoingViewingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardOutgoingViewingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardRandomSeed.

  def readTypeZcashOrchardRandomSeed
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardRandomSeed._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardSpendingKey.

  def readTypeZcashOrchardSpendingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardSpendingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardTransactionBuilder.

  def readTypeZcashOrchardTransactionBuilder
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardTransactionBuilder._uniffi_allocate(pointer)
  end

  # The Object type ZcashOrchardValueCommitment.

  def readTypeZcashOrchardValueCommitment
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOrchardValueCommitment._uniffi_allocate(pointer)
  end

  # The Object type ZcashOutPoint.

  def readTypeZcashOutPoint
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOutPoint._uniffi_allocate(pointer)
  end

  # The Object type ZcashOutgoingViewingKey.

  def readTypeZcashOutgoingViewingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashOutgoingViewingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashPaymentAddress.

  def readTypeZcashPaymentAddress
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashPaymentAddress._uniffi_allocate(pointer)
  end

  # The Object type ZcashProofGenerationKey.

  def readTypeZcashProofGenerationKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashProofGenerationKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashProvingKey.

  def readTypeZcashProvingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashProvingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashRecipientAddress.

  def readTypeZcashRecipientAddress
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashRecipientAddress._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingBundle.

  def readTypeZcashSaplingBundle
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingBundle._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingDiversifiedTransmissionKey.

  def readTypeZcashSaplingDiversifiedTransmissionKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingDiversifiedTransmissionKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingExtractedNoteCommitment.

  def readTypeZcashSaplingExtractedNoteCommitment
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingExtractedNoteCommitment._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingIvk.

  def readTypeZcashSaplingIvk
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingIvk._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingMerklePath.

  def readTypeZcashSaplingMerklePath
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingMerklePath._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingMetadata.

  def readTypeZcashSaplingMetadata
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingMetadata._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingNode.

  def readTypeZcashSaplingNode
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingNode._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingNote.

  def readTypeZcashSaplingNote
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingNote._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingNoteValue.

  def readTypeZcashSaplingNoteValue
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingNoteValue._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingNullifier.

  def readTypeZcashSaplingNullifier
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingNullifier._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingOutputDescription.

  def readTypeZcashSaplingOutputDescription
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingOutputDescription._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingPublicKey.

  def readTypeZcashSaplingPublicKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingPublicKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingSpendDescription.

  def readTypeZcashSaplingSpendDescription
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingSpendDescription._uniffi_allocate(pointer)
  end

  # The Object type ZcashSaplingValueCommitment.

  def readTypeZcashSaplingValueCommitment
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashSaplingValueCommitment._uniffi_allocate(pointer)
  end

  # The Object type ZcashScript.

  def readTypeZcashScript
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashScript._uniffi_allocate(pointer)
  end

  # The Object type ZcashTransaction.

  def readTypeZcashTransaction
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashTransaction._uniffi_allocate(pointer)
  end

  # The Object type ZcashTransactionBuilder.

  def readTypeZcashTransactionBuilder
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashTransactionBuilder._uniffi_allocate(pointer)
  end

  # The Object type ZcashTransparentAddress.

  def readTypeZcashTransparentAddress
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashTransparentAddress._uniffi_allocate(pointer)
  end

  # The Object type ZcashTransparentBundle.

  def readTypeZcashTransparentBundle
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashTransparentBundle._uniffi_allocate(pointer)
  end

  # The Object type ZcashTxId.

  def readTypeZcashTxId
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashTxId._uniffi_allocate(pointer)
  end

  # The Object type ZcashTxIn.

  def readTypeZcashTxIn
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashTxIn._uniffi_allocate(pointer)
  end

  # The Object type ZcashTxOut.

  def readTypeZcashTxOut
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashTxOut._uniffi_allocate(pointer)
  end

  # The Object type ZcashTxVersion.

  def readTypeZcashTxVersion
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashTxVersion._uniffi_allocate(pointer)
  end

  # The Object type ZcashUnifiedAddress.

  def readTypeZcashUnifiedAddress
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashUnifiedAddress._uniffi_allocate(pointer)
  end

  # The Object type ZcashUnifiedFullViewingKey.

  def readTypeZcashUnifiedFullViewingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashUnifiedFullViewingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashUnifiedSpendingKey.

  def readTypeZcashUnifiedSpendingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashUnifiedSpendingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashVerifyingKey.

  def readTypeZcashVerifyingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashVerifyingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashViewingKey.

  def readTypeZcashViewingKey
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashViewingKey._uniffi_allocate(pointer)
  end

  # The Object type ZcashZip317FeeRule.

  def readTypeZcashZip317FeeRule
    pointer = FFI::Pointer.new unpack_from 8, 'Q>'
    return ZcashZip317FeeRule._uniffi_allocate(pointer)
  end

  # The Record type ZcashAccountId.

  def readTypeZcashAccountId
    ZcashAccountId.new(
      readU32
    )
  end

  # The Record type ZcashAuthPath.

  def readTypeZcashAuthPath
    ZcashAuthPath.new(
      readTypeZcashSaplingNode,
      readBool
    )
  end

  # The Record type ZcashDiversifierIndexAndPaymentAddress.

  def readTypeZcashDiversifierIndexAndPaymentAddress
    ZcashDiversifierIndexAndPaymentAddress.new(
      readTypeZcashDiversifierIndex,
      readTypeZcashPaymentAddress
    )
  end

  # The Record type ZcashDiversifierIndexAndScope.

  def readTypeZcashDiversifierIndexAndScope
    ZcashDiversifierIndexAndScope.new(
      readTypeZcashDiversifierIndex,
      readTypeZcashScope
    )
  end

  # The Record type ZcashInternalOvkExternalOvk.

  def readTypeZcashInternalOvkExternalOvk
    ZcashInternalOvkExternalOvk.new(
      readTypeZcashInternalOvk,
      readTypeZcashExternalOvk
    )
  end

  # The Record type ZcashOrchardDecryptOutput.

  def readTypeZcashOrchardDecryptOutput
    ZcashOrchardDecryptOutput.new(
      readTypeZcashOrchardNote,
      readTypeZcashOrchardAddress,
      readSequenceu8
    )
  end

  # The Record type ZcashOrchardDecryptOutputForIncomingKeys.

  def readTypeZcashOrchardDecryptOutputForIncomingKeys
    ZcashOrchardDecryptOutputForIncomingKeys.new(
      readU64,
      readTypeZcashOrchardIncomingViewingKey,
      readTypeZcashOrchardNote,
      readTypeZcashOrchardAddress,
      readSequenceu8
    )
  end

  # The Record type ZcashOrchardDecryptOutputForOutgoingKeys.

  def readTypeZcashOrchardDecryptOutputForOutgoingKeys
    ZcashOrchardDecryptOutputForOutgoingKeys.new(
      readU64,
      readTypeZcashOrchardOutgoingViewingKey,
      readTypeZcashOrchardNote,
      readTypeZcashOrchardAddress,
      readSequenceu8
    )
  end

  # The Record type ZcashOrchardTransmittedNoteCiphertext.

  def readTypeZcashOrchardTransmittedNoteCiphertext
    ZcashOrchardTransmittedNoteCiphertext.new(
      readSequenceu8,
      readSequenceu8,
      readSequenceu8
    )
  end

  # The Record type ZcashPayment.

  def readTypeZcashPayment
    ZcashPayment.new(
      readTypeZcashRecipientAddress,
      readI64,
      readOptionalTypeZcashMemoBytes,
      readOptionalstring,
      readOptionalstring,
      readSequenceTypeZcashPaymentParam
    )
  end

  # The Record type ZcashPaymentParam.

  def readTypeZcashPaymentParam
    ZcashPaymentParam.new(
      readString,
      readString
    )
  end

  # The Record type ZcashTransactionAndSaplingMetadata.

  def readTypeZcashTransactionAndSaplingMetadata
    ZcashTransactionAndSaplingMetadata.new(
      readTypeZcashTransaction,
      readTypeZcashSaplingMetadata
    )
  end

  # The Record type ZcashTransparentAddressAndIndex.

  def readTypeZcashTransparentAddressAndIndex
    ZcashTransparentAddressAndIndex.new(
      readTypeZcashTransparentAddress,
      readU32
    )
  end

  # The Record type ZcashUnifiedAddressAndDiversifierIndex.

  def readTypeZcashUnifiedAddressAndDiversifierIndex
    ZcashUnifiedAddressAndDiversifierIndex.new(
      readTypeZcashUnifiedAddress,
      readTypeZcashDiversifierIndex
    )
  end

  # The Enum type ZcashBranchId.

  def readTypeZcashBranchId
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return ZcashBranchId::SPROUT
    end
    if variant == 2
      return ZcashBranchId::OVERWINTER
    end
    if variant == 3
      return ZcashBranchId::SAPLING
    end
    if variant == 4
      return ZcashBranchId::BLOSSOM
    end
    if variant == 5
      return ZcashBranchId::HEARTWOOD
    end
    if variant == 6
      return ZcashBranchId::CANOPY
    end
    if variant == 7
      return ZcashBranchId::NU5
    end

    raise InternalError, 'Unexpected variant tag for TypeZcashBranchId'
  end

  # The Enum type ZcashChildIndex.

  def readTypeZcashChildIndex
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return ZcashChildIndex::NON_HARDENED.new(
            self.readU32()
        )
    end
    if variant == 2
        return ZcashChildIndex::HARDENED.new(
            self.readU32()
        )
    end
    raise InternalError, 'Unexpected variant tag for TypeZcashChildIndex'
  end

  # The Enum type ZcashConsensusParameters.

  def readTypeZcashConsensusParameters
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return ZcashConsensusParameters::MAIN_NETWORK
    end
    if variant == 2
      return ZcashConsensusParameters::TEST_NETWORK
    end

    raise InternalError, 'Unexpected variant tag for TypeZcashConsensusParameters'
  end

  # The Enum type ZcashFeeRules.

  def readTypeZcashFeeRules
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return ZcashFeeRules::FIXED_STANDARD.new
        
    end
    if variant == 2
        return ZcashFeeRules::FIXED_NON_STANDARD.new(
            self.readU64()
        )
    end
    if variant == 3
        return ZcashFeeRules::ZIP317_STANDARD.new
        
    end
    if variant == 4
        return ZcashFeeRules::ZIP317_NON_STANDARD.new(
            self.readU64(),
            self.readU64(),
            self.readU64(),
            self.readU64()
        )
    end
    raise InternalError, 'Unexpected variant tag for TypeZcashFeeRules'
  end

  # The Enum type ZcashKeySeed.

  def readTypeZcashKeySeed
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return ZcashKeySeed::S128
    end
    if variant == 2
      return ZcashKeySeed::S256
    end
    if variant == 3
      return ZcashKeySeed::S512
    end

    raise InternalError, 'Unexpected variant tag for TypeZcashKeySeed'
  end

  # The Enum type ZcashKeysEra.

  def readTypeZcashKeysEra
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return ZcashKeysEra::ORCHARD
    end

    raise InternalError, 'Unexpected variant tag for TypeZcashKeysEra'
  end

  # The Enum type ZcashOrchardScope.

  def readTypeZcashOrchardScope
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return ZcashOrchardScope::EXTERNAL
    end
    if variant == 2
      return ZcashOrchardScope::INTERNAL
    end

    raise InternalError, 'Unexpected variant tag for TypeZcashOrchardScope'
  end

  # The Enum type ZcashRseed.

  def readTypeZcashRseed
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return ZcashRseed::BEFORE_ZIP212.new(
            self.readSequenceu8()
        )
    end
    if variant == 2
        return ZcashRseed::AFTER_ZIP212.new(
            self.readSequenceu8()
        )
    end
    raise InternalError, 'Unexpected variant tag for TypeZcashRseed'
  end

  # The Enum type ZcashScope.

  def readTypeZcashScope
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return ZcashScope::EXTERNAL
    end
    if variant == 2
      return ZcashScope::INTERNAL
    end

    raise InternalError, 'Unexpected variant tag for TypeZcashScope'
  end

  # The Enum type ZcashTxVersionSelection.

  def readTypeZcashTxVersionSelection
    variant = unpack_from 4, 'l>'
    
    if variant == 1
        return ZcashTxVersionSelection::SPROUT.new(
            self.readU32()
        )
    end
    if variant == 2
        return ZcashTxVersionSelection::OVERWINTER.new
        
    end
    if variant == 3
        return ZcashTxVersionSelection::SAPLING.new
        
    end
    if variant == 4
        return ZcashTxVersionSelection::ZIP225.new
        
    end
    raise InternalError, 'Unexpected variant tag for TypeZcashTxVersionSelection'
  end

  

  # The Error type ZcashError

  def readTypeZcashError
    variant = unpack_from 4, 'l>'
    
    if variant == 1
      return ZcashError::HdWalletError.new(
        readString()
      )
    end
    if variant == 2
      return ZcashError::DecodingError.new(
        readString()
      )
    end
    if variant == 3
      return ZcashError::DerivationError.new(
        readString()
      )
    end
    if variant == 4
      return ZcashError::InvalidAsk.new(
        readString()
      )
    end
    if variant == 5
      return ZcashError::InvalidNsk.new(
        readString()
      )
    end
    if variant == 6
      return ZcashError::Message.new(
        readString()
      )
    end
    if variant == 7
      return ZcashError::ArrayLengthMismatch.new(
        readString()
      )
    end
    if variant == 8
      return ZcashError::ValueOutOfRange.new(
        readString()
      )
    end
    if variant == 9
      return ZcashError::Secp256k1Error.new(
        readString()
      )
    end
    if variant == 10
      return ZcashError::Bech32DecodeError.new(
        readString()
      )
    end
    if variant == 11
      return ZcashError::Bs58Error.new(
        readString()
      )
    end
    if variant == 12
      return ZcashError::BuilderError.new(
        readString()
      )
    end
    if variant == 13
      return ZcashError::TransparentBuilderError.new(
        readString()
      )
    end
    if variant == 14
      return ZcashError::SaplingBuilderError.new(
        readString()
      )
    end
    if variant == 15
      return ZcashError::OrchardBuilderError.new(
        readString()
      )
    end
    if variant == 16
      return ZcashError::InsufficientFundsError.new(
        readString()
      )
    end
    if variant == 17
      return ZcashError::ChangeRequiredError.new(
        readString()
      )
    end
    if variant == 18
      return ZcashError::BalanceError.new(
        readString()
      )
    end
    if variant == 19
      return ZcashError::IoError.new(
        readString()
      )
    end
    if variant == 20
      return ZcashError::Unknown.new(
        readString()
      )
    end

    raise InternalError, 'Unexpected variant tag for TypeZcashError'
  end

  # The Optional<T> type for u64.

  def readOptionalu64
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readU64
    else
      raise InternalError, 'Unexpected flag byte for Optionalu64'
    end
  end

  # The Optional<T> type for string.

  def readOptionalstring
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readString
    else
      raise InternalError, 'Unexpected flag byte for Optionalstring'
    end
  end

  # The Optional<T> type for TypeZcashAccountPubKey.

  def readOptionalTypeZcashAccountPubKey
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashAccountPubKey
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashAccountPubKey'
    end
  end

  # The Optional<T> type for TypeZcashDiversifiableFullViewingKey.

  def readOptionalTypeZcashDiversifiableFullViewingKey
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashDiversifiableFullViewingKey
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashDiversifiableFullViewingKey'
    end
  end

  # The Optional<T> type for TypeZcashMemoBytes.

  def readOptionalTypeZcashMemoBytes
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashMemoBytes
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashMemoBytes'
    end
  end

  # The Optional<T> type for TypeZcashOrchardAddress.

  def readOptionalTypeZcashOrchardAddress
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashOrchardAddress
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardAddress'
    end
  end

  # The Optional<T> type for TypeZcashOrchardBundle.

  def readOptionalTypeZcashOrchardBundle
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashOrchardBundle
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardBundle'
    end
  end

  # The Optional<T> type for TypeZcashOrchardDiversifierIndex.

  def readOptionalTypeZcashOrchardDiversifierIndex
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashOrchardDiversifierIndex
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardDiversifierIndex'
    end
  end

  # The Optional<T> type for TypeZcashOrchardFullViewingKey.

  def readOptionalTypeZcashOrchardFullViewingKey
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashOrchardFullViewingKey
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardFullViewingKey'
    end
  end

  # The Optional<T> type for TypeZcashOrchardOutgoingViewingKey.

  def readOptionalTypeZcashOrchardOutgoingViewingKey
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashOrchardOutgoingViewingKey
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardOutgoingViewingKey'
    end
  end

  # The Optional<T> type for TypeZcashOutgoingViewingKey.

  def readOptionalTypeZcashOutgoingViewingKey
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashOutgoingViewingKey
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOutgoingViewingKey'
    end
  end

  # The Optional<T> type for TypeZcashPaymentAddress.

  def readOptionalTypeZcashPaymentAddress
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashPaymentAddress
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashPaymentAddress'
    end
  end

  # The Optional<T> type for TypeZcashSaplingBundle.

  def readOptionalTypeZcashSaplingBundle
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashSaplingBundle
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashSaplingBundle'
    end
  end

  # The Optional<T> type for TypeZcashSaplingMerklePath.

  def readOptionalTypeZcashSaplingMerklePath
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashSaplingMerklePath
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashSaplingMerklePath'
    end
  end

  # The Optional<T> type for TypeZcashTransparentAddress.

  def readOptionalTypeZcashTransparentAddress
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashTransparentAddress
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashTransparentAddress'
    end
  end

  # The Optional<T> type for TypeZcashTransparentBundle.

  def readOptionalTypeZcashTransparentBundle
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashTransparentBundle
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashTransparentBundle'
    end
  end

  # The Optional<T> type for TypeZcashUnifiedAddress.

  def readOptionalTypeZcashUnifiedAddress
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashUnifiedAddress
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashUnifiedAddress'
    end
  end

  # The Optional<T> type for TypeZcashDiversifierIndexAndPaymentAddress.

  def readOptionalTypeZcashDiversifierIndexAndPaymentAddress
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashDiversifierIndexAndPaymentAddress
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashDiversifierIndexAndPaymentAddress'
    end
  end

  # The Optional<T> type for TypeZcashDiversifierIndexAndScope.

  def readOptionalTypeZcashDiversifierIndexAndScope
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashDiversifierIndexAndScope
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashDiversifierIndexAndScope'
    end
  end

  # The Optional<T> type for TypeZcashUnifiedAddressAndDiversifierIndex.

  def readOptionalTypeZcashUnifiedAddressAndDiversifierIndex
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashUnifiedAddressAndDiversifierIndex
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashUnifiedAddressAndDiversifierIndex'
    end
  end

  # The Optional<T> type for TypeZcashOrchardScope.

  def readOptionalTypeZcashOrchardScope
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readTypeZcashOrchardScope
    else
      raise InternalError, 'Unexpected flag byte for OptionalTypeZcashOrchardScope'
    end
  end

  # The Optional<T> type for Sequenceu8.

  def readOptionalSequenceu8
    flag = unpack_from 1, 'c'

    if flag == 0
      return nil
    elsif flag == 1
      return readSequenceu8
    else
      raise InternalError, 'Unexpected flag byte for OptionalSequenceu8'
    end
  end

  # The Sequence<T> type for u8.

  def readSequenceu8
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readU8
    end

    items
  end

  # The Sequence<T> type for u32.

  def readSequenceu32
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readU32
    end

    items
  end

  # The Sequence<T> type for u64.

  def readSequenceu64
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readU64
    end

    items
  end

  # The Sequence<T> type for TypeZcashOrchardAction.

  def readSequenceTypeZcashOrchardAction
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashOrchardAction
    end

    items
  end

  # The Sequence<T> type for TypeZcashOrchardIncomingViewingKey.

  def readSequenceTypeZcashOrchardIncomingViewingKey
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashOrchardIncomingViewingKey
    end

    items
  end

  # The Sequence<T> type for TypeZcashOrchardMerkleHash.

  def readSequenceTypeZcashOrchardMerkleHash
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashOrchardMerkleHash
    end

    items
  end

  # The Sequence<T> type for TypeZcashOrchardOutgoingViewingKey.

  def readSequenceTypeZcashOrchardOutgoingViewingKey
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashOrchardOutgoingViewingKey
    end

    items
  end

  # The Sequence<T> type for TypeZcashOrchardSpendingKey.

  def readSequenceTypeZcashOrchardSpendingKey
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashOrchardSpendingKey
    end

    items
  end

  # The Sequence<T> type for TypeZcashSaplingOutputDescription.

  def readSequenceTypeZcashSaplingOutputDescription
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashSaplingOutputDescription
    end

    items
  end

  # The Sequence<T> type for TypeZcashSaplingSpendDescription.

  def readSequenceTypeZcashSaplingSpendDescription
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashSaplingSpendDescription
    end

    items
  end

  # The Sequence<T> type for TypeZcashTxIn.

  def readSequenceTypeZcashTxIn
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashTxIn
    end

    items
  end

  # The Sequence<T> type for TypeZcashTxOut.

  def readSequenceTypeZcashTxOut
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashTxOut
    end

    items
  end

  # The Sequence<T> type for TypeZcashAuthPath.

  def readSequenceTypeZcashAuthPath
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashAuthPath
    end

    items
  end

  # The Sequence<T> type for TypeZcashOrchardDecryptOutputForIncomingKeys.

  def readSequenceTypeZcashOrchardDecryptOutputForIncomingKeys
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashOrchardDecryptOutputForIncomingKeys
    end

    items
  end

  # The Sequence<T> type for TypeZcashOrchardDecryptOutputForOutgoingKeys.

  def readSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashOrchardDecryptOutputForOutgoingKeys
    end

    items
  end

  # The Sequence<T> type for TypeZcashPaymentParam.

  def readSequenceTypeZcashPaymentParam
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashPaymentParam
    end

    items
  end

  # The Sequence<T> type for TypeZcashChildIndex.

  def readSequenceTypeZcashChildIndex
    count = unpack_from 4, 'l>'

    raise InternalError, 'Unexpected negative sequence length' if count.negative?

    items = []

    count.times do
      items.append readTypeZcashChildIndex
    end

    items
  end

  

  def unpack_from(size, format)
    raise InternalError, 'read past end of rust buffer' if @offset + size > @rbuf.len

    value = @rbuf.data.get_bytes(@offset, size).unpack format

    @offset += size

    # TODO: verify this
    raise 'more than one element!!!' if value.size > 1

    value[0]
  end
end

private_constant :RustBufferStream
  
# Helper for structured writing of values into a RustBuffer.
class RustBufferBuilder
  def initialize
    @rust_buf = RustBuffer.alloc 16
    @rust_buf.len = 0
  end

  def finalize
    rbuf = @rust_buf

    @rust_buf = nil

    rbuf
  end

  def discard
    return if @rust_buf.nil?

    rbuf = finalize
    rbuf.free
  end

  def write(value)
    reserve(value.bytes.size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, value.bytes
    end
  end

  def write_U8(v)
    pack_into(1, 'c', v)
  end

  def write_U32(v)
    pack_into(4, 'L>', v)
  end

  def write_U64(v)
    pack_into(8, 'Q>', v)
  end

  def write_I64(v)
    pack_into(8, 'q>', v)
  end

  def write_Bool(v)
    pack_into(1, 'c', v ? 1 : 0)
  end

  def write_String(v)
    v = v.to_s
    pack_into 4, 'l>', v.bytes.size
    write v
  end

  # The Object type SecpSecretKey.

  def write_TypeSecpSecretKey(obj)
    pointer = SecpSecretKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type TestSupport.

  def write_TypeTestSupport(obj)
    pointer = TestSupport._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashAccountPrivKey.

  def write_TypeZcashAccountPrivKey(obj)
    pointer = ZcashAccountPrivKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashAccountPubKey.

  def write_TypeZcashAccountPubKey(obj)
    pointer = ZcashAccountPubKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashAmount.

  def write_TypeZcashAmount(obj)
    pointer = ZcashAmount._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashAnchor.

  def write_TypeZcashAnchor(obj)
    pointer = ZcashAnchor._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashBlockHeight.

  def write_TypeZcashBlockHeight(obj)
    pointer = ZcashBlockHeight._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashCommitmentTree.

  def write_TypeZcashCommitmentTree(obj)
    pointer = ZcashCommitmentTree._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashDiversifiableFullViewingKey.

  def write_TypeZcashDiversifiableFullViewingKey(obj)
    pointer = ZcashDiversifiableFullViewingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashDiversifier.

  def write_TypeZcashDiversifier(obj)
    pointer = ZcashDiversifier._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashDiversifierIndex.

  def write_TypeZcashDiversifierIndex(obj)
    pointer = ZcashDiversifierIndex._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashExpandedSpendingKey.

  def write_TypeZcashExpandedSpendingKey(obj)
    pointer = ZcashExpandedSpendingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashExtendedFullViewingKey.

  def write_TypeZcashExtendedFullViewingKey(obj)
    pointer = ZcashExtendedFullViewingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashExtendedPrivKey.

  def write_TypeZcashExtendedPrivKey(obj)
    pointer = ZcashExtendedPrivKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashExtendedSpendingKey.

  def write_TypeZcashExtendedSpendingKey(obj)
    pointer = ZcashExtendedSpendingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashExternalIvk.

  def write_TypeZcashExternalIvk(obj)
    pointer = ZcashExternalIvk._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashExternalOvk.

  def write_TypeZcashExternalOvk(obj)
    pointer = ZcashExternalOvk._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashExtractedNoteCommitment.

  def write_TypeZcashExtractedNoteCommitment(obj)
    pointer = ZcashExtractedNoteCommitment._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashFixedFeeRule.

  def write_TypeZcashFixedFeeRule(obj)
    pointer = ZcashFixedFeeRule._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashFullViewingKey.

  def write_TypeZcashFullViewingKey(obj)
    pointer = ZcashFullViewingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashIncrementalWitness.

  def write_TypeZcashIncrementalWitness(obj)
    pointer = ZcashIncrementalWitness._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashInternalIvk.

  def write_TypeZcashInternalIvk(obj)
    pointer = ZcashInternalIvk._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashInternalOvk.

  def write_TypeZcashInternalOvk(obj)
    pointer = ZcashInternalOvk._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashJubjubFr.

  def write_TypeZcashJubjubFr(obj)
    pointer = ZcashJubjubFr._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashKeyIndex.

  def write_TypeZcashKeyIndex(obj)
    pointer = ZcashKeyIndex._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashLocalTxProver.

  def write_TypeZcashLocalTxProver(obj)
    pointer = ZcashLocalTxProver._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashMemoBytes.

  def write_TypeZcashMemoBytes(obj)
    pointer = ZcashMemoBytes._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashNullifierDerivingKey.

  def write_TypeZcashNullifierDerivingKey(obj)
    pointer = ZcashNullifierDerivingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardAction.

  def write_TypeZcashOrchardAction(obj)
    pointer = ZcashOrchardAction._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardAddress.

  def write_TypeZcashOrchardAddress(obj)
    pointer = ZcashOrchardAddress._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardBundle.

  def write_TypeZcashOrchardBundle(obj)
    pointer = ZcashOrchardBundle._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardDiversifier.

  def write_TypeZcashOrchardDiversifier(obj)
    pointer = ZcashOrchardDiversifier._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardDiversifierIndex.

  def write_TypeZcashOrchardDiversifierIndex(obj)
    pointer = ZcashOrchardDiversifierIndex._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardFlags.

  def write_TypeZcashOrchardFlags(obj)
    pointer = ZcashOrchardFlags._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardFullViewingKey.

  def write_TypeZcashOrchardFullViewingKey(obj)
    pointer = ZcashOrchardFullViewingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardIncomingViewingKey.

  def write_TypeZcashOrchardIncomingViewingKey(obj)
    pointer = ZcashOrchardIncomingViewingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardMerkleHash.

  def write_TypeZcashOrchardMerkleHash(obj)
    pointer = ZcashOrchardMerkleHash._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardMerklePath.

  def write_TypeZcashOrchardMerklePath(obj)
    pointer = ZcashOrchardMerklePath._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardNote.

  def write_TypeZcashOrchardNote(obj)
    pointer = ZcashOrchardNote._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardNoteCommitment.

  def write_TypeZcashOrchardNoteCommitment(obj)
    pointer = ZcashOrchardNoteCommitment._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardNoteValue.

  def write_TypeZcashOrchardNoteValue(obj)
    pointer = ZcashOrchardNoteValue._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardNullifier.

  def write_TypeZcashOrchardNullifier(obj)
    pointer = ZcashOrchardNullifier._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardOutgoingViewingKey.

  def write_TypeZcashOrchardOutgoingViewingKey(obj)
    pointer = ZcashOrchardOutgoingViewingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardRandomSeed.

  def write_TypeZcashOrchardRandomSeed(obj)
    pointer = ZcashOrchardRandomSeed._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardSpendingKey.

  def write_TypeZcashOrchardSpendingKey(obj)
    pointer = ZcashOrchardSpendingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardTransactionBuilder.

  def write_TypeZcashOrchardTransactionBuilder(obj)
    pointer = ZcashOrchardTransactionBuilder._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOrchardValueCommitment.

  def write_TypeZcashOrchardValueCommitment(obj)
    pointer = ZcashOrchardValueCommitment._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOutPoint.

  def write_TypeZcashOutPoint(obj)
    pointer = ZcashOutPoint._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashOutgoingViewingKey.

  def write_TypeZcashOutgoingViewingKey(obj)
    pointer = ZcashOutgoingViewingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashPaymentAddress.

  def write_TypeZcashPaymentAddress(obj)
    pointer = ZcashPaymentAddress._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashProofGenerationKey.

  def write_TypeZcashProofGenerationKey(obj)
    pointer = ZcashProofGenerationKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashProvingKey.

  def write_TypeZcashProvingKey(obj)
    pointer = ZcashProvingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashRecipientAddress.

  def write_TypeZcashRecipientAddress(obj)
    pointer = ZcashRecipientAddress._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingBundle.

  def write_TypeZcashSaplingBundle(obj)
    pointer = ZcashSaplingBundle._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingDiversifiedTransmissionKey.

  def write_TypeZcashSaplingDiversifiedTransmissionKey(obj)
    pointer = ZcashSaplingDiversifiedTransmissionKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingExtractedNoteCommitment.

  def write_TypeZcashSaplingExtractedNoteCommitment(obj)
    pointer = ZcashSaplingExtractedNoteCommitment._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingIvk.

  def write_TypeZcashSaplingIvk(obj)
    pointer = ZcashSaplingIvk._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingMerklePath.

  def write_TypeZcashSaplingMerklePath(obj)
    pointer = ZcashSaplingMerklePath._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingMetadata.

  def write_TypeZcashSaplingMetadata(obj)
    pointer = ZcashSaplingMetadata._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingNode.

  def write_TypeZcashSaplingNode(obj)
    pointer = ZcashSaplingNode._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingNote.

  def write_TypeZcashSaplingNote(obj)
    pointer = ZcashSaplingNote._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingNoteValue.

  def write_TypeZcashSaplingNoteValue(obj)
    pointer = ZcashSaplingNoteValue._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingNullifier.

  def write_TypeZcashSaplingNullifier(obj)
    pointer = ZcashSaplingNullifier._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingOutputDescription.

  def write_TypeZcashSaplingOutputDescription(obj)
    pointer = ZcashSaplingOutputDescription._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingPublicKey.

  def write_TypeZcashSaplingPublicKey(obj)
    pointer = ZcashSaplingPublicKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingSpendDescription.

  def write_TypeZcashSaplingSpendDescription(obj)
    pointer = ZcashSaplingSpendDescription._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashSaplingValueCommitment.

  def write_TypeZcashSaplingValueCommitment(obj)
    pointer = ZcashSaplingValueCommitment._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashScript.

  def write_TypeZcashScript(obj)
    pointer = ZcashScript._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashTransaction.

  def write_TypeZcashTransaction(obj)
    pointer = ZcashTransaction._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashTransactionBuilder.

  def write_TypeZcashTransactionBuilder(obj)
    pointer = ZcashTransactionBuilder._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashTransparentAddress.

  def write_TypeZcashTransparentAddress(obj)
    pointer = ZcashTransparentAddress._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashTransparentBundle.

  def write_TypeZcashTransparentBundle(obj)
    pointer = ZcashTransparentBundle._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashTxId.

  def write_TypeZcashTxId(obj)
    pointer = ZcashTxId._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashTxIn.

  def write_TypeZcashTxIn(obj)
    pointer = ZcashTxIn._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashTxOut.

  def write_TypeZcashTxOut(obj)
    pointer = ZcashTxOut._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashTxVersion.

  def write_TypeZcashTxVersion(obj)
    pointer = ZcashTxVersion._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashUnifiedAddress.

  def write_TypeZcashUnifiedAddress(obj)
    pointer = ZcashUnifiedAddress._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashUnifiedFullViewingKey.

  def write_TypeZcashUnifiedFullViewingKey(obj)
    pointer = ZcashUnifiedFullViewingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashUnifiedSpendingKey.

  def write_TypeZcashUnifiedSpendingKey(obj)
    pointer = ZcashUnifiedSpendingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashVerifyingKey.

  def write_TypeZcashVerifyingKey(obj)
    pointer = ZcashVerifyingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashViewingKey.

  def write_TypeZcashViewingKey(obj)
    pointer = ZcashViewingKey._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Object type ZcashZip317FeeRule.

  def write_TypeZcashZip317FeeRule(obj)
    pointer = ZcashZip317FeeRule._uniffi_lower obj
    pack_into(8, 'Q>', pointer.address)
  end

  # The Record type ZcashAccountId.

  def write_TypeZcashAccountId(v)
    self.write_U32(v.id)
  end

  # The Record type ZcashAuthPath.

  def write_TypeZcashAuthPath(v)
    self.write_TypeZcashSaplingNode(v.node)
    self.write_Bool(v.bool)
  end

  # The Record type ZcashDiversifierIndexAndPaymentAddress.

  def write_TypeZcashDiversifierIndexAndPaymentAddress(v)
    self.write_TypeZcashDiversifierIndex(v.diversifier_index)
    self.write_TypeZcashPaymentAddress(v.address)
  end

  # The Record type ZcashDiversifierIndexAndScope.

  def write_TypeZcashDiversifierIndexAndScope(v)
    self.write_TypeZcashDiversifierIndex(v.diversifier_index)
    self.write_TypeZcashScope(v.scope)
  end

  # The Record type ZcashInternalOvkExternalOvk.

  def write_TypeZcashInternalOvkExternalOvk(v)
    self.write_TypeZcashInternalOvk(v.internal_ovk)
    self.write_TypeZcashExternalOvk(v.external_ovk)
  end

  # The Record type ZcashOrchardDecryptOutput.

  def write_TypeZcashOrchardDecryptOutput(v)
    self.write_TypeZcashOrchardNote(v.note)
    self.write_TypeZcashOrchardAddress(v.address)
    self.write_Sequenceu8(v.data)
  end

  # The Record type ZcashOrchardDecryptOutputForIncomingKeys.

  def write_TypeZcashOrchardDecryptOutputForIncomingKeys(v)
    self.write_U64(v.idx)
    self.write_TypeZcashOrchardIncomingViewingKey(v.key)
    self.write_TypeZcashOrchardNote(v.note)
    self.write_TypeZcashOrchardAddress(v.address)
    self.write_Sequenceu8(v.data)
  end

  # The Record type ZcashOrchardDecryptOutputForOutgoingKeys.

  def write_TypeZcashOrchardDecryptOutputForOutgoingKeys(v)
    self.write_U64(v.idx)
    self.write_TypeZcashOrchardOutgoingViewingKey(v.key)
    self.write_TypeZcashOrchardNote(v.note)
    self.write_TypeZcashOrchardAddress(v.address)
    self.write_Sequenceu8(v.data)
  end

  # The Record type ZcashOrchardTransmittedNoteCiphertext.

  def write_TypeZcashOrchardTransmittedNoteCiphertext(v)
    self.write_Sequenceu8(v.epk_bytes)
    self.write_Sequenceu8(v.enc_ciphertext)
    self.write_Sequenceu8(v.out_ciphertext)
  end

  # The Record type ZcashPayment.

  def write_TypeZcashPayment(v)
    self.write_TypeZcashRecipientAddress(v.recipent_address)
    self.write_I64(v.amount)
    self.write_OptionalTypeZcashMemoBytes(v.memo)
    self.write_Optionalstring(v.label)
    self.write_Optionalstring(v.message)
    self.write_SequenceTypeZcashPaymentParam(v.other_params)
  end

  # The Record type ZcashPaymentParam.

  def write_TypeZcashPaymentParam(v)
    self.write_String(v.key)
    self.write_String(v.value)
  end

  # The Record type ZcashTransactionAndSaplingMetadata.

  def write_TypeZcashTransactionAndSaplingMetadata(v)
    self.write_TypeZcashTransaction(v.transaction)
    self.write_TypeZcashSaplingMetadata(v.sapling_metadata)
  end

  # The Record type ZcashTransparentAddressAndIndex.

  def write_TypeZcashTransparentAddressAndIndex(v)
    self.write_TypeZcashTransparentAddress(v.transparent_address)
    self.write_U32(v.index)
  end

  # The Record type ZcashUnifiedAddressAndDiversifierIndex.

  def write_TypeZcashUnifiedAddressAndDiversifierIndex(v)
    self.write_TypeZcashUnifiedAddress(v.address)
    self.write_TypeZcashDiversifierIndex(v.diversifier_index)
  end

  # The Enum type ZcashBranchId.

  def write_TypeZcashBranchId(v)
    pack_into(4, 'l>', v)
 end

  # The Enum type ZcashChildIndex.

  def write_TypeZcashChildIndex(v)
    if v.non_hardened?
      pack_into(4, 'l>', 1)
      self.write_U32(v.v)
    end
    if v.hardened?
      pack_into(4, 'l>', 2)
      self.write_U32(v.v)
    end
 end

  # The Enum type ZcashConsensusParameters.

  def write_TypeZcashConsensusParameters(v)
    pack_into(4, 'l>', v)
 end

  # The Enum type ZcashFeeRules.

  def write_TypeZcashFeeRules(v)
    if v.fixed_standard?
      pack_into(4, 'l>', 1)
    end
    if v.fixed_non_standard?
      pack_into(4, 'l>', 2)
      self.write_U64(v.amount)
    end
    if v.zip317_standard?
      pack_into(4, 'l>', 3)
    end
    if v.zip317_non_standard?
      pack_into(4, 'l>', 4)
      self.write_U64(v.marginal_fee)
      self.write_U64(v.grace_actions)
      self.write_U64(v.p2pkh_standard_input_size)
      self.write_U64(v.p2pkh_standard_output_size)
    end
 end

  # The Enum type ZcashKeySeed.

  def write_TypeZcashKeySeed(v)
    pack_into(4, 'l>', v)
 end

  # The Enum type ZcashKeysEra.

  def write_TypeZcashKeysEra(v)
    pack_into(4, 'l>', v)
 end

  # The Enum type ZcashOrchardScope.

  def write_TypeZcashOrchardScope(v)
    pack_into(4, 'l>', v)
 end

  # The Enum type ZcashRseed.

  def write_TypeZcashRseed(v)
    if v.before_zip212?
      pack_into(4, 'l>', 1)
      self.write_Sequenceu8(v.fr_data)
    end
    if v.after_zip212?
      pack_into(4, 'l>', 2)
      self.write_Sequenceu8(v.data)
    end
 end

  # The Enum type ZcashScope.

  def write_TypeZcashScope(v)
    pack_into(4, 'l>', v)
 end

  # The Enum type ZcashTxVersionSelection.

  def write_TypeZcashTxVersionSelection(v)
    if v.sprout?
      pack_into(4, 'l>', 1)
      self.write_U32(v.v)
    end
    if v.overwinter?
      pack_into(4, 'l>', 2)
    end
    if v.sapling?
      pack_into(4, 'l>', 3)
    end
    if v.zip225?
      pack_into(4, 'l>', 4)
    end
 end

  # This type is not yet supported in the Ruby backend.
  def write_TypeZcashError(v)
    raise InternalError('RustBufferStream.write() not implemented yet for TypeZcashError')
  end# The Optional<T> type for u64.

  def write_Optionalu64(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_U64(v)
    end
  end

  # The Optional<T> type for string.

  def write_Optionalstring(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_String(v)
    end
  end

  # The Optional<T> type for TypeZcashAccountPubKey.

  def write_OptionalTypeZcashAccountPubKey(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashAccountPubKey(v)
    end
  end

  # The Optional<T> type for TypeZcashDiversifiableFullViewingKey.

  def write_OptionalTypeZcashDiversifiableFullViewingKey(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashDiversifiableFullViewingKey(v)
    end
  end

  # The Optional<T> type for TypeZcashMemoBytes.

  def write_OptionalTypeZcashMemoBytes(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashMemoBytes(v)
    end
  end

  # The Optional<T> type for TypeZcashOrchardAddress.

  def write_OptionalTypeZcashOrchardAddress(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashOrchardAddress(v)
    end
  end

  # The Optional<T> type for TypeZcashOrchardBundle.

  def write_OptionalTypeZcashOrchardBundle(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashOrchardBundle(v)
    end
  end

  # The Optional<T> type for TypeZcashOrchardDiversifierIndex.

  def write_OptionalTypeZcashOrchardDiversifierIndex(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashOrchardDiversifierIndex(v)
    end
  end

  # The Optional<T> type for TypeZcashOrchardFullViewingKey.

  def write_OptionalTypeZcashOrchardFullViewingKey(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashOrchardFullViewingKey(v)
    end
  end

  # The Optional<T> type for TypeZcashOrchardOutgoingViewingKey.

  def write_OptionalTypeZcashOrchardOutgoingViewingKey(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashOrchardOutgoingViewingKey(v)
    end
  end

  # The Optional<T> type for TypeZcashOutgoingViewingKey.

  def write_OptionalTypeZcashOutgoingViewingKey(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashOutgoingViewingKey(v)
    end
  end

  # The Optional<T> type for TypeZcashPaymentAddress.

  def write_OptionalTypeZcashPaymentAddress(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashPaymentAddress(v)
    end
  end

  # The Optional<T> type for TypeZcashSaplingBundle.

  def write_OptionalTypeZcashSaplingBundle(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashSaplingBundle(v)
    end
  end

  # The Optional<T> type for TypeZcashSaplingMerklePath.

  def write_OptionalTypeZcashSaplingMerklePath(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashSaplingMerklePath(v)
    end
  end

  # The Optional<T> type for TypeZcashTransparentAddress.

  def write_OptionalTypeZcashTransparentAddress(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashTransparentAddress(v)
    end
  end

  # The Optional<T> type for TypeZcashTransparentBundle.

  def write_OptionalTypeZcashTransparentBundle(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashTransparentBundle(v)
    end
  end

  # The Optional<T> type for TypeZcashUnifiedAddress.

  def write_OptionalTypeZcashUnifiedAddress(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashUnifiedAddress(v)
    end
  end

  # The Optional<T> type for TypeZcashDiversifierIndexAndPaymentAddress.

  def write_OptionalTypeZcashDiversifierIndexAndPaymentAddress(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashDiversifierIndexAndPaymentAddress(v)
    end
  end

  # The Optional<T> type for TypeZcashDiversifierIndexAndScope.

  def write_OptionalTypeZcashDiversifierIndexAndScope(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashDiversifierIndexAndScope(v)
    end
  end

  # The Optional<T> type for TypeZcashUnifiedAddressAndDiversifierIndex.

  def write_OptionalTypeZcashUnifiedAddressAndDiversifierIndex(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashUnifiedAddressAndDiversifierIndex(v)
    end
  end

  # The Optional<T> type for TypeZcashOrchardScope.

  def write_OptionalTypeZcashOrchardScope(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_TypeZcashOrchardScope(v)
    end
  end

  # The Optional<T> type for Sequenceu8.

  def write_OptionalSequenceu8(v)
    if v.nil?
      pack_into(1, 'c', 0)
    else
      pack_into(1, 'c', 1)
      self.write_Sequenceu8(v)
    end
  end

  # The Sequence<T> type for u8.

  def write_Sequenceu8(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_U8(item)
    end
  end

  # The Sequence<T> type for u32.

  def write_Sequenceu32(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_U32(item)
    end
  end

  # The Sequence<T> type for u64.

  def write_Sequenceu64(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_U64(item)
    end
  end

  # The Sequence<T> type for TypeZcashOrchardAction.

  def write_SequenceTypeZcashOrchardAction(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashOrchardAction(item)
    end
  end

  # The Sequence<T> type for TypeZcashOrchardIncomingViewingKey.

  def write_SequenceTypeZcashOrchardIncomingViewingKey(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashOrchardIncomingViewingKey(item)
    end
  end

  # The Sequence<T> type for TypeZcashOrchardMerkleHash.

  def write_SequenceTypeZcashOrchardMerkleHash(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashOrchardMerkleHash(item)
    end
  end

  # The Sequence<T> type for TypeZcashOrchardOutgoingViewingKey.

  def write_SequenceTypeZcashOrchardOutgoingViewingKey(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashOrchardOutgoingViewingKey(item)
    end
  end

  # The Sequence<T> type for TypeZcashOrchardSpendingKey.

  def write_SequenceTypeZcashOrchardSpendingKey(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashOrchardSpendingKey(item)
    end
  end

  # The Sequence<T> type for TypeZcashSaplingOutputDescription.

  def write_SequenceTypeZcashSaplingOutputDescription(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashSaplingOutputDescription(item)
    end
  end

  # The Sequence<T> type for TypeZcashSaplingSpendDescription.

  def write_SequenceTypeZcashSaplingSpendDescription(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashSaplingSpendDescription(item)
    end
  end

  # The Sequence<T> type for TypeZcashTxIn.

  def write_SequenceTypeZcashTxIn(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashTxIn(item)
    end
  end

  # The Sequence<T> type for TypeZcashTxOut.

  def write_SequenceTypeZcashTxOut(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashTxOut(item)
    end
  end

  # The Sequence<T> type for TypeZcashAuthPath.

  def write_SequenceTypeZcashAuthPath(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashAuthPath(item)
    end
  end

  # The Sequence<T> type for TypeZcashOrchardDecryptOutputForIncomingKeys.

  def write_SequenceTypeZcashOrchardDecryptOutputForIncomingKeys(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashOrchardDecryptOutputForIncomingKeys(item)
    end
  end

  # The Sequence<T> type for TypeZcashOrchardDecryptOutputForOutgoingKeys.

  def write_SequenceTypeZcashOrchardDecryptOutputForOutgoingKeys(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashOrchardDecryptOutputForOutgoingKeys(item)
    end
  end

  # The Sequence<T> type for TypeZcashPaymentParam.

  def write_SequenceTypeZcashPaymentParam(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashPaymentParam(item)
    end
  end

  # The Sequence<T> type for TypeZcashChildIndex.

  def write_SequenceTypeZcashChildIndex(items)
    pack_into(4, 'l>', items.size)

    items.each do |item|
      self.write_TypeZcashChildIndex(item)
    end
  end

  

  private

  def reserve(num_bytes)
    if @rust_buf.len + num_bytes > @rust_buf.capacity
      @rust_buf = RustBuffer.reserve(@rust_buf, num_bytes)
    end

    yield

    @rust_buf.len += num_bytes
  end

  def pack_into(size, format, value)
    reserve(size) do
      @rust_buf.data.put_array_of_char @rust_buf.len, [value].pack(format).bytes
    end
  end
end

private_constant :RustBufferBuilder

  # Error definitions
  class RustCallStatus < FFI::Struct
  layout :code,    :int8,
         :error_buf, RustBuffer

  def code
    self[:code]
  end

  def error_buf
    self[:error_buf]
  end

  def to_s
    "RustCallStatus(code=#{self[:code]})"
  end
end

# These match the values from the uniffi::rustcalls module
CALL_SUCCESS = 0
CALL_ERROR = 1
CALL_PANIC = 2

class ZcashError
    HdWalletError = Class.new StandardError
    DecodingError = Class.new StandardError
    DerivationError = Class.new StandardError
    InvalidAsk = Class.new StandardError
    InvalidNsk = Class.new StandardError
    Message = Class.new StandardError
    ArrayLengthMismatch = Class.new StandardError
    ValueOutOfRange = Class.new StandardError
    Secp256k1Error = Class.new StandardError
    Bech32DecodeError = Class.new StandardError
    Bs58Error = Class.new StandardError
    BuilderError = Class.new StandardError
    TransparentBuilderError = Class.new StandardError
    SaplingBuilderError = Class.new StandardError
    OrchardBuilderError = Class.new StandardError
    InsufficientFundsError = Class.new StandardError
    ChangeRequiredError = Class.new StandardError
    BalanceError = Class.new StandardError
    IoError = Class.new StandardError
    Unknown = Class.new StandardError

end

# Map error modules to the RustBuffer method name that reads them
ERROR_MODULE_TO_READER_METHOD = {
  ZcashError => :readTypeZcashError,
}

private_constant :ERROR_MODULE_TO_READER_METHOD, :CALL_SUCCESS, :CALL_ERROR, :CALL_PANIC,
                 :RustCallStatus

def self.consume_buffer_into_error(error_module, rust_buffer)
  rust_buffer.consumeWithStream do |stream|
    reader_method = ERROR_MODULE_TO_READER_METHOD[error_module]
    return stream.send(reader_method)
  end
end

class InternalError < StandardError
end

def self.rust_call(fn_name, *args)
  # Call a rust function
  rust_call_with_error(nil, fn_name, *args)
end

def self.rust_call_with_error(error_module, fn_name, *args)
  # Call a rust function and handle errors
  #
  # Use this when the rust function returns a Result<>.  error_module must be the error_module that corresponds to that Result.


  # Note: RustCallStatus.new zeroes out the struct, which is exactly what we
  # want to pass to Rust (code=0, error_buf=RustBuffer(len=0, capacity=0,
  # data=NULL))
  status = RustCallStatus.new
  args << status

  result = UniFFILib.public_send(fn_name, *args)

  case status.code
  when CALL_SUCCESS
    result
  when CALL_ERROR
    if error_module.nil?
      status.error_buf.free
      raise InternalError, "CALL_ERROR with no error_module set"
    else
      raise consume_buffer_into_error(error_module, status.error_buf)
    end
  when CALL_PANIC
    # When the rust code sees a panic, it tries to construct a RustBuffer
    # with the message.  But if that code panics, then it just sends back
    # an empty buffer.
    if status.error_buf.len > 0
      raise InternalError, status.error_buf.consumeIntoString()
    else
      raise InternalError, "Rust panic"
    end
  else
    raise InternalError, "Unknown call status: #{status.code}"
  end
end

private_class_method :consume_buffer_into_error

  # This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
module UniFFILib
  extend FFI::Library

  
  ffi_lib File.join(File.dirname(File.expand_path(__FILE__)), '/libuniffi_zcash' + (OS.windows? && '.dll' || OS.mac? && '.dylib' || '.so'))
  

  attach_function :ffi_zcash_e53_ZcashRecipientAddress_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashRecipientAddress_decode,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashRecipientAddress_shielded,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashRecipientAddress_transparent,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashRecipientAddress_unified,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashRecipientAddress_encode,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashUnifiedAddress_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashUnifiedAddress_new,
    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashUnifiedAddress_decode,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashUnifiedAddress_orchard,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashUnifiedAddress_sapling,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashUnifiedAddress_transparent,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashUnifiedAddress_encode,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashUnifiedFullViewingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashUnifiedFullViewingKey_new,
    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashUnifiedFullViewingKey_decode,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashUnifiedFullViewingKey_encode,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashUnifiedFullViewingKey_transparent,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashUnifiedFullViewingKey_sapling,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashUnifiedFullViewingKey_orchard,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashUnifiedFullViewingKey_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashUnifiedFullViewingKey_find_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashUnifiedFullViewingKey_default_address,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashUnifiedSpendingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashUnifiedSpendingKey_from_seed,
    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashUnifiedSpendingKey_from_bytes,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashUnifiedSpendingKey_to_unified_full_viewing_key,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashUnifiedSpendingKey_transparent,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashUnifiedSpendingKey_sapling,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashUnifiedSpendingKey_orchard,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashUnifiedSpendingKey_to_bytes,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardNote_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardNote_from_parts,
    [:pointer, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardNote_recipient,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardNote_value,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardNote_commitment,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashOrchardNullifier_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardNullifier_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardNullifier_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardRandomSeed_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardRandomSeed_from_bytes,
    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardRandomSeed_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardNoteCommitment_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardNoteCommitment_to_extracted_note_commitment,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashExtractedNoteCommitment_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashExtractedNoteCommitment_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtractedNoteCommitment_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardAddress_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardAddress_from_raw_address_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardAddress_diversifier,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardAddress_to_raw_address_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashVerifyingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashVerifyingKey_new,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashProvingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashProvingKey_new,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashOrchardBundle_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardBundle_actions,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashOrchardBundle_flags,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardBundle_value_balance,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardBundle_anchor,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardBundle_verify_proof,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardBundle_decrypt_output_with_key,
    [:pointer, :uint64, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashOrchardBundle_decrypt_output_with_keys,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashOrchardBundle_recover_output_with_ovk,
    [:pointer, :uint64, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashOrchardBundle_recover_outputs_with_ovks,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardFlags_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardFlags_from_parts,
    [:int8, :int8, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardFlags_from_byte,
    [:uint8, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardFlags_spends_enabled,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :zcash_e53_ZcashOrchardFlags_outputs_enabled,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :zcash_e53_ZcashOrchardFlags_to_byte,
    [:pointer, RustCallStatus.by_ref],
    :uint8
  attach_function :ffi_zcash_e53_ZcashOrchardNoteValue_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardNoteValue_from_raw,
    [:uint64, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardNoteValue_value,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :ffi_zcash_e53_ZcashOrchardValueCommitment_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardValueCommitment_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardAction_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardAction_nullifier,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardAction_cmx,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardAction_encrypted_note,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashOrchardAction_cv_net,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashOrchardFullViewingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardFullViewingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardFullViewingKey_address_at,
    [:pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardFullViewingKey_address,
    [:pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardFullViewingKey_scope_for_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashOrchardFullViewingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashOrchardFullViewingKey_to_ivk,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardFullViewingKey_to_ovk,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashOrchardSpendingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardSpendingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardSpendingKey_from_zip32_seed,
    [RustBuffer.by_value, :uint32, :uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardSpendingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashOrchardSpendingKey_to_fvk,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashAnchor_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashAnchor_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAnchor_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardIncomingViewingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardIncomingViewingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardIncomingViewingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashOrchardIncomingViewingKey_diversifier_index,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashOrchardIncomingViewingKey_address_at,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardIncomingViewingKey_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashOrchardDiversifier_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardDiversifier_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardDiversifier_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardOutgoingViewingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardOutgoingViewingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardOutgoingViewingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardMerklePath_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardMerklePath_from_parts,
    [:uint32, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardMerklePath_root,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashOrchardMerkleHash_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardMerkleHash_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardMerkleHash_from_cmx,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardMerkleHash_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardDiversifierIndex_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardDiversifierIndex_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardDiversifierIndex_from_u32,
    [:uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardDiversifierIndex_from_u64,
    [:uint64, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardDiversifierIndex_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashExtendedPrivKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashExtendedPrivKey_random,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedPrivKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedPrivKey_random_with_seed_size,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedPrivKey_with_seed,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedPrivKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashExtendedPrivKey_derive_private_key,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashKeyIndex_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashKeyIndex_from_u32,
    [:uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashKeyIndex_hardened_from_normalize_index,
    [:uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashKeyIndex_from_index,
    [:uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashKeyIndex_raw_index,
    [:pointer, RustCallStatus.by_ref],
    :uint32
  attach_function :zcash_e53_ZcashKeyIndex_normalize_index,
    [:pointer, RustCallStatus.by_ref],
    :uint32
  attach_function :zcash_e53_ZcashKeyIndex_is_valid,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :ffi_zcash_e53_ZcashZip317FeeRule_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashZip317FeeRule_standard,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashZip317FeeRule_non_standard,
    [:pointer, :uint64, :uint64, :uint64, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashZip317FeeRule_marginal_fee,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashFixedFeeRule_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashFixedFeeRule_non_standard,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashFixedFeeRule_standard,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashFixedFeeRule_fixed_fee,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashTransparentBundle_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTransparentBundle_is_coinbase,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :zcash_e53_ZcashTransparentBundle_vin,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashTransparentBundle_vout,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashTxOut_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTxOut_new,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTxOut_value,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTxOut_script_pubkey,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTxOut_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashTxOut_recipient_address,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashTxIn_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTxIn_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashTransactionBuilder_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTransactionBuilder_new,
    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTransactionBuilder_add_sapling_spend,
    [:pointer, :pointer, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTransactionBuilder_add_sapling_output,
    [:pointer, RustBuffer.by_value, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTransactionBuilder_add_transparent_input,
    [:pointer, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTransactionBuilder_add_transparent_output,
    [:pointer, :pointer, :pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTransactionBuilder_build,
    [:pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashTransaction_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTransaction_from_bytes,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTransaction_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashTransaction_txid,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTransaction_version,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTransaction_consensus_branch_id,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashTransaction_lock_time,
    [:pointer, RustCallStatus.by_ref],
    :uint32
  attach_function :zcash_e53_ZcashTransaction_expiry_height,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTransaction_transparent_bundle,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashTransaction_sapling_bundle,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashTransaction_orchard_bundle,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashTxId_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTxId_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTxId_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOrchardTransactionBuilder_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardTransactionBuilder_new,
    [RustBuffer.by_value, :pointer, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOrchardTransactionBuilder_add_spend,
    [:pointer, :pointer, :pointer, :pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardTransactionBuilder_add_recipient,
    [:pointer, RustBuffer.by_value, :pointer, :uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOrchardTransactionBuilder_build,
    [:pointer, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashTxVersion_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTxVersion_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTxVersion_suggested_for_branch,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTxVersion_selection,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashTxVersion_header,
    [:pointer, RustCallStatus.by_ref],
    :uint32
  attach_function :zcash_e53_ZcashTxVersion_version_group_id,
    [:pointer, RustCallStatus.by_ref],
    :uint32
  attach_function :zcash_e53_ZcashTxVersion_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashTxVersion_has_sprout,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :zcash_e53_ZcashTxVersion_has_overwinter,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :zcash_e53_ZcashTxVersion_has_sapling,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :zcash_e53_ZcashTxVersion_has_orchard,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :ffi_zcash_e53_ZcashOutPoint_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOutPoint_new,
    [RustBuffer.by_value, :uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashAmount_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashAmount_new,
    [:int64, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAmount_zero,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAmount_value,
    [:pointer, RustCallStatus.by_ref],
    :int64
  attach_function :ffi_zcash_e53_ZcashSaplingSpendDescription_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingSpendDescription_cv,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashSaplingSpendDescription_anchor,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashSaplingSpendDescription_nullifier,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashSaplingSpendDescription_rk,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashSaplingBundle_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingBundle_shielded_spends,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashSaplingBundle_shielded_outputs,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashSaplingBundle_value_balance,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashSaplingOutputDescription_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingOutputDescription_cv,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashSaplingOutputDescription_cmu,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashSaplingMetadata_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingMetadata_new,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashSaplingMetadata_spend_index,
    [:pointer, :uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashSaplingMetadata_output_index,
    [:pointer, :uint64, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashBlockHeight_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashBlockHeight_new,
    [:uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashBlockHeight_value,
    [:pointer, RustCallStatus.by_ref],
    :uint32
  attach_function :ffi_zcash_e53_ZcashCommitmentTree_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashCommitmentTree_empty,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashCommitmentTree_append,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :void
  attach_function :ffi_zcash_e53_ZcashSaplingMerklePath_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingMerklePath_auth_path,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashSaplingMerklePath_position,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :ffi_zcash_e53_ZcashIncrementalWitness_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashIncrementalWitness_from_tree,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashIncrementalWitness_append,
    [:pointer, :pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashIncrementalWitness_path,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashTransparentAddress_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashTransparentAddress_from_public_key,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTransparentAddress_from_script,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTransparentAddress_decode,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTransparentAddress_encode,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashTransparentAddress_is_public_key,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :zcash_e53_ZcashTransparentAddress_is_script,
    [:pointer, RustCallStatus.by_ref],
    :int8
  attach_function :zcash_e53_ZcashTransparentAddress_script,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashTransparentAddress_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashExternalIvk_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashExternalIvk_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExternalIvk_derive_address,
    [:pointer, :uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExternalIvk_default_address,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashExternalIvk_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashInternalIvk_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashInternalIvk_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashInternalIvk_default_address,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashInternalIvk_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashExternalOvk_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashExternalOvk_as_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashInternalOvk_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashInternalOvk_as_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashAccountPubKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashAccountPubKey_new,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPubKey_derive_external_ivk,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPubKey_derive_internal_ivk,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPubKey_ovks_for_shielding,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashAccountPubKey_internal_ovk,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPubKey_external_ovk,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPubKey_serialize,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashAccountPrivKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashAccountPrivKey_from_seed,
    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPrivKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPrivKey_from_extended_privkey,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPrivKey_to_account_pubkey,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPrivKey_derive_external_secret_key,
    [:pointer, :uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPrivKey_derive_internal_secret_key,
    [:pointer, :uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashAccountPrivKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashScript_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashScript_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashScript_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashSaplingValueCommitment_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingValueCommitment_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashSaplingNote_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingNote_from_parts,
    [:pointer, :pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashSaplingNote_value,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashSaplingNote_cmu,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashSaplingNoteValue_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingNoteValue_from_raw,
    [:uint64, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashSaplingNoteValue_inner,
    [:pointer, RustCallStatus.by_ref],
    :uint64
  attach_function :ffi_zcash_e53_ZcashSaplingNullifier_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingNullifier_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashSaplingExtractedNoteCommitment_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingExtractedNoteCommitment_new,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashSaplingExtractedNoteCommitment_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashPaymentAddress_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashPaymentAddress_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashPaymentAddress_decode,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashPaymentAddress_encode,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashPaymentAddress_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashPaymentAddress_diversifier,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashPaymentAddress_pk_d,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashPaymentAddress_create_note,
    [:pointer, :uint64, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashSaplingIvk_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingIvk_to_payment_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashSaplingIvk_to_repr,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashDiversifier_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashDiversifier_new,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashDiversifier_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashFullViewingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashFullViewingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashFullViewingKey_from_expanded_spending_key,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashFullViewingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashFullViewingKey_vk,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashFullViewingKey_ovk,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashNullifierDerivingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashNullifierDerivingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashNullifierDerivingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashOutgoingViewingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashOutgoingViewingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashOutgoingViewingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashExpandedSpendingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashExpandedSpendingKey_from_spending_key,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExpandedSpendingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExpandedSpendingKey_proof_generation_key,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExpandedSpendingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashProofGenerationKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashProofGenerationKey_to_viewing_key,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashDiversifiableFullViewingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_fvk,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_to_nk,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_to_ivk,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_to_ovk,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_find_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_default_address,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_diversified_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_change_address,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_diversified_change_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashDiversifiableFullViewingKey_decrypt_diversifier,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashSaplingDiversifiedTransmissionKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :ffi_zcash_e53_ZcashViewingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashViewingKey_ivk,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashViewingKey_to_payment_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashExtendedFullViewingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashExtendedFullViewingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedFullViewingKey_decode,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedFullViewingKey_encode,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashExtendedFullViewingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashExtendedFullViewingKey_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashExtendedFullViewingKey_derive_child,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedFullViewingKey_find_address,
    [:pointer, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashExtendedFullViewingKey_default_address,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashExtendedFullViewingKey_derive_internal,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedFullViewingKey_to_diversifiable_full_viewing_key,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashSaplingPublicKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingPublicKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashSaplingNode_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashSaplingNode_from_cmu,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashExtendedSpendingKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashExtendedSpendingKey_master,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedSpendingKey_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedSpendingKey_from_path,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedSpendingKey_decode,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedSpendingKey_encode,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashExtendedSpendingKey_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashExtendedSpendingKey_derive_child,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedSpendingKey_default_address,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_ZcashExtendedSpendingKey_derive_internal,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashExtendedSpendingKey_to_diversifiable_full_viewing_key,
    [:pointer, RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_ZcashDiversifierIndex_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashDiversifierIndex_new,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashDiversifierIndex_from_u32,
    [:uint32, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashDiversifierIndex_from_u64,
    [:uint64, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashDiversifierIndex_increment,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashDiversifierIndex_to_u32,
    [:pointer, RustCallStatus.by_ref],
    :uint32
  attach_function :zcash_e53_ZcashDiversifierIndex_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashMemoBytes_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashMemoBytes_new,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashMemoBytes_empty,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashMemoBytes_data,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashLocalTxProver_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashLocalTxProver_new,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashLocalTxProver_from_bytes,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashLocalTxProver_with_default_location,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :ffi_zcash_e53_SecpSecretKey_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_SecpSecretKey_new,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_SecpSecretKey_serialize_secret,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_ZcashJubjubFr_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_ZcashJubjubFr_from_bytes,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_ZcashJubjubFr_to_bytes,
    [:pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_TestSupport_object_free,
    [:pointer, RustCallStatus.by_ref],
    :void
  attach_function :zcash_e53_TestSupport_from_csv_file,
    [RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_TestSupport_get_as_u8_array,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_TestSupport_get_as_u32_array,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_TestSupport_get_as_u64_array,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_TestSupport_get_as_u32,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :uint32
  attach_function :zcash_e53_TestSupport_get_as_u64,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    :uint64
  attach_function :zcash_e53_TestSupport_get_as_string,
    [:pointer, RustBuffer.by_value, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_decode_extended_full_viewing_key,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_decode_extended_spending_key,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_decode_payment_address,
    [RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_decode_transparent_address,
    [RustBuffer.by_value, RustBuffer.by_value, RustBuffer.by_value, RustCallStatus.by_ref],
    :pointer
  attach_function :zcash_e53_encode_extended_full_viewing_key,
    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_encode_extended_spending_key,
    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_encode_payment_address,
    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_encode_payment_address_p,
    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_encode_transparent_address,
    [RustBuffer.by_value, RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :zcash_e53_encode_transparent_address_p,
    [RustBuffer.by_value, :pointer, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_rustbuffer_alloc,
    [:int32, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_rustbuffer_from_bytes,
    [ForeignBytes, RustCallStatus.by_ref],
    RustBuffer.by_value
  attach_function :ffi_zcash_e53_rustbuffer_free,
    [RustBuffer.by_value, RustCallStatus.by_ref],
    :void
  attach_function :ffi_zcash_e53_rustbuffer_reserve,
    [RustBuffer.by_value, :int32, RustCallStatus.by_ref],
    RustBuffer.by_value
  
end

  # Public interface members begin here.

  
  

class ZcashBranchId
  SPROUT = 1
  OVERWINTER = 2
  SAPLING = 3
  BLOSSOM = 4
  HEARTWOOD = 5
  CANOPY = 6
  NU5 = 7
  
end


  

class ZcashChildIndex
  def initialize
    raise RuntimeError, 'ZcashChildIndex cannot be instantiated directly'
  end

  # Each enum variant is a nested class of the enum itself.
  class NON_HARDENED
    
    attr_reader :v
    
    def initialize(v)
      
      @v = v
      
    end

    def to_s
      "ZcashChildIndex::NON_HARDENED(v=#{@v})"
    end

    def ==(other)
      if !other.non_hardened?
        return false
      end
      if @v != other.v
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def non_hardened?
      instance_of? ZcashChildIndex::NON_HARDENED
    end
    
    def hardened?
      instance_of? ZcashChildIndex::HARDENED
    end
    
  end
  class HARDENED
    
    attr_reader :v
    
    def initialize(v)
      
      @v = v
      
    end

    def to_s
      "ZcashChildIndex::HARDENED(v=#{@v})"
    end

    def ==(other)
      if !other.hardened?
        return false
      end
      if @v != other.v
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def non_hardened?
      instance_of? ZcashChildIndex::NON_HARDENED
    end
    
    def hardened?
      instance_of? ZcashChildIndex::HARDENED
    end
    
  end
  
end


  

class ZcashConsensusParameters
  MAIN_NETWORK = 1
  TEST_NETWORK = 2
  
end


  

class ZcashFeeRules
  def initialize
    raise RuntimeError, 'ZcashFeeRules cannot be instantiated directly'
  end

  # Each enum variant is a nested class of the enum itself.
  class FIXED_STANDARD
    
    def initialize()
      
      
    end

    def to_s
      "ZcashFeeRules::FIXED_STANDARD()"
    end

    def ==(other)
      if !other.fixed_standard?
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def fixed_standard?
      instance_of? ZcashFeeRules::FIXED_STANDARD
    end
    
    def fixed_non_standard?
      instance_of? ZcashFeeRules::FIXED_NON_STANDARD
    end
    
    def zip317_standard?
      instance_of? ZcashFeeRules::ZIP317_STANDARD
    end
    
    def zip317_non_standard?
      instance_of? ZcashFeeRules::ZIP317_NON_STANDARD
    end
    
  end
  class FIXED_NON_STANDARD
    
    attr_reader :amount
    
    def initialize(amount)
      
      @amount = amount
      
    end

    def to_s
      "ZcashFeeRules::FIXED_NON_STANDARD(amount=#{@amount})"
    end

    def ==(other)
      if !other.fixed_non_standard?
        return false
      end
      if @amount != other.amount
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def fixed_standard?
      instance_of? ZcashFeeRules::FIXED_STANDARD
    end
    
    def fixed_non_standard?
      instance_of? ZcashFeeRules::FIXED_NON_STANDARD
    end
    
    def zip317_standard?
      instance_of? ZcashFeeRules::ZIP317_STANDARD
    end
    
    def zip317_non_standard?
      instance_of? ZcashFeeRules::ZIP317_NON_STANDARD
    end
    
  end
  class ZIP317_STANDARD
    
    def initialize()
      
      
    end

    def to_s
      "ZcashFeeRules::ZIP317_STANDARD()"
    end

    def ==(other)
      if !other.zip317_standard?
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def fixed_standard?
      instance_of? ZcashFeeRules::FIXED_STANDARD
    end
    
    def fixed_non_standard?
      instance_of? ZcashFeeRules::FIXED_NON_STANDARD
    end
    
    def zip317_standard?
      instance_of? ZcashFeeRules::ZIP317_STANDARD
    end
    
    def zip317_non_standard?
      instance_of? ZcashFeeRules::ZIP317_NON_STANDARD
    end
    
  end
  class ZIP317_NON_STANDARD
    
    attr_reader :marginal_fee, :grace_actions, :p2pkh_standard_input_size, :p2pkh_standard_output_size
    
    def initialize(marginal_fee, grace_actions, p2pkh_standard_input_size, p2pkh_standard_output_size)
      
      @marginal_fee = marginal_fee
      @grace_actions = grace_actions
      @p2pkh_standard_input_size = p2pkh_standard_input_size
      @p2pkh_standard_output_size = p2pkh_standard_output_size
      
    end

    def to_s
      "ZcashFeeRules::ZIP317_NON_STANDARD(marginal_fee=#{@marginal_fee}, grace_actions=#{@grace_actions}, p2pkh_standard_input_size=#{@p2pkh_standard_input_size}, p2pkh_standard_output_size=#{@p2pkh_standard_output_size})"
    end

    def ==(other)
      if !other.zip317_non_standard?
        return false
      end
      if @marginal_fee != other.marginal_fee
        return false
      end
      if @grace_actions != other.grace_actions
        return false
      end
      if @p2pkh_standard_input_size != other.p2pkh_standard_input_size
        return false
      end
      if @p2pkh_standard_output_size != other.p2pkh_standard_output_size
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def fixed_standard?
      instance_of? ZcashFeeRules::FIXED_STANDARD
    end
    
    def fixed_non_standard?
      instance_of? ZcashFeeRules::FIXED_NON_STANDARD
    end
    
    def zip317_standard?
      instance_of? ZcashFeeRules::ZIP317_STANDARD
    end
    
    def zip317_non_standard?
      instance_of? ZcashFeeRules::ZIP317_NON_STANDARD
    end
    
  end
  
end


  

class ZcashKeySeed
  S128 = 1
  S256 = 2
  S512 = 3
  
end


  

class ZcashKeysEra
  ORCHARD = 1
  
end


  

class ZcashOrchardScope
  EXTERNAL = 1
  INTERNAL = 2
  
end


  

class ZcashRseed
  def initialize
    raise RuntimeError, 'ZcashRseed cannot be instantiated directly'
  end

  # Each enum variant is a nested class of the enum itself.
  class BEFORE_ZIP212
    
    attr_reader :fr_data
    
    def initialize(fr_data)
      
      @fr_data = fr_data
      
    end

    def to_s
      "ZcashRseed::BEFORE_ZIP212(fr_data=#{@fr_data})"
    end

    def ==(other)
      if !other.before_zip212?
        return false
      end
      if @fr_data != other.fr_data
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def before_zip212?
      instance_of? ZcashRseed::BEFORE_ZIP212
    end
    
    def after_zip212?
      instance_of? ZcashRseed::AFTER_ZIP212
    end
    
  end
  class AFTER_ZIP212
    
    attr_reader :data
    
    def initialize(data)
      
      @data = data
      
    end

    def to_s
      "ZcashRseed::AFTER_ZIP212(data=#{@data})"
    end

    def ==(other)
      if !other.after_zip212?
        return false
      end
      if @data != other.data
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def before_zip212?
      instance_of? ZcashRseed::BEFORE_ZIP212
    end
    
    def after_zip212?
      instance_of? ZcashRseed::AFTER_ZIP212
    end
    
  end
  
end


  

class ZcashScope
  EXTERNAL = 1
  INTERNAL = 2
  
end


  

class ZcashTxVersionSelection
  def initialize
    raise RuntimeError, 'ZcashTxVersionSelection cannot be instantiated directly'
  end

  # Each enum variant is a nested class of the enum itself.
  class SPROUT
    
    attr_reader :v
    
    def initialize(v)
      
      @v = v
      
    end

    def to_s
      "ZcashTxVersionSelection::SPROUT(v=#{@v})"
    end

    def ==(other)
      if !other.sprout?
        return false
      end
      if @v != other.v
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def sprout?
      instance_of? ZcashTxVersionSelection::SPROUT
    end
    
    def overwinter?
      instance_of? ZcashTxVersionSelection::OVERWINTER
    end
    
    def sapling?
      instance_of? ZcashTxVersionSelection::SAPLING
    end
    
    def zip225?
      instance_of? ZcashTxVersionSelection::ZIP225
    end
    
  end
  class OVERWINTER
    
    def initialize()
      
      
    end

    def to_s
      "ZcashTxVersionSelection::OVERWINTER()"
    end

    def ==(other)
      if !other.overwinter?
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def sprout?
      instance_of? ZcashTxVersionSelection::SPROUT
    end
    
    def overwinter?
      instance_of? ZcashTxVersionSelection::OVERWINTER
    end
    
    def sapling?
      instance_of? ZcashTxVersionSelection::SAPLING
    end
    
    def zip225?
      instance_of? ZcashTxVersionSelection::ZIP225
    end
    
  end
  class SAPLING
    
    def initialize()
      
      
    end

    def to_s
      "ZcashTxVersionSelection::SAPLING()"
    end

    def ==(other)
      if !other.sapling?
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def sprout?
      instance_of? ZcashTxVersionSelection::SPROUT
    end
    
    def overwinter?
      instance_of? ZcashTxVersionSelection::OVERWINTER
    end
    
    def sapling?
      instance_of? ZcashTxVersionSelection::SAPLING
    end
    
    def zip225?
      instance_of? ZcashTxVersionSelection::ZIP225
    end
    
  end
  class ZIP225
    
    def initialize()
      
      
    end

    def to_s
      "ZcashTxVersionSelection::ZIP225()"
    end

    def ==(other)
      if !other.zip225?
        return false
      end

      true
    end

    # For each variant, we have an `NAME?` method for easily checking
    # whether an instance is that variant.
    
    def sprout?
      instance_of? ZcashTxVersionSelection::SPROUT
    end
    
    def overwinter?
      instance_of? ZcashTxVersionSelection::OVERWINTER
    end
    
    def sapling?
      instance_of? ZcashTxVersionSelection::SAPLING
    end
    
    def zip225?
      instance_of? ZcashTxVersionSelection::ZIP225
    end
    
  end
  
end


  # Record type ZcashAccountId
class ZcashAccountId
  attr_reader :id
  
  

  def initialize(id)
    @id = id
  end

  def ==(other)
    if @id != other.id
      return false
    end

    true
  end
end
  
  # Record type ZcashAuthPath
class ZcashAuthPath
  attr_reader :node
  
  attr_reader :bool
  
  

  def initialize(node, bool)
    @node = node
    @bool = bool
  end

  def ==(other)
    if @node != other.node
      return false
    end
    if @bool != other.bool
      return false
    end

    true
  end
end
  
  # Record type ZcashDiversifierIndexAndPaymentAddress
class ZcashDiversifierIndexAndPaymentAddress
  attr_reader :diversifier_index
  
  attr_reader :address
  
  

  def initialize(diversifier_index, address)
    @diversifier_index = diversifier_index
    @address = address
  end

  def ==(other)
    if @diversifier_index != other.diversifier_index
      return false
    end
    if @address != other.address
      return false
    end

    true
  end
end
  
  # Record type ZcashDiversifierIndexAndScope
class ZcashDiversifierIndexAndScope
  attr_reader :diversifier_index
  
  attr_reader :scope
  
  

  def initialize(diversifier_index, scope)
    @diversifier_index = diversifier_index
    @scope = scope
  end

  def ==(other)
    if @diversifier_index != other.diversifier_index
      return false
    end
    if @scope != other.scope
      return false
    end

    true
  end
end
  
  # Record type ZcashInternalOvkExternalOvk
class ZcashInternalOvkExternalOvk
  attr_reader :internal_ovk
  
  attr_reader :external_ovk
  
  

  def initialize(internal_ovk, external_ovk)
    @internal_ovk = internal_ovk
    @external_ovk = external_ovk
  end

  def ==(other)
    if @internal_ovk != other.internal_ovk
      return false
    end
    if @external_ovk != other.external_ovk
      return false
    end

    true
  end
end
  
  # Record type ZcashOrchardDecryptOutput
class ZcashOrchardDecryptOutput
  attr_reader :note
  
  attr_reader :address
  
  attr_reader :data
  
  

  def initialize(note, address, data)
    @note = note
    @address = address
    @data = data
  end

  def ==(other)
    if @note != other.note
      return false
    end
    if @address != other.address
      return false
    end
    if @data != other.data
      return false
    end

    true
  end
end
  
  # Record type ZcashOrchardDecryptOutputForIncomingKeys
class ZcashOrchardDecryptOutputForIncomingKeys
  attr_reader :idx
  
  attr_reader :key
  
  attr_reader :note
  
  attr_reader :address
  
  attr_reader :data
  
  

  def initialize(idx, key, note, address, data)
    @idx = idx
    @key = key
    @note = note
    @address = address
    @data = data
  end

  def ==(other)
    if @idx != other.idx
      return false
    end
    if @key != other.key
      return false
    end
    if @note != other.note
      return false
    end
    if @address != other.address
      return false
    end
    if @data != other.data
      return false
    end

    true
  end
end
  
  # Record type ZcashOrchardDecryptOutputForOutgoingKeys
class ZcashOrchardDecryptOutputForOutgoingKeys
  attr_reader :idx
  
  attr_reader :key
  
  attr_reader :note
  
  attr_reader :address
  
  attr_reader :data
  
  

  def initialize(idx, key, note, address, data)
    @idx = idx
    @key = key
    @note = note
    @address = address
    @data = data
  end

  def ==(other)
    if @idx != other.idx
      return false
    end
    if @key != other.key
      return false
    end
    if @note != other.note
      return false
    end
    if @address != other.address
      return false
    end
    if @data != other.data
      return false
    end

    true
  end
end
  
  # Record type ZcashOrchardTransmittedNoteCiphertext
class ZcashOrchardTransmittedNoteCiphertext
  attr_reader :epk_bytes
  
  attr_reader :enc_ciphertext
  
  attr_reader :out_ciphertext
  
  

  def initialize(epk_bytes, enc_ciphertext, out_ciphertext)
    @epk_bytes = epk_bytes
    @enc_ciphertext = enc_ciphertext
    @out_ciphertext = out_ciphertext
  end

  def ==(other)
    if @epk_bytes != other.epk_bytes
      return false
    end
    if @enc_ciphertext != other.enc_ciphertext
      return false
    end
    if @out_ciphertext != other.out_ciphertext
      return false
    end

    true
  end
end
  
  # Record type ZcashPayment
class ZcashPayment
  attr_reader :recipent_address
  
  attr_reader :amount
  
  attr_reader :memo
  
  attr_reader :label
  
  attr_reader :message
  
  attr_reader :other_params
  
  

  def initialize(recipent_address, amount, memo, label, message, other_params)
    @recipent_address = recipent_address
    @amount = amount
    @memo = memo
    @label = label
    @message = message
    @other_params = other_params
  end

  def ==(other)
    if @recipent_address != other.recipent_address
      return false
    end
    if @amount != other.amount
      return false
    end
    if @memo != other.memo
      return false
    end
    if @label != other.label
      return false
    end
    if @message != other.message
      return false
    end
    if @other_params != other.other_params
      return false
    end

    true
  end
end
  
  # Record type ZcashPaymentParam
class ZcashPaymentParam
  attr_reader :key
  
  attr_reader :value
  
  

  def initialize(key, value)
    @key = key
    @value = value
  end

  def ==(other)
    if @key != other.key
      return false
    end
    if @value != other.value
      return false
    end

    true
  end
end
  
  # Record type ZcashTransactionAndSaplingMetadata
class ZcashTransactionAndSaplingMetadata
  attr_reader :transaction
  
  attr_reader :sapling_metadata
  
  

  def initialize(transaction, sapling_metadata)
    @transaction = transaction
    @sapling_metadata = sapling_metadata
  end

  def ==(other)
    if @transaction != other.transaction
      return false
    end
    if @sapling_metadata != other.sapling_metadata
      return false
    end

    true
  end
end
  
  # Record type ZcashTransparentAddressAndIndex
class ZcashTransparentAddressAndIndex
  attr_reader :transparent_address
  
  attr_reader :index
  
  

  def initialize(transparent_address, index)
    @transparent_address = transparent_address
    @index = index
  end

  def ==(other)
    if @transparent_address != other.transparent_address
      return false
    end
    if @index != other.index
      return false
    end

    true
  end
end
  
  # Record type ZcashUnifiedAddressAndDiversifierIndex
class ZcashUnifiedAddressAndDiversifierIndex
  attr_reader :address
  
  attr_reader :diversifier_index
  
  

  def initialize(address, diversifier_index)
    @address = address
    @diversifier_index = diversifier_index
  end

  def ==(other)
    if @address != other.address
      return false
    end
    if @diversifier_index != other.diversifier_index
      return false
    end

    true
  end
end
  

  
  
def self.decode_extended_full_viewing_key(hrp, s)
    hrp = hrp.to_s
    s = s.to_s
  result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_decode_extended_full_viewing_key,RustBuffer.allocFromString(hrp),RustBuffer.allocFromString(s))
  return ZcashExtendedFullViewingKey._uniffi_allocate(result)
end


  
  
def self.decode_extended_spending_key(hrp, s)
    hrp = hrp.to_s
    s = s.to_s
  result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_decode_extended_spending_key,RustBuffer.allocFromString(hrp),RustBuffer.allocFromString(s))
  return ZcashExtendedSpendingKey._uniffi_allocate(result)
end


  
  
def self.decode_payment_address(hrp, s)
    hrp = hrp.to_s
    s = s.to_s
  result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_decode_payment_address,RustBuffer.allocFromString(hrp),RustBuffer.allocFromString(s))
  return ZcashPaymentAddress._uniffi_allocate(result)
end


  
  
def self.decode_transparent_address(pubkey_version, script_version, s)
    pubkey_version = pubkey_version.map { |v| v.to_i }
    script_version = script_version.map { |v| v.to_i }
    s = s.to_s
  result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_decode_transparent_address,RustBuffer.alloc_from_Sequenceu8(pubkey_version),RustBuffer.alloc_from_Sequenceu8(script_version),RustBuffer.allocFromString(s))
  return ZcashTransparentAddress._uniffi_allocate(result)
end


  
  
def self.encode_extended_full_viewing_key(hrp, extfvk)
    hrp = hrp.to_s
    extfvk = extfvk
  result = Zcash.rust_call(:zcash_e53_encode_extended_full_viewing_key,RustBuffer.allocFromString(hrp),(ZcashExtendedFullViewingKey._uniffi_lower extfvk))
  return result.consumeIntoString
end


  
  
def self.encode_extended_spending_key(hrp, extsk)
    hrp = hrp.to_s
    extsk = extsk
  result = Zcash.rust_call(:zcash_e53_encode_extended_spending_key,RustBuffer.allocFromString(hrp),(ZcashExtendedSpendingKey._uniffi_lower extsk))
  return result.consumeIntoString
end


  
  
def self.encode_payment_address(hrp, addr)
    hrp = hrp.to_s
    addr = addr
  result = Zcash.rust_call(:zcash_e53_encode_payment_address,RustBuffer.allocFromString(hrp),(ZcashPaymentAddress._uniffi_lower addr))
  return result.consumeIntoString
end


  
  
def self.encode_payment_address_p(params, addr)
    params = params
    addr = addr
  result = Zcash.rust_call(:zcash_e53_encode_payment_address_p,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),(ZcashPaymentAddress._uniffi_lower addr))
  return result.consumeIntoString
end


  
  
def self.encode_transparent_address(pubkey_version, script_version, addr)
    pubkey_version = pubkey_version.map { |v| v.to_i }
    script_version = script_version.map { |v| v.to_i }
    addr = addr
  result = Zcash.rust_call(:zcash_e53_encode_transparent_address,RustBuffer.alloc_from_Sequenceu8(pubkey_version),RustBuffer.alloc_from_Sequenceu8(script_version),(ZcashTransparentAddress._uniffi_lower addr))
  return result.consumeIntoString
end


  
  
def self.encode_transparent_address_p(params, addr)
    params = params
    addr = addr
  result = Zcash.rust_call(:zcash_e53_encode_transparent_address_p,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),(ZcashTransparentAddress._uniffi_lower addr))
  return result.consumeIntoString
end


  

  
  class ZcashRecipientAddress

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashRecipientAddress_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashRecipientAddress instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.decode(params, address)
        params = params
        address = address.to_s
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashRecipientAddress_decode,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),RustBuffer.allocFromString(address)))
  end
  
def self.shielded(addr)
        addr = addr
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashRecipientAddress_shielded,(ZcashPaymentAddress._uniffi_lower addr)))
  end
  
def self.transparent(addr)
        addr = addr
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashRecipientAddress_transparent,(ZcashTransparentAddress._uniffi_lower addr)))
  end
  
def self.unified(addr)
        addr = addr
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashRecipientAddress_unified,(ZcashUnifiedAddress._uniffi_lower addr)))
  end
  

  
def encode(params)
        params = params
    result = Zcash.rust_call(:zcash_e53_ZcashRecipientAddress_encode,@pointer,RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
    return result.consumeIntoString
  end
  
end
  
  class ZcashUnifiedAddress

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashUnifiedAddress_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashUnifiedAddress instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(orchard, sapling, transparent)
        orchard = (orchard ? orchard : nil)
        sapling = (sapling ? sapling : nil)
        transparent = (transparent ? transparent : nil)
    pointer = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashUnifiedAddress_new,RustBuffer.alloc_from_OptionalTypeZcashOrchardAddress(orchard),RustBuffer.alloc_from_OptionalTypeZcashPaymentAddress(sapling),RustBuffer.alloc_from_OptionalTypeZcashTransparentAddress(transparent))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  
def self.decode(params, address)
        params = params
        address = address.to_s
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashUnifiedAddress_decode,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),RustBuffer.allocFromString(address)))
  end
  

  
def orchard()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedAddress_orchard,@pointer,)
    return result.consumeIntoOptionalTypeZcashOrchardAddress
  end
  
def sapling()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedAddress_sapling,@pointer,)
    return result.consumeIntoOptionalTypeZcashPaymentAddress
  end
  
def transparent()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedAddress_transparent,@pointer,)
    return result.consumeIntoOptionalTypeZcashTransparentAddress
  end
  
def encode(params)
        params = params
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedAddress_encode,@pointer,RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
    return result.consumeIntoString
  end
  
end
  
  class ZcashUnifiedFullViewingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashUnifiedFullViewingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashUnifiedFullViewingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(transparent, sapling, orchard)
        transparent = (transparent ? transparent : nil)
        sapling = (sapling ? sapling : nil)
        orchard = (orchard ? orchard : nil)
    pointer = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashUnifiedFullViewingKey_new,RustBuffer.alloc_from_OptionalTypeZcashAccountPubKey(transparent),RustBuffer.alloc_from_OptionalTypeZcashDiversifiableFullViewingKey(sapling),RustBuffer.alloc_from_OptionalTypeZcashOrchardFullViewingKey(orchard))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  
def self.decode(params, encoded)
        params = params
        encoded = encoded.to_s
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashUnifiedFullViewingKey_decode,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),RustBuffer.allocFromString(encoded)))
  end
  

  
def encode(params)
        params = params
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedFullViewingKey_encode,@pointer,RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
    return result.consumeIntoString
  end
  
def transparent()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedFullViewingKey_transparent,@pointer,)
    return result.consumeIntoOptionalTypeZcashAccountPubKey
  end
  
def sapling()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedFullViewingKey_sapling,@pointer,)
    return result.consumeIntoOptionalTypeZcashDiversifiableFullViewingKey
  end
  
def orchard()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedFullViewingKey_orchard,@pointer,)
    return result.consumeIntoOptionalTypeZcashOrchardFullViewingKey
  end
  
def address(j)
        j = j
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedFullViewingKey_address,@pointer,(ZcashDiversifierIndex._uniffi_lower j))
    return result.consumeIntoOptionalTypeZcashUnifiedAddress
  end
  
def find_address(j)
        j = j
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedFullViewingKey_find_address,@pointer,(ZcashDiversifierIndex._uniffi_lower j))
    return result.consumeIntoOptionalTypeZcashUnifiedAddressAndDiversifierIndex
  end
  
def default_address()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedFullViewingKey_default_address,@pointer,)
    return result.consumeIntoTypeZcashUnifiedAddressAndDiversifierIndex
  end
  
end
  
  class ZcashUnifiedSpendingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashUnifiedSpendingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashUnifiedSpendingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_seed(params, seed, account_id)
        params = params
        seed = seed.map { |v| v.to_i }
        account_id = account_id
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashUnifiedSpendingKey_from_seed,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),RustBuffer.alloc_from_Sequenceu8(seed),RustBuffer.alloc_from_TypeZcashAccountId(account_id)))
  end
  
def self.from_bytes(era, encoded)
        era = era
        encoded = encoded.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashUnifiedSpendingKey_from_bytes,RustBuffer.alloc_from_TypeZcashKeysEra(era),RustBuffer.alloc_from_Sequenceu8(encoded)))
  end
  

  
def to_unified_full_viewing_key()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedSpendingKey_to_unified_full_viewing_key,@pointer,)
    return ZcashUnifiedFullViewingKey._uniffi_allocate(result)
  end
  
def transparent()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedSpendingKey_transparent,@pointer,)
    return ZcashAccountPrivKey._uniffi_allocate(result)
  end
  
def sapling()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedSpendingKey_sapling,@pointer,)
    return ZcashExtendedSpendingKey._uniffi_allocate(result)
  end
  
def orchard()
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedSpendingKey_orchard,@pointer,)
    return ZcashOrchardSpendingKey._uniffi_allocate(result)
  end
  
def to_bytes(era)
        era = era
    result = Zcash.rust_call(:zcash_e53_ZcashUnifiedSpendingKey_to_bytes,@pointer,RustBuffer.alloc_from_TypeZcashKeysEra(era))
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOrchardNote

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardNote_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardNote instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_parts(recipient, value, rho, rseed)
        recipient = recipient
        value = value
        rho = rho
        rseed = rseed
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardNote_from_parts,(ZcashOrchardAddress._uniffi_lower recipient),(ZcashOrchardNoteValue._uniffi_lower value),(ZcashOrchardNullifier._uniffi_lower rho),(ZcashOrchardRandomSeed._uniffi_lower rseed)))
  end
  

  
def recipient()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardNote_recipient,@pointer,)
    return ZcashOrchardAddress._uniffi_allocate(result)
  end
  
def value()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardNote_value,@pointer,)
    return ZcashOrchardNoteValue._uniffi_allocate(result)
  end
  
def commitment()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardNote_commitment,@pointer,)
    return ZcashOrchardNoteCommitment._uniffi_allocate(result)
  end
  
end
  
  class ZcashOrchardNullifier

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardNullifier_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardNullifier instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardNullifier_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardNullifier_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOrchardRandomSeed

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardRandomSeed_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardRandomSeed instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data, rho)
        data = data.map { |v| v.to_i }
        rho = rho
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardRandomSeed_from_bytes,RustBuffer.alloc_from_Sequenceu8(data),(ZcashOrchardNullifier._uniffi_lower rho)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardRandomSeed_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOrchardNoteCommitment

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardNoteCommitment_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardNoteCommitment instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def to_extracted_note_commitment()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardNoteCommitment_to_extracted_note_commitment,@pointer,)
    return ZcashExtractedNoteCommitment._uniffi_allocate(result)
  end
  
end
  
  class ZcashExtractedNoteCommitment

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashExtractedNoteCommitment_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashExtractedNoteCommitment instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtractedNoteCommitment_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashExtractedNoteCommitment_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOrchardAddress

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardAddress_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardAddress instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_raw_address_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardAddress_from_raw_address_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  

  
def diversifier()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardAddress_diversifier,@pointer,)
    return ZcashOrchardDiversifier._uniffi_allocate(result)
  end
  
def to_raw_address_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardAddress_to_raw_address_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashVerifyingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashVerifyingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashVerifyingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize()
    pointer = Zcash.rust_call(:zcash_e53_ZcashVerifyingKey_new,)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
end
  
  class ZcashProvingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashProvingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashProvingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize()
    pointer = Zcash.rust_call(:zcash_e53_ZcashProvingKey_new,)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
end
  
  class ZcashOrchardBundle

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardBundle_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardBundle instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def actions()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardBundle_actions,@pointer,)
    return result.consumeIntoSequenceTypeZcashOrchardAction
  end
  
def flags()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardBundle_flags,@pointer,)
    return ZcashOrchardFlags._uniffi_allocate(result)
  end
  
def value_balance()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardBundle_value_balance,@pointer,)
    return ZcashAmount._uniffi_allocate(result)
  end
  
def anchor()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardBundle_anchor,@pointer,)
    return ZcashAnchor._uniffi_allocate(result)
  end
  
def verify_proof(key)
        key = key
      Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardBundle_verify_proof,@pointer,(ZcashVerifyingKey._uniffi_lower key))
  end
  
  
def decrypt_output_with_key(action_idx, ivk)
        action_idx = action_idx.to_i
        ivk = ivk
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardBundle_decrypt_output_with_key,@pointer,action_idx,(ZcashOrchardIncomingViewingKey._uniffi_lower ivk))
    return result.consumeIntoTypeZcashOrchardDecryptOutput
  end
  
def decrypt_output_with_keys(ivks)
        ivks = ivks
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardBundle_decrypt_output_with_keys,@pointer,RustBuffer.alloc_from_SequenceTypeZcashOrchardIncomingViewingKey(ivks))
    return result.consumeIntoSequenceTypeZcashOrchardDecryptOutputForIncomingKeys
  end
  
def recover_output_with_ovk(action_idx, ovk)
        action_idx = action_idx.to_i
        ovk = ovk
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardBundle_recover_output_with_ovk,@pointer,action_idx,(ZcashOrchardOutgoingViewingKey._uniffi_lower ovk))
    return result.consumeIntoTypeZcashOrchardDecryptOutput
  end
  
def recover_outputs_with_ovks(ovks)
        ovks = ovks
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardBundle_recover_outputs_with_ovks,@pointer,RustBuffer.alloc_from_SequenceTypeZcashOrchardOutgoingViewingKey(ovks))
    return result.consumeIntoSequenceTypeZcashOrchardDecryptOutputForOutgoingKeys
  end
  
end
  
  class ZcashOrchardFlags

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardFlags_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardFlags instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_parts(spends_enabled, outputs_enabled)
        spends_enabled = spends_enabled ? true : false
        outputs_enabled = outputs_enabled ? true : false
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashOrchardFlags_from_parts,(spends_enabled ? 1 : 0),(outputs_enabled ? 1 : 0)))
  end
  
def self.from_byte(v)
        v = v.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardFlags_from_byte,v))
  end
  

  
def spends_enabled()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardFlags_spends_enabled,@pointer,)
    return 1 == result
  end
  
def outputs_enabled()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardFlags_outputs_enabled,@pointer,)
    return 1 == result
  end
  
def to_byte()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardFlags_to_byte,@pointer,)
    return result.to_i
  end
  
end
  
  class ZcashOrchardNoteValue

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardNoteValue_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardNoteValue instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_raw(value)
        value = value.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashOrchardNoteValue_from_raw,value))
  end
  

  
def value()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardNoteValue_value,@pointer,)
    return result.to_i
  end
  
end
  
  class ZcashOrchardValueCommitment

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardValueCommitment_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardValueCommitment instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardValueCommitment_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOrchardAction

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardAction_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardAction instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def nullifier()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardAction_nullifier,@pointer,)
    return ZcashOrchardNullifier._uniffi_allocate(result)
  end
  
def cmx()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardAction_cmx,@pointer,)
    return ZcashExtractedNoteCommitment._uniffi_allocate(result)
  end
  
def encrypted_note()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardAction_encrypted_note,@pointer,)
    return result.consumeIntoTypeZcashOrchardTransmittedNoteCiphertext
  end
  
def cv_net()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardAction_cv_net,@pointer,)
    return ZcashOrchardValueCommitment._uniffi_allocate(result)
  end
  
end
  
  class ZcashOrchardFullViewingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardFullViewingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardFullViewingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardFullViewingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  

  
def address_at(j, scope)
        j = j
        scope = scope
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardFullViewingKey_address_at,@pointer,(ZcashOrchardDiversifierIndex._uniffi_lower j),RustBuffer.alloc_from_TypeZcashOrchardScope(scope))
    return ZcashOrchardAddress._uniffi_allocate(result)
  end
  
def address(d, scope)
        d = d
        scope = scope
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardFullViewingKey_address,@pointer,(ZcashOrchardDiversifier._uniffi_lower d),RustBuffer.alloc_from_TypeZcashOrchardScope(scope))
    return ZcashOrchardAddress._uniffi_allocate(result)
  end
  
def scope_for_address(address)
        address = address
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardFullViewingKey_scope_for_address,@pointer,(ZcashOrchardAddress._uniffi_lower address))
    return result.consumeIntoOptionalTypeZcashOrchardScope
  end
  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardFullViewingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def to_ivk(scope)
        scope = scope
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardFullViewingKey_to_ivk,@pointer,RustBuffer.alloc_from_TypeZcashOrchardScope(scope))
    return ZcashOrchardIncomingViewingKey._uniffi_allocate(result)
  end
  
def to_ovk(scope)
        scope = scope
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardFullViewingKey_to_ovk,@pointer,RustBuffer.alloc_from_TypeZcashOrchardScope(scope))
    return ZcashOrchardOutgoingViewingKey._uniffi_allocate(result)
  end
  
end
  
  class ZcashOrchardSpendingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardSpendingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardSpendingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardSpendingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  
def self.from_zip32_seed(seed, coin_type, account)
        seed = seed.map { |v| v.to_i }
        coin_type = coin_type.to_i
        account = account.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardSpendingKey_from_zip32_seed,RustBuffer.alloc_from_Sequenceu8(seed),coin_type,account))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardSpendingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def to_fvk()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardSpendingKey_to_fvk,@pointer,)
    return ZcashOrchardFullViewingKey._uniffi_allocate(result)
  end
  
end
  
  class ZcashAnchor

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashAnchor_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashAnchor instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashAnchor_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashAnchor_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOrchardIncomingViewingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardIncomingViewingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardIncomingViewingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardIncomingViewingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardIncomingViewingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def diversifier_index(addr)
        addr = addr
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardIncomingViewingKey_diversifier_index,@pointer,(ZcashOrchardAddress._uniffi_lower addr))
    return result.consumeIntoOptionalTypeZcashOrchardDiversifierIndex
  end
  
def address_at(j)
        j = j
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardIncomingViewingKey_address_at,@pointer,(ZcashOrchardDiversifierIndex._uniffi_lower j))
    return ZcashOrchardAddress._uniffi_allocate(result)
  end
  
def address(diversifier)
        diversifier = diversifier
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardIncomingViewingKey_address,@pointer,(ZcashOrchardDiversifier._uniffi_lower diversifier))
    return ZcashOrchardAddress._uniffi_allocate(result)
  end
  
end
  
  class ZcashOrchardDiversifier

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardDiversifier_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardDiversifier instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardDiversifier_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardDiversifier_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOrchardOutgoingViewingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardOutgoingViewingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardOutgoingViewingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardOutgoingViewingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardOutgoingViewingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOrchardMerklePath

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardMerklePath_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardMerklePath instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_parts(position, auth_path)
        position = position.to_i
        auth_path = auth_path
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardMerklePath_from_parts,position,RustBuffer.alloc_from_SequenceTypeZcashOrchardMerkleHash(auth_path)))
  end
  

  
def root(cmx)
        cmx = cmx
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardMerklePath_root,@pointer,(ZcashExtractedNoteCommitment._uniffi_lower cmx))
    return ZcashAnchor._uniffi_allocate(result)
  end
  
end
  
  class ZcashOrchardMerkleHash

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardMerkleHash_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardMerkleHash instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardMerkleHash_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  
def self.from_cmx(cmx)
        cmx = cmx
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashOrchardMerkleHash_from_cmx,(ZcashExtractedNoteCommitment._uniffi_lower cmx)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardMerkleHash_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOrchardDiversifierIndex

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardDiversifierIndex_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardDiversifierIndex instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(b)
        b = b.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardDiversifierIndex_from_bytes,RustBuffer.alloc_from_Sequenceu8(b)))
  end
  
def self.from_u32(i)
        i = i.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashOrchardDiversifierIndex_from_u32,i))
  end
  
def self.from_u64(i)
        i = i.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashOrchardDiversifierIndex_from_u64,i))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOrchardDiversifierIndex_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashExtendedPrivKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashExtendedPrivKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashExtendedPrivKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.random()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtendedPrivKey_random,))
  end
  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtendedPrivKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  
def self.random_with_seed_size(seed_size)
        seed_size = seed_size
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtendedPrivKey_random_with_seed_size,RustBuffer.alloc_from_TypeZcashKeySeed(seed_size)))
  end
  
def self.with_seed(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtendedPrivKey_with_seed,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedPrivKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def derive_private_key(key_index)
        key_index = key_index
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtendedPrivKey_derive_private_key,@pointer,(ZcashKeyIndex._uniffi_lower key_index))
    return ZcashExtendedPrivKey._uniffi_allocate(result)
  end
  
end
  
  class ZcashKeyIndex

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashKeyIndex_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashKeyIndex instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_u32(i)
        i = i.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashKeyIndex_from_u32,i))
  end
  
def self.hardened_from_normalize_index(i)
        i = i.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashKeyIndex_hardened_from_normalize_index,i))
  end
  
def self.from_index(i)
        i = i.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashKeyIndex_from_index,i))
  end
  

  
def raw_index()
    result = Zcash.rust_call(:zcash_e53_ZcashKeyIndex_raw_index,@pointer,)
    return result.to_i
  end
  
def normalize_index()
    result = Zcash.rust_call(:zcash_e53_ZcashKeyIndex_normalize_index,@pointer,)
    return result.to_i
  end
  
def is_valid()
    result = Zcash.rust_call(:zcash_e53_ZcashKeyIndex_is_valid,@pointer,)
    return 1 == result
  end
  
end
  
  class ZcashZip317FeeRule

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashZip317FeeRule_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashZip317FeeRule instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.standard()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashZip317FeeRule_standard,))
  end
  
def self.non_standard(marginal_fee, grace_actions, p2pkh_standard_input_size, p2pkh_standard_output_size)
        marginal_fee = marginal_fee
        grace_actions = grace_actions.to_i
        p2pkh_standard_input_size = p2pkh_standard_input_size.to_i
        p2pkh_standard_output_size = p2pkh_standard_output_size.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashZip317FeeRule_non_standard,(ZcashAmount._uniffi_lower marginal_fee),grace_actions,p2pkh_standard_input_size,p2pkh_standard_output_size))
  end
  

  
def marginal_fee()
    result = Zcash.rust_call(:zcash_e53_ZcashZip317FeeRule_marginal_fee,@pointer,)
    return ZcashAmount._uniffi_allocate(result)
  end
  
end
  
  class ZcashFixedFeeRule

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashFixedFeeRule_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashFixedFeeRule instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.non_standard(fixed_fee)
        fixed_fee = fixed_fee
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashFixedFeeRule_non_standard,(ZcashAmount._uniffi_lower fixed_fee)))
  end
  
def self.standard()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashFixedFeeRule_standard,))
  end
  

  
def fixed_fee()
    result = Zcash.rust_call(:zcash_e53_ZcashFixedFeeRule_fixed_fee,@pointer,)
    return ZcashAmount._uniffi_allocate(result)
  end
  
end
  
  class ZcashTransparentBundle

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashTransparentBundle_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashTransparentBundle instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def is_coinbase()
    result = Zcash.rust_call(:zcash_e53_ZcashTransparentBundle_is_coinbase,@pointer,)
    return 1 == result
  end
  
def vin()
    result = Zcash.rust_call(:zcash_e53_ZcashTransparentBundle_vin,@pointer,)
    return result.consumeIntoSequenceTypeZcashTxIn
  end
  
def vout()
    result = Zcash.rust_call(:zcash_e53_ZcashTransparentBundle_vout,@pointer,)
    return result.consumeIntoSequenceTypeZcashTxOut
  end
  
end
  
  class ZcashTxOut

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashTxOut_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashTxOut instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(value, script_pubkey)
        value = value
        script_pubkey = script_pubkey
    pointer = Zcash.rust_call(:zcash_e53_ZcashTxOut_new,(ZcashAmount._uniffi_lower value),(ZcashScript._uniffi_lower script_pubkey))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
def value()
    result = Zcash.rust_call(:zcash_e53_ZcashTxOut_value,@pointer,)
    return ZcashAmount._uniffi_allocate(result)
  end
  
def script_pubkey()
    result = Zcash.rust_call(:zcash_e53_ZcashTxOut_script_pubkey,@pointer,)
    return ZcashScript._uniffi_allocate(result)
  end
  
def to_bytes()
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTxOut_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def recipient_address()
    result = Zcash.rust_call(:zcash_e53_ZcashTxOut_recipient_address,@pointer,)
    return result.consumeIntoOptionalTypeZcashTransparentAddress
  end
  
end
  
  class ZcashTxIn

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashTxIn_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashTxIn instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def to_bytes()
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTxIn_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashTransactionBuilder

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashTransactionBuilder_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashTransactionBuilder instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(parameters, block_height)
        parameters = parameters
        block_height = block_height
    pointer = Zcash.rust_call(:zcash_e53_ZcashTransactionBuilder_new,RustBuffer.alloc_from_TypeZcashConsensusParameters(parameters),(ZcashBlockHeight._uniffi_lower block_height))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
def add_sapling_spend(extsk, diversifier, note, merkle_path)
        extsk = extsk
        diversifier = diversifier
        note = note
        merkle_path = merkle_path
      Zcash.rust_call(:zcash_e53_ZcashTransactionBuilder_add_sapling_spend,@pointer,(ZcashExtendedSpendingKey._uniffi_lower extsk),(ZcashDiversifier._uniffi_lower diversifier),(ZcashSaplingNote._uniffi_lower note),(ZcashSaplingMerklePath._uniffi_lower merkle_path))
  end
  
  
def add_sapling_output(ovk, to, value, memo)
        ovk = (ovk ? ovk : nil)
        to = to
        value = value
        memo = memo
      Zcash.rust_call(:zcash_e53_ZcashTransactionBuilder_add_sapling_output,@pointer,RustBuffer.alloc_from_OptionalTypeZcashOutgoingViewingKey(ovk),(ZcashPaymentAddress._uniffi_lower to),(ZcashAmount._uniffi_lower value),(ZcashMemoBytes._uniffi_lower memo))
  end
  
  
def add_transparent_input(sk, utxo, coin)
        sk = sk
        utxo = utxo
        coin = coin
      Zcash.rust_call(:zcash_e53_ZcashTransactionBuilder_add_transparent_input,@pointer,(SecpSecretKey._uniffi_lower sk),(ZcashOutPoint._uniffi_lower utxo),(ZcashTxOut._uniffi_lower coin))
  end
  
  
def add_transparent_output(to, value)
        to = to
        value = value
      Zcash.rust_call(:zcash_e53_ZcashTransactionBuilder_add_transparent_output,@pointer,(ZcashTransparentAddress._uniffi_lower to),(ZcashAmount._uniffi_lower value))
  end
  
  
def build(prover, fee_rule)
        prover = prover
        fee_rule = fee_rule
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTransactionBuilder_build,@pointer,(ZcashLocalTxProver._uniffi_lower prover),RustBuffer.alloc_from_TypeZcashFeeRules(fee_rule))
    return result.consumeIntoTypeZcashTransactionAndSaplingMetadata
  end
  
end
  
  class ZcashTransaction

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashTransaction_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashTransaction instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data, consensus_branch_id)
        data = data.map { |v| v.to_i }
        consensus_branch_id = consensus_branch_id
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTransaction_from_bytes,RustBuffer.alloc_from_Sequenceu8(data),RustBuffer.alloc_from_TypeZcashBranchId(consensus_branch_id)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTransaction_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def txid()
    result = Zcash.rust_call(:zcash_e53_ZcashTransaction_txid,@pointer,)
    return ZcashTxId._uniffi_allocate(result)
  end
  
def version()
    result = Zcash.rust_call(:zcash_e53_ZcashTransaction_version,@pointer,)
    return ZcashTxVersion._uniffi_allocate(result)
  end
  
def consensus_branch_id()
    result = Zcash.rust_call(:zcash_e53_ZcashTransaction_consensus_branch_id,@pointer,)
    return result.consumeIntoTypeZcashBranchId
  end
  
def lock_time()
    result = Zcash.rust_call(:zcash_e53_ZcashTransaction_lock_time,@pointer,)
    return result.to_i
  end
  
def expiry_height()
    result = Zcash.rust_call(:zcash_e53_ZcashTransaction_expiry_height,@pointer,)
    return ZcashBlockHeight._uniffi_allocate(result)
  end
  
def transparent_bundle()
    result = Zcash.rust_call(:zcash_e53_ZcashTransaction_transparent_bundle,@pointer,)
    return result.consumeIntoOptionalTypeZcashTransparentBundle
  end
  
def sapling_bundle()
    result = Zcash.rust_call(:zcash_e53_ZcashTransaction_sapling_bundle,@pointer,)
    return result.consumeIntoOptionalTypeZcashSaplingBundle
  end
  
def orchard_bundle()
    result = Zcash.rust_call(:zcash_e53_ZcashTransaction_orchard_bundle,@pointer,)
    return result.consumeIntoOptionalTypeZcashOrchardBundle
  end
  
end
  
  class ZcashTxId

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashTxId_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashTxId instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTxId_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTxId_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOrchardTransactionBuilder

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOrchardTransactionBuilder_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOrchardTransactionBuilder instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(parameters, target_height, expiry_height, anchor, flags)
        parameters = parameters
        target_height = target_height
        expiry_height = expiry_height
        anchor = anchor
        flags = flags
    pointer = Zcash.rust_call(:zcash_e53_ZcashOrchardTransactionBuilder_new,RustBuffer.alloc_from_TypeZcashConsensusParameters(parameters),(ZcashBlockHeight._uniffi_lower target_height),(ZcashBlockHeight._uniffi_lower expiry_height),(ZcashAnchor._uniffi_lower anchor),(ZcashOrchardFlags._uniffi_lower flags))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
def add_spend(fvk, note, merkle_path)
        fvk = fvk
        note = note
        merkle_path = merkle_path
      Zcash.rust_call(:zcash_e53_ZcashOrchardTransactionBuilder_add_spend,@pointer,(ZcashOrchardFullViewingKey._uniffi_lower fvk),(ZcashOrchardNote._uniffi_lower note),(ZcashOrchardMerklePath._uniffi_lower merkle_path))
  end
  
  
def add_recipient(ovk, recipient, value, memo)
        ovk = (ovk ? ovk : nil)
        recipient = recipient
        value = value.to_i
        memo = (memo ? memo.map { |v| v.to_i } : nil)
      Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardTransactionBuilder_add_recipient,@pointer,RustBuffer.alloc_from_OptionalTypeZcashOrchardOutgoingViewingKey(ovk),(ZcashOrchardAddress._uniffi_lower recipient),value,RustBuffer.alloc_from_OptionalSequenceu8(memo))
  end
  
  
def build(keys, sighash)
        keys = keys
        sighash = sighash.map { |v| v.to_i }
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOrchardTransactionBuilder_build,@pointer,RustBuffer.alloc_from_SequenceTypeZcashOrchardSpendingKey(keys),RustBuffer.alloc_from_Sequenceu8(sighash))
    return ZcashTransaction._uniffi_allocate(result)
  end
  
end
  
  class ZcashTxVersion

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashTxVersion_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashTxVersion instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTxVersion_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  
def self.suggested_for_branch(consensus_branch_id)
        consensus_branch_id = consensus_branch_id
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashTxVersion_suggested_for_branch,RustBuffer.alloc_from_TypeZcashBranchId(consensus_branch_id)))
  end
  

  
def selection()
    result = Zcash.rust_call(:zcash_e53_ZcashTxVersion_selection,@pointer,)
    return result.consumeIntoTypeZcashTxVersionSelection
  end
  
def header()
    result = Zcash.rust_call(:zcash_e53_ZcashTxVersion_header,@pointer,)
    return result.to_i
  end
  
def version_group_id()
    result = Zcash.rust_call(:zcash_e53_ZcashTxVersion_version_group_id,@pointer,)
    return result.to_i
  end
  
def to_bytes()
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTxVersion_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def has_sprout()
    result = Zcash.rust_call(:zcash_e53_ZcashTxVersion_has_sprout,@pointer,)
    return 1 == result
  end
  
def has_overwinter()
    result = Zcash.rust_call(:zcash_e53_ZcashTxVersion_has_overwinter,@pointer,)
    return 1 == result
  end
  
def has_sapling()
    result = Zcash.rust_call(:zcash_e53_ZcashTxVersion_has_sapling,@pointer,)
    return 1 == result
  end
  
def has_orchard()
    result = Zcash.rust_call(:zcash_e53_ZcashTxVersion_has_orchard,@pointer,)
    return 1 == result
  end
  
end
  
  class ZcashOutPoint

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOutPoint_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOutPoint instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(hash, n)
        hash = hash.map { |v| v.to_i }
        n = n.to_i
    pointer = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOutPoint_new,RustBuffer.alloc_from_Sequenceu8(hash),n)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
end
  
  class ZcashAmount

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashAmount_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashAmount instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(amount)
        amount = amount.to_i
    pointer = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashAmount_new,amount)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  
def self.zero()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashAmount_zero,))
  end
  

  
def value()
    result = Zcash.rust_call(:zcash_e53_ZcashAmount_value,@pointer,)
    return result.to_i
  end
  
end
  
  class ZcashSaplingSpendDescription

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingSpendDescription_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingSpendDescription instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def cv()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingSpendDescription_cv,@pointer,)
    return ZcashSaplingValueCommitment._uniffi_allocate(result)
  end
  
def anchor()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingSpendDescription_anchor,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def nullifier()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingSpendDescription_nullifier,@pointer,)
    return ZcashSaplingNullifier._uniffi_allocate(result)
  end
  
def rk()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingSpendDescription_rk,@pointer,)
    return ZcashSaplingPublicKey._uniffi_allocate(result)
  end
  
end
  
  class ZcashSaplingBundle

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingBundle_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingBundle instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def shielded_spends()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingBundle_shielded_spends,@pointer,)
    return result.consumeIntoSequenceTypeZcashSaplingSpendDescription
  end
  
def shielded_outputs()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingBundle_shielded_outputs,@pointer,)
    return result.consumeIntoSequenceTypeZcashSaplingOutputDescription
  end
  
def value_balance()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingBundle_value_balance,@pointer,)
    return ZcashAmount._uniffi_allocate(result)
  end
  
end
  
  class ZcashSaplingOutputDescription

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingOutputDescription_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingOutputDescription instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def cv()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingOutputDescription_cv,@pointer,)
    return ZcashSaplingValueCommitment._uniffi_allocate(result)
  end
  
def cmu()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingOutputDescription_cmu,@pointer,)
    return ZcashSaplingExtractedNoteCommitment._uniffi_allocate(result)
  end
  
end
  
  class ZcashSaplingMetadata

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingMetadata_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingMetadata instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize()
    pointer = Zcash.rust_call(:zcash_e53_ZcashSaplingMetadata_new,)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
def spend_index(n)
        n = n.to_i
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingMetadata_spend_index,@pointer,n)
    return result.consumeIntoOptionalu64
  end
  
def output_index(n)
        n = n.to_i
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingMetadata_output_index,@pointer,n)
    return result.consumeIntoOptionalu64
  end
  
end
  
  class ZcashBlockHeight

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashBlockHeight_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashBlockHeight instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(v)
        v = v.to_i
    pointer = Zcash.rust_call(:zcash_e53_ZcashBlockHeight_new,v)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
def value()
    result = Zcash.rust_call(:zcash_e53_ZcashBlockHeight_value,@pointer,)
    return result.to_i
  end
  
end
  
  class ZcashCommitmentTree

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashCommitmentTree_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashCommitmentTree instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.empty()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashCommitmentTree_empty,))
  end
  

  
def append(node)
        node = node
      Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashCommitmentTree_append,@pointer,(ZcashSaplingNode._uniffi_lower node))
  end
  
  
end
  
  class ZcashSaplingMerklePath

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingMerklePath_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingMerklePath instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def auth_path()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingMerklePath_auth_path,@pointer,)
    return result.consumeIntoSequenceTypeZcashAuthPath
  end
  
def position()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingMerklePath_position,@pointer,)
    return result.to_i
  end
  
end
  
  class ZcashIncrementalWitness

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashIncrementalWitness_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashIncrementalWitness instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_tree(tree)
        tree = tree
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashIncrementalWitness_from_tree,(ZcashCommitmentTree._uniffi_lower tree)))
  end
  

  
def append(node)
        node = node
      Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashIncrementalWitness_append,@pointer,(ZcashSaplingNode._uniffi_lower node))
  end
  
  
def path()
    result = Zcash.rust_call(:zcash_e53_ZcashIncrementalWitness_path,@pointer,)
    return result.consumeIntoOptionalTypeZcashSaplingMerklePath
  end
  
end
  
  class ZcashTransparentAddress

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashTransparentAddress_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashTransparentAddress instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_public_key(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTransparentAddress_from_public_key,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  
def self.from_script(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTransparentAddress_from_script,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  
def self.decode(params, input)
        params = params
        input = input.to_s
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashTransparentAddress_decode,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),RustBuffer.allocFromString(input)))
  end
  

  
def encode(params)
        params = params
    result = Zcash.rust_call(:zcash_e53_ZcashTransparentAddress_encode,@pointer,RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
    return result.consumeIntoString
  end
  
def is_public_key()
    result = Zcash.rust_call(:zcash_e53_ZcashTransparentAddress_is_public_key,@pointer,)
    return 1 == result
  end
  
def is_script()
    result = Zcash.rust_call(:zcash_e53_ZcashTransparentAddress_is_script,@pointer,)
    return 1 == result
  end
  
def script()
    result = Zcash.rust_call(:zcash_e53_ZcashTransparentAddress_script,@pointer,)
    return ZcashScript._uniffi_allocate(result)
  end
  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashTransparentAddress_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashExternalIvk

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashExternalIvk_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashExternalIvk instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExternalIvk_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  

  
def derive_address(child_index)
        child_index = child_index.to_i
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExternalIvk_derive_address,@pointer,child_index)
    return ZcashTransparentAddress._uniffi_allocate(result)
  end
  
def default_address()
    result = Zcash.rust_call(:zcash_e53_ZcashExternalIvk_default_address,@pointer,)
    return result.consumeIntoTypeZcashTransparentAddressAndIndex
  end
  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashExternalIvk_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashInternalIvk

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashInternalIvk_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashInternalIvk instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashInternalIvk_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  

  
def default_address()
    result = Zcash.rust_call(:zcash_e53_ZcashInternalIvk_default_address,@pointer,)
    return result.consumeIntoTypeZcashTransparentAddressAndIndex
  end
  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashInternalIvk_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashExternalOvk

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashExternalOvk_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashExternalOvk instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def as_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashExternalOvk_as_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashInternalOvk

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashInternalOvk_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashInternalOvk instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def as_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashInternalOvk_as_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashAccountPubKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashAccountPubKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashAccountPubKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(data)
        data = data.map { |v| v.to_i }
    pointer = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashAccountPubKey_new,RustBuffer.alloc_from_Sequenceu8(data))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
def derive_external_ivk()
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashAccountPubKey_derive_external_ivk,@pointer,)
    return ZcashExternalIvk._uniffi_allocate(result)
  end
  
def derive_internal_ivk()
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashAccountPubKey_derive_internal_ivk,@pointer,)
    return ZcashInternalIvk._uniffi_allocate(result)
  end
  
def ovks_for_shielding()
    result = Zcash.rust_call(:zcash_e53_ZcashAccountPubKey_ovks_for_shielding,@pointer,)
    return result.consumeIntoTypeZcashInternalOvkExternalOvk
  end
  
def internal_ovk()
    result = Zcash.rust_call(:zcash_e53_ZcashAccountPubKey_internal_ovk,@pointer,)
    return ZcashInternalOvk._uniffi_allocate(result)
  end
  
def external_ovk()
    result = Zcash.rust_call(:zcash_e53_ZcashAccountPubKey_external_ovk,@pointer,)
    return ZcashExternalOvk._uniffi_allocate(result)
  end
  
def serialize()
    result = Zcash.rust_call(:zcash_e53_ZcashAccountPubKey_serialize,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashAccountPrivKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashAccountPrivKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashAccountPrivKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_seed(params, seed, account_id)
        params = params
        seed = seed.map { |v| v.to_i }
        account_id = account_id
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashAccountPrivKey_from_seed,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),RustBuffer.alloc_from_Sequenceu8(seed),RustBuffer.alloc_from_TypeZcashAccountId(account_id)))
  end
  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashAccountPrivKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  
def self.from_extended_privkey(key)
        key = key
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashAccountPrivKey_from_extended_privkey,(ZcashExtendedPrivKey._uniffi_lower key)))
  end
  

  
def to_account_pubkey()
    result = Zcash.rust_call(:zcash_e53_ZcashAccountPrivKey_to_account_pubkey,@pointer,)
    return ZcashAccountPubKey._uniffi_allocate(result)
  end
  
def derive_external_secret_key(child_index)
        child_index = child_index.to_i
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashAccountPrivKey_derive_external_secret_key,@pointer,child_index)
    return SecpSecretKey._uniffi_allocate(result)
  end
  
def derive_internal_secret_key(child_index)
        child_index = child_index.to_i
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashAccountPrivKey_derive_internal_secret_key,@pointer,child_index)
    return SecpSecretKey._uniffi_allocate(result)
  end
  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashAccountPrivKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashScript

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashScript_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashScript instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashScript_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashScript_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashSaplingValueCommitment

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingValueCommitment_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingValueCommitment instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingValueCommitment_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashSaplingNote

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingNote_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingNote instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_parts(recipient, value, rseed)
        recipient = recipient
        value = value
        rseed = rseed
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashSaplingNote_from_parts,(ZcashPaymentAddress._uniffi_lower recipient),(ZcashSaplingNoteValue._uniffi_lower value),RustBuffer.alloc_from_TypeZcashRseed(rseed)))
  end
  

  
def value()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingNote_value,@pointer,)
    return ZcashSaplingNoteValue._uniffi_allocate(result)
  end
  
def cmu()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingNote_cmu,@pointer,)
    return ZcashSaplingExtractedNoteCommitment._uniffi_allocate(result)
  end
  
end
  
  class ZcashSaplingNoteValue

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingNoteValue_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingNoteValue instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_raw(data)
        data = data.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashSaplingNoteValue_from_raw,data))
  end
  

  
def inner()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingNoteValue_inner,@pointer,)
    return result.to_i
  end
  
end
  
  class ZcashSaplingNullifier

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingNullifier_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingNullifier instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingNullifier_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashSaplingExtractedNoteCommitment

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingExtractedNoteCommitment_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingExtractedNoteCommitment instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(data)
        data = data.map { |v| v.to_i }
    pointer = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashSaplingExtractedNoteCommitment_new,RustBuffer.alloc_from_Sequenceu8(data))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingExtractedNoteCommitment_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashPaymentAddress

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashPaymentAddress_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashPaymentAddress instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashPaymentAddress_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  
def self.decode(params, input)
        params = params
        input = input.to_s
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashPaymentAddress_decode,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),RustBuffer.allocFromString(input)))
  end
  

  
def encode(params)
        params = params
    result = Zcash.rust_call(:zcash_e53_ZcashPaymentAddress_encode,@pointer,RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
    return result.consumeIntoString
  end
  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashPaymentAddress_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def diversifier()
    result = Zcash.rust_call(:zcash_e53_ZcashPaymentAddress_diversifier,@pointer,)
    return ZcashDiversifier._uniffi_allocate(result)
  end
  
def pk_d()
    result = Zcash.rust_call(:zcash_e53_ZcashPaymentAddress_pk_d,@pointer,)
    return ZcashSaplingDiversifiedTransmissionKey._uniffi_allocate(result)
  end
  
def create_note(value, rseed)
        value = value.to_i
        rseed = rseed
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashPaymentAddress_create_note,@pointer,value,RustBuffer.alloc_from_TypeZcashRseed(rseed))
    return ZcashSaplingNote._uniffi_allocate(result)
  end
  
end
  
  class ZcashSaplingIvk

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingIvk_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingIvk instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def to_payment_address(diversifier)
        diversifier = diversifier
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingIvk_to_payment_address,@pointer,(ZcashDiversifier._uniffi_lower diversifier))
    return result.consumeIntoOptionalTypeZcashPaymentAddress
  end
  
def to_repr()
    result = Zcash.rust_call(:zcash_e53_ZcashSaplingIvk_to_repr,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashDiversifier

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashDiversifier_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashDiversifier instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(bytes)
        bytes = bytes.map { |v| v.to_i }
    pointer = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashDiversifier_new,RustBuffer.alloc_from_Sequenceu8(bytes))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifier_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashFullViewingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashFullViewingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashFullViewingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashFullViewingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  
def self.from_expanded_spending_key(expsk)
        expsk = expsk
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashFullViewingKey_from_expanded_spending_key,(ZcashExpandedSpendingKey._uniffi_lower expsk)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashFullViewingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def vk()
    result = Zcash.rust_call(:zcash_e53_ZcashFullViewingKey_vk,@pointer,)
    return ZcashViewingKey._uniffi_allocate(result)
  end
  
def ovk()
    result = Zcash.rust_call(:zcash_e53_ZcashFullViewingKey_ovk,@pointer,)
    return ZcashOutgoingViewingKey._uniffi_allocate(result)
  end
  
end
  
  class ZcashNullifierDerivingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashNullifierDerivingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashNullifierDerivingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashNullifierDerivingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashNullifierDerivingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashOutgoingViewingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashOutgoingViewingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashOutgoingViewingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(b)
        b = b.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashOutgoingViewingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(b)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashOutgoingViewingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashExpandedSpendingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashExpandedSpendingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashExpandedSpendingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_spending_key(sk)
        sk = sk.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashExpandedSpendingKey_from_spending_key,RustBuffer.alloc_from_Sequenceu8(sk)))
  end
  
def self.from_bytes(b)
        b = b.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExpandedSpendingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(b)))
  end
  

  
def proof_generation_key()
    result = Zcash.rust_call(:zcash_e53_ZcashExpandedSpendingKey_proof_generation_key,@pointer,)
    return ZcashProofGenerationKey._uniffi_allocate(result)
  end
  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashExpandedSpendingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashProofGenerationKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashProofGenerationKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashProofGenerationKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def to_viewing_key()
    result = Zcash.rust_call(:zcash_e53_ZcashProofGenerationKey_to_viewing_key,@pointer,)
    return ZcashViewingKey._uniffi_allocate(result)
  end
  
end
  
  class ZcashDiversifiableFullViewingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashDiversifiableFullViewingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashDiversifiableFullViewingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashDiversifiableFullViewingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def fvk()
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_fvk,@pointer,)
    return ZcashFullViewingKey._uniffi_allocate(result)
  end
  
def to_nk(scope)
        scope = scope
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_to_nk,@pointer,RustBuffer.alloc_from_TypeZcashScope(scope))
    return ZcashNullifierDerivingKey._uniffi_allocate(result)
  end
  
def to_ivk(scope)
        scope = scope
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_to_ivk,@pointer,RustBuffer.alloc_from_TypeZcashScope(scope))
    return ZcashSaplingIvk._uniffi_allocate(result)
  end
  
def to_ovk(scope)
        scope = scope
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_to_ovk,@pointer,RustBuffer.alloc_from_TypeZcashScope(scope))
    return ZcashOutgoingViewingKey._uniffi_allocate(result)
  end
  
def address(j)
        j = j
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_address,@pointer,(ZcashDiversifierIndex._uniffi_lower j))
    return result.consumeIntoOptionalTypeZcashPaymentAddress
  end
  
def find_address(j)
        j = j
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_find_address,@pointer,(ZcashDiversifierIndex._uniffi_lower j))
    return result.consumeIntoOptionalTypeZcashDiversifierIndexAndPaymentAddress
  end
  
def default_address()
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_default_address,@pointer,)
    return result.consumeIntoTypeZcashDiversifierIndexAndPaymentAddress
  end
  
def diversified_address(diversifier)
        diversifier = diversifier
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_diversified_address,@pointer,(ZcashDiversifier._uniffi_lower diversifier))
    return result.consumeIntoOptionalTypeZcashPaymentAddress
  end
  
def change_address()
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_change_address,@pointer,)
    return result.consumeIntoTypeZcashDiversifierIndexAndPaymentAddress
  end
  
def diversified_change_address(diversifier)
        diversifier = diversifier
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_diversified_change_address,@pointer,(ZcashDiversifier._uniffi_lower diversifier))
    return result.consumeIntoOptionalTypeZcashPaymentAddress
  end
  
def decrypt_diversifier(addr)
        addr = addr
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifiableFullViewingKey_decrypt_diversifier,@pointer,(ZcashPaymentAddress._uniffi_lower addr))
    return result.consumeIntoOptionalTypeZcashDiversifierIndexAndScope
  end
  
end
  
  class ZcashSaplingDiversifiedTransmissionKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingDiversifiedTransmissionKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingDiversifiedTransmissionKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
end
  
  class ZcashViewingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashViewingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashViewingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def ivk()
    result = Zcash.rust_call(:zcash_e53_ZcashViewingKey_ivk,@pointer,)
    return ZcashSaplingIvk._uniffi_allocate(result)
  end
  
def to_payment_address(diversifier)
        diversifier = diversifier
    result = Zcash.rust_call(:zcash_e53_ZcashViewingKey_to_payment_address,@pointer,(ZcashDiversifier._uniffi_lower diversifier))
    return result.consumeIntoOptionalTypeZcashPaymentAddress
  end
  
end
  
  class ZcashExtendedFullViewingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashExtendedFullViewingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashExtendedFullViewingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(bytes)
        bytes = bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtendedFullViewingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(bytes)))
  end
  
def self.decode(params, input)
        params = params
        input = input.to_s
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtendedFullViewingKey_decode,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),RustBuffer.allocFromString(input)))
  end
  

  
def encode(params)
        params = params
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedFullViewingKey_encode,@pointer,RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
    return result.consumeIntoString
  end
  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedFullViewingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def address(j)
        j = j
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedFullViewingKey_address,@pointer,(ZcashDiversifierIndex._uniffi_lower j))
    return result.consumeIntoOptionalTypeZcashPaymentAddress
  end
  
def derive_child(i)
        i = i
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtendedFullViewingKey_derive_child,@pointer,RustBuffer.alloc_from_TypeZcashChildIndex(i))
    return ZcashExtendedFullViewingKey._uniffi_allocate(result)
  end
  
def find_address(j)
        j = j
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedFullViewingKey_find_address,@pointer,(ZcashDiversifierIndex._uniffi_lower j))
    return result.consumeIntoOptionalTypeZcashDiversifierIndexAndPaymentAddress
  end
  
def default_address()
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedFullViewingKey_default_address,@pointer,)
    return result.consumeIntoTypeZcashDiversifierIndexAndPaymentAddress
  end
  
def derive_internal()
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedFullViewingKey_derive_internal,@pointer,)
    return ZcashExtendedFullViewingKey._uniffi_allocate(result)
  end
  
def to_diversifiable_full_viewing_key()
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedFullViewingKey_to_diversifiable_full_viewing_key,@pointer,)
    return ZcashDiversifiableFullViewingKey._uniffi_allocate(result)
  end
  
end
  
  class ZcashSaplingPublicKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingPublicKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingPublicKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  

  
def to_bytes()
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashSaplingPublicKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashSaplingNode

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashSaplingNode_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashSaplingNode instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_cmu(cmu)
        cmu = cmu
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashSaplingNode_from_cmu,(ZcashSaplingExtractedNoteCommitment._uniffi_lower cmu)))
  end
  

  
end
  
  class ZcashExtendedSpendingKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashExtendedSpendingKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashExtendedSpendingKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.master(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashExtendedSpendingKey_master,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtendedSpendingKey_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  
def self.from_path(master, path)
        master = master
        path = path
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashExtendedSpendingKey_from_path,(ZcashExtendedSpendingKey._uniffi_lower master),RustBuffer.alloc_from_SequenceTypeZcashChildIndex(path)))
  end
  
def self.decode(params, input)
        params = params
        input = input.to_s
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashExtendedSpendingKey_decode,RustBuffer.alloc_from_TypeZcashConsensusParameters(params),RustBuffer.allocFromString(input)))
  end
  

  
def encode(params)
        params = params
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedSpendingKey_encode,@pointer,RustBuffer.alloc_from_TypeZcashConsensusParameters(params))
    return result.consumeIntoString
  end
  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedSpendingKey_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
def derive_child(index)
        index = index
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedSpendingKey_derive_child,@pointer,RustBuffer.alloc_from_TypeZcashChildIndex(index))
    return ZcashExtendedSpendingKey._uniffi_allocate(result)
  end
  
def default_address()
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedSpendingKey_default_address,@pointer,)
    return result.consumeIntoTypeZcashDiversifierIndexAndPaymentAddress
  end
  
def derive_internal()
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedSpendingKey_derive_internal,@pointer,)
    return ZcashExtendedSpendingKey._uniffi_allocate(result)
  end
  
def to_diversifiable_full_viewing_key()
    result = Zcash.rust_call(:zcash_e53_ZcashExtendedSpendingKey_to_diversifiable_full_viewing_key,@pointer,)
    return ZcashDiversifiableFullViewingKey._uniffi_allocate(result)
  end
  
end
  
  class ZcashDiversifierIndex

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashDiversifierIndex_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashDiversifierIndex instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize()
    pointer = Zcash.rust_call(:zcash_e53_ZcashDiversifierIndex_new,)
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  
def self.from_u32(i)
        i = i.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashDiversifierIndex_from_u32,i))
  end
  
def self.from_u64(i)
        i = i.to_i
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashDiversifierIndex_from_u64,i))
  end
  

  
def increment()
      Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashDiversifierIndex_increment,@pointer,)
  end
  
  
def to_u32()
    result = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashDiversifierIndex_to_u32,@pointer,)
    return result.to_i
  end
  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashDiversifierIndex_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashMemoBytes

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashMemoBytes_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashMemoBytes instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(data)
        data = data.map { |v| v.to_i }
    pointer = Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashMemoBytes_new,RustBuffer.alloc_from_Sequenceu8(data))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  
def self.empty()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashMemoBytes_empty,))
  end
  

  
def data()
    result = Zcash.rust_call(:zcash_e53_ZcashMemoBytes_data,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashLocalTxProver

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashLocalTxProver_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashLocalTxProver instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(spend_path, output_path)
        spend_path = spend_path.to_s
        output_path = output_path.to_s
    pointer = Zcash.rust_call(:zcash_e53_ZcashLocalTxProver_new,RustBuffer.allocFromString(spend_path),RustBuffer.allocFromString(output_path))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  
def self.from_bytes(spend_param_bytes, output_param_bytes)
        spend_param_bytes = spend_param_bytes.map { |v| v.to_i }
        output_param_bytes = output_param_bytes.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_ZcashLocalTxProver_from_bytes,RustBuffer.alloc_from_Sequenceu8(spend_param_bytes),RustBuffer.alloc_from_Sequenceu8(output_param_bytes)))
  end
  
def self.with_default_location()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashLocalTxProver_with_default_location,))
  end
  

  
end
  
  class SecpSecretKey

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_SecpSecretKey_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a SecpSecretKey instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end
def initialize(data)
        data = data.map { |v| v.to_i }
    pointer = Zcash.rust_call_with_error(ZcashError,:zcash_e53_SecpSecretKey_new,RustBuffer.alloc_from_Sequenceu8(data))
    @pointer = pointer
    ObjectSpace.define_finalizer(self, self.class._uniffi_define_finalizer_by_pointer(pointer, self.object_id))
  end

  

  
def serialize_secret()
    result = Zcash.rust_call(:zcash_e53_SecpSecretKey_serialize_secret,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class ZcashJubjubFr

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_ZcashJubjubFr_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a ZcashJubjubFr instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_bytes(data)
        data = data.map { |v| v.to_i }
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call_with_error(ZcashError,:zcash_e53_ZcashJubjubFr_from_bytes,RustBuffer.alloc_from_Sequenceu8(data)))
  end
  

  
def to_bytes()
    result = Zcash.rust_call(:zcash_e53_ZcashJubjubFr_to_bytes,@pointer,)
    return result.consumeIntoSequenceu8
  end
  
end
  
  class TestSupport

  # A private helper for initializing instances of the class from a raw pointer,
  # bypassing any initialization logic and ensuring they are GC'd properly.
  def self._uniffi_allocate(pointer)
    pointer.autorelease = false
    inst = allocate
    inst.instance_variable_set :@pointer, pointer
    ObjectSpace.define_finalizer(inst, _uniffi_define_finalizer_by_pointer(pointer, inst.object_id))
    return inst
  end

  # A private helper for registering an object finalizer.
  # N.B. it's important that this does not capture a reference
  # to the actual instance, only its underlying pointer.
  def self._uniffi_define_finalizer_by_pointer(pointer, object_id)
    Proc.new do |_id|
      Zcash.rust_call(
        :ffi_zcash_e53_TestSupport_object_free,
        pointer
      )
    end
  end

  # A private helper for lowering instances into a raw pointer.
  # This does an explicit typecheck, because accidentally lowering a different type of
  # object in a place where this type is expected, could lead to memory unsafety.
  def self._uniffi_lower(inst)
    if not inst.is_a? self
      raise TypeError.new "Expected a TestSupport instance, got #{inst}"
    end
    return inst.instance_variable_get :@pointer
  end

  
def self.from_csv_file()
    # Call the (fallible) function before creating any half-baked object instances.
    # Lightly yucky way to bypass the usual "initialize" logic
    # and just create a new instance with the required pointer.
    return _uniffi_allocate(Zcash.rust_call(:zcash_e53_TestSupport_from_csv_file,))
  end
  

  
def get_as_u8_array(key)
        key = key.to_s
    result = Zcash.rust_call(:zcash_e53_TestSupport_get_as_u8_array,@pointer,RustBuffer.allocFromString(key))
    return result.consumeIntoSequenceu8
  end
  
def get_as_u32_array(key)
        key = key.to_s
    result = Zcash.rust_call(:zcash_e53_TestSupport_get_as_u32_array,@pointer,RustBuffer.allocFromString(key))
    return result.consumeIntoSequenceu32
  end
  
def get_as_u64_array(key)
        key = key.to_s
    result = Zcash.rust_call(:zcash_e53_TestSupport_get_as_u64_array,@pointer,RustBuffer.allocFromString(key))
    return result.consumeIntoSequenceu64
  end
  
def get_as_u32(key)
        key = key.to_s
    result = Zcash.rust_call(:zcash_e53_TestSupport_get_as_u32,@pointer,RustBuffer.allocFromString(key))
    return result.to_i
  end
  
def get_as_u64(key)
        key = key.to_s
    result = Zcash.rust_call(:zcash_e53_TestSupport_get_as_u64,@pointer,RustBuffer.allocFromString(key))
    return result.to_i
  end
  
def get_as_string(key)
        key = key.to_s
    result = Zcash.rust_call(:zcash_e53_TestSupport_get_as_string,@pointer,RustBuffer.allocFromString(key))
    return result.consumeIntoString
  end
  
end
  
end

